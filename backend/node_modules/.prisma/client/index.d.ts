
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model aboutsection
 * 
 */
export type aboutsection = $Result.DefaultSelection<Prisma.$aboutsectionPayload>
/**
 * Model adminactionlog
 * 
 */
export type adminactionlog = $Result.DefaultSelection<Prisma.$adminactionlogPayload>
/**
 * Model advertisement
 * 
 */
export type advertisement = $Result.DefaultSelection<Prisma.$advertisementPayload>
/**
 * Model blogpost
 * 
 */
export type blogpost = $Result.DefaultSelection<Prisma.$blogpostPayload>
/**
 * Model branchchurch
 * 
 */
export type branchchurch = $Result.DefaultSelection<Prisma.$branchchurchPayload>
/**
 * Model churchmember
 * 
 */
export type churchmember = $Result.DefaultSelection<Prisma.$churchmemberPayload>
/**
 * Model collectionrecord
 * 
 */
export type collectionrecord = $Result.DefaultSelection<Prisma.$collectionrecordPayload>
/**
 * Model comment
 * 
 */
export type comment = $Result.DefaultSelection<Prisma.$commentPayload>
/**
 * Model contactmessage
 * 
 */
export type contactmessage = $Result.DefaultSelection<Prisma.$contactmessagePayload>
/**
 * Model decisionlog
 * 
 */
export type decisionlog = $Result.DefaultSelection<Prisma.$decisionlogPayload>
/**
 * Model directmediaitem
 * 
 */
export type directmediaitem = $Result.DefaultSelection<Prisma.$directmediaitemPayload>
/**
 * Model donatepagecontent
 * 
 */
export type donatepagecontent = $Result.DefaultSelection<Prisma.$donatepagecontentPayload>
/**
 * Model donationrecord
 * 
 */
export type donationrecord = $Result.DefaultSelection<Prisma.$donationrecordPayload>
/**
 * Model donordetail
 * 
 */
export type donordetail = $Result.DefaultSelection<Prisma.$donordetailPayload>
/**
 * Model eventitem
 * 
 */
export type eventitem = $Result.DefaultSelection<Prisma.$eventitemPayload>
/**
 * Model expenserecord
 * 
 */
export type expenserecord = $Result.DefaultSelection<Prisma.$expenserecordPayload>
/**
 * Model fellowshiprosteritem
 * 
 */
export type fellowshiprosteritem = $Result.DefaultSelection<Prisma.$fellowshiprosteritemPayload>
/**
 * Model friendship
 * 
 */
export type friendship = $Result.DefaultSelection<Prisma.$friendshipPayload>
/**
 * Model frontendactivitylog
 * 
 */
export type frontendactivitylog = $Result.DefaultSelection<Prisma.$frontendactivitylogPayload>
/**
 * Model generatedscheduleitem
 * 
 */
export type generatedscheduleitem = $Result.DefaultSelection<Prisma.$generatedscheduleitemPayload>
/**
 * Model group
 * 
 */
export type group = $Result.DefaultSelection<Prisma.$groupPayload>
/**
 * Model groupmember
 * 
 */
export type groupmember = $Result.DefaultSelection<Prisma.$groupmemberPayload>
/**
 * Model groupmessage
 * 
 */
export type groupmessage = $Result.DefaultSelection<Prisma.$groupmessagePayload>
/**
 * Model historychapter
 * 
 */
export type historychapter = $Result.DefaultSelection<Prisma.$historychapterPayload>
/**
 * Model historymilestone
 * 
 */
export type historymilestone = $Result.DefaultSelection<Prisma.$historymilestonePayload>
/**
 * Model homeslide
 * 
 */
export type homeslide = $Result.DefaultSelection<Prisma.$homeslidePayload>
/**
 * Model keyperson
 * 
 */
export type keyperson = $Result.DefaultSelection<Prisma.$keypersonPayload>
/**
 * Model meetingdecisionpoint
 * 
 */
export type meetingdecisionpoint = $Result.DefaultSelection<Prisma.$meetingdecisionpointPayload>
/**
 * Model meetinglog
 * 
 */
export type meetinglog = $Result.DefaultSelection<Prisma.$meetinglogPayload>
/**
 * Model ministry
 * 
 */
export type ministry = $Result.DefaultSelection<Prisma.$ministryPayload>
/**
 * Model ministryjoinrequest
 * 
 */
export type ministryjoinrequest = $Result.DefaultSelection<Prisma.$ministryjoinrequestPayload>
/**
 * Model monthlythemeimage
 * 
 */
export type monthlythemeimage = $Result.DefaultSelection<Prisma.$monthlythemeimagePayload>
/**
 * Model newsitem
 * 
 */
export type newsitem = $Result.DefaultSelection<Prisma.$newsitemPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model prayer
 * 
 */
export type prayer = $Result.DefaultSelection<Prisma.$prayerPayload>
/**
 * Model prayerrequest
 * 
 */
export type prayerrequest = $Result.DefaultSelection<Prisma.$prayerrequestPayload>
/**
 * Model responsibility
 * 
 */
export type responsibility = $Result.DefaultSelection<Prisma.$responsibilityPayload>
/**
 * Model sermon
 * 
 */
export type sermon = $Result.DefaultSelection<Prisma.$sermonPayload>
/**
 * Model testimonial
 * 
 */
export type testimonial = $Result.DefaultSelection<Prisma.$testimonialPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const advertisement_adType: {
  image_banner: 'image_banner',
  video_banner: 'video_banner'
};

export type advertisement_adType = (typeof advertisement_adType)[keyof typeof advertisement_adType]


export const blogpost_category: {
  Church_Life: 'Church_Life',
  Biblical_Study: 'Biblical_Study',
  Devotionals: 'Devotionals',
  Community_News: 'Community_News',
  Testimonies: 'Testimonies'
};

export type blogpost_category = (typeof blogpost_category)[keyof typeof blogpost_category]


export const collectionrecord_purpose: {
  Tithe: 'Tithe',
  General_Offering: 'General_Offering',
  Saturday_Fellowship_Offering: 'Saturday_Fellowship_Offering',
  Wednesday_Fellowship_Offering: 'Wednesday_Fellowship_Offering',
  Friday_Program_Offering: 'Friday_Program_Offering',
  Building_Fund: 'Building_Fund',
  Mission_Support: 'Mission_Support',
  Youth_Ministry_Support: 'Youth_Ministry_Support',
  Children_Ministry_Support: 'Children_Ministry_Support',
  Women_Ministry_Support: 'Women_Ministry_Support',
  Men_Ministry_Support: 'Men_Ministry_Support',
  Thanksgiving_Offering: 'Thanksgiving_Offering',
  Special_Event_Collection: 'Special_Event_Collection',
  Other_Collections: 'Other_Collections'
};

export type collectionrecord_purpose = (typeof collectionrecord_purpose)[keyof typeof collectionrecord_purpose]


export const contactmessage_status: {
  pending: 'pending',
  replied: 'replied'
};

export type contactmessage_status = (typeof contactmessage_status)[keyof typeof contactmessage_status]


export const decisionlog_status: {
  Proposed: 'Proposed',
  Approved: 'Approved',
  Implemented: 'Implemented',
  Rejected: 'Rejected',
  Follow_up_Required: 'Follow_up_Required',
  Postponed: 'Postponed',
  Cancelled: 'Cancelled'
};

export type decisionlog_status = (typeof decisionlog_status)[keyof typeof decisionlog_status]


export const directmediaitem_mediaType: {
  image: 'image',
  video: 'video'
};

export type directmediaitem_mediaType = (typeof directmediaitem_mediaType)[keyof typeof directmediaitem_mediaType]


export const donationrecord_purpose: {
  General_Fund: 'General_Fund',
  Tithe: 'Tithe',
  Worship_Ministry: 'Worship_Ministry',
  Sunday_School: 'Sunday_School',
  Outreach_Missions: 'Outreach_Missions',
  Prayer_Ministry: 'Prayer_Ministry',
  Building_Fund_Maintenance: 'Building_Fund_Maintenance',
  Leadership_Support_Pastor: 'Leadership_Support_Pastor',
  Leadership_Support_Elders_Ministry_Leaders: 'Leadership_Support_Elders_Ministry_Leaders',
  Benevolence_Fund: 'Benevolence_Fund'
};

export type donationrecord_purpose = (typeof donationrecord_purpose)[keyof typeof donationrecord_purpose]


export const donationrecord_paymentMethod: {
  Cash: 'Cash',
  Cheque: 'Cheque',
  Bank_Transfer: 'Bank_Transfer',
  eSewa: 'eSewa',
  Other: 'Other'
};

export type donationrecord_paymentMethod = (typeof donationrecord_paymentMethod)[keyof typeof donationrecord_paymentMethod]


export const eventitem_category: {
  Community_Outreach: 'Community_Outreach',
  Conference: 'Conference',
  Workshop: 'Workshop',
  Holiday_Service: 'Holiday_Service',
  Youth_Event: 'Youth_Event',
  Worship_Night: 'Worship_Night',
  Fellowship: 'Fellowship',
  Special_Meeting: 'Special_Meeting'
};

export type eventitem_category = (typeof eventitem_category)[keyof typeof eventitem_category]


export const expenserecord_category: {
  Ministry_Supplies: 'Ministry_Supplies',
  Utilities: 'Utilities',
  Outreach_Events: 'Outreach_Events',
  Benevolence: 'Benevolence',
  Salaries_Stipends: 'Salaries_Stipends',
  Building_Maintenance: 'Building_Maintenance',
  Office_Supplies: 'Office_Supplies',
  Travel: 'Travel',
  Bank_Charges: 'Bank_Charges',
  IT_Subscriptions: 'IT_Subscriptions',
  Other: 'Other'
};

export type expenserecord_category = (typeof expenserecord_category)[keyof typeof expenserecord_category]


export const expenserecord_paymentMethod: {
  Cash: 'Cash',
  Cheque: 'Cheque',
  Bank_Transfer: 'Bank_Transfer',
  eSewa: 'eSewa',
  Other: 'Other'
};

export type expenserecord_paymentMethod = (typeof expenserecord_paymentMethod)[keyof typeof expenserecord_paymentMethod]


export const expenserecord_status: {
  paid: 'paid',
  pending: 'pending',
  overdue: 'overdue',
  cancelled: 'cancelled'
};

export type expenserecord_status = (typeof expenserecord_status)[keyof typeof expenserecord_status]


export const fellowshiprosteritem_rosterType: {
  Saturday_Main_Fellowship: 'Saturday_Main_Fellowship',
  Saturday_Children_Fellowship: 'Saturday_Children_Fellowship',
  Saturday_Youth_Fellowship: 'Saturday_Youth_Fellowship',
  Wednesday_Home_Fellowship: 'Wednesday_Home_Fellowship',
  Friday_Evening_Program: 'Friday_Evening_Program',
  Special_Meeting: 'Special_Meeting',
  Outreach_Program: 'Outreach_Program',
  Other_Regular_Program: 'Other_Regular_Program',
  Prayer_Team_Visit: 'Prayer_Team_Visit',
  Night_Prayer: 'Night_Prayer',
  Saturday_Prayer: 'Saturday_Prayer'
};

export type fellowshiprosteritem_rosterType = (typeof fellowshiprosteritem_rosterType)[keyof typeof fellowshiprosteritem_rosterType]


export const friendship_status: {
  pending: 'pending',
  accepted: 'accepted',
  blocked: 'blocked',
  declined: 'declined'
};

export type friendship_status = (typeof friendship_status)[keyof typeof friendship_status]


export const generatedscheduleitem_rosterType: {
  Saturday_Main_Fellowship: 'Saturday_Main_Fellowship',
  Saturday_Children_Fellowship: 'Saturday_Children_Fellowship',
  Saturday_Youth_Fellowship: 'Saturday_Youth_Fellowship',
  Wednesday_Home_Fellowship: 'Wednesday_Home_Fellowship',
  Friday_Evening_Program: 'Friday_Evening_Program',
  Special_Meeting: 'Special_Meeting',
  Outreach_Program: 'Outreach_Program',
  Other_Regular_Program: 'Other_Regular_Program',
  Prayer_Team_Visit: 'Prayer_Team_Visit',
  Night_Prayer: 'Night_Prayer',
  Saturday_Prayer: 'Saturday_Prayer'
};

export type generatedscheduleitem_rosterType = (typeof generatedscheduleitem_rosterType)[keyof typeof generatedscheduleitem_rosterType]


export const group_editSettings: {
  admins_only: 'admins_only',
  all_members: 'all_members'
};

export type group_editSettings = (typeof group_editSettings)[keyof typeof group_editSettings]


export const group_sendMessage: {
  admins_only: 'admins_only',
  all_members: 'all_members'
};

export type group_sendMessage = (typeof group_sendMessage)[keyof typeof group_sendMessage]


export const group_addMembers: {
  admins_only: 'admins_only',
  all_members: 'all_members'
};

export type group_addMembers = (typeof group_addMembers)[keyof typeof group_addMembers]


export const group_approveMembers: {
  admins_only: 'admins_only',
  all_members: 'all_members'
};

export type group_approveMembers = (typeof group_approveMembers)[keyof typeof group_approveMembers]


export const groupmember_role: {
  admin: 'admin',
  member: 'member'
};

export type groupmember_role = (typeof groupmember_role)[keyof typeof groupmember_role]


export const groupmessage_mediaType: {
  image: 'image',
  video: 'video',
  file: 'file',
  location: 'location'
};

export type groupmessage_mediaType = (typeof groupmessage_mediaType)[keyof typeof groupmessage_mediaType]


export const historychapter_status: {
  draft: 'draft',
  published: 'published'
};

export type historychapter_status = (typeof historychapter_status)[keyof typeof historychapter_status]


export const meetingdecisionpoint_status: {
  Proposed: 'Proposed',
  Approved: 'Approved',
  Implemented: 'Implemented',
  Rejected: 'Rejected',
  Follow_up_Required: 'Follow_up_Required',
  Postponed: 'Postponed',
  Cancelled: 'Cancelled'
};

export type meetingdecisionpoint_status = (typeof meetingdecisionpoint_status)[keyof typeof meetingdecisionpoint_status]


export const meetinglog_meetingType: {
  General_Leaders_Meeting: 'General_Leaders_Meeting',
  Elders_Meeting: 'Elders_Meeting',
  Deacons_Meeting: 'Deacons_Meeting',
  General_Choir_Meeting: 'General_Choir_Meeting',
  Worship_Team_Practice: 'Worship_Team_Practice',
  Programme_Arrange_Meeting: 'Programme_Arrange_Meeting',
  Event_Planning_Meeting: 'Event_Planning_Meeting',
  Helping_Ministry_Meeting: 'Helping_Ministry_Meeting',
  Benevolence_Committee: 'Benevolence_Committee',
  Outreach_Planning_Meeting: 'Outreach_Planning_Meeting',
  Missions_Update_Meeting: 'Missions_Update_Meeting',
  Sunday_School_Teachers_Meeting: 'Sunday_School_Teachers_Meeting',
  Youth_Leaders_Meeting: 'Youth_Leaders_Meeting',
  Men_s_Fellowship_Planning: 'Men_s_Fellowship_Planning',
  Women_s_Fellowship_Planning: 'Women_s_Fellowship_Planning',
  Prayer_Meeting: 'Prayer_Meeting',
  Bible_Study_Group: 'Bible_Study_Group',
  Financial_Committee_Meeting: 'Financial_Committee_Meeting',
  Administrative_Meeting: 'Administrative_Meeting',
  Special_General_Meeting: 'Special_General_Meeting',
  Other_Specific_Meeting: 'Other_Specific_Meeting'
};

export type meetinglog_meetingType = (typeof meetinglog_meetingType)[keyof typeof meetinglog_meetingType]


export const meetinglog_status: {
  Pending_Discussion: 'Pending_Discussion',
  Agenda_Set: 'Agenda_Set',
  In_Progress: 'In_Progress',
  Completed: 'Completed',
  Decisions_Approved: 'Decisions_Approved',
  Follow_up_Required: 'Follow_up_Required',
  Postponed: 'Postponed',
  Cancelled: 'Cancelled'
};

export type meetinglog_status = (typeof meetinglog_status)[keyof typeof meetinglog_status]


export const ministry_category: {
  Youth_Young_Adults: 'Youth_Young_Adults',
  Children_Family: 'Children_Family',
  Men_s_Ministry: 'Men_s_Ministry',
  Women_s_Ministry: 'Women_s_Ministry',
  Worship_Team: 'Worship_Team',
  Outreach_Missions: 'Outreach_Missions',
  Pastoral_Care: 'Pastoral_Care'
};

export type ministry_category = (typeof ministry_category)[keyof typeof ministry_category]


export const ministryjoinrequest_status: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type ministryjoinrequest_status = (typeof ministryjoinrequest_status)[keyof typeof ministryjoinrequest_status]


export const newsitem_category: {
  Church_Announcements: 'Church_Announcements',
  Community_Updates: 'Community_Updates',
  Special_Reports: 'Special_Reports',
  Mission_News: 'Mission_News',
  Youth_Activities: 'Youth_Activities',
  Pastoral_Messages: 'Pastoral_Messages'
};

export type newsitem_category = (typeof newsitem_category)[keyof typeof newsitem_category]


export const notification_type: {
  comment: 'comment',
  ministry_request_update: 'ministry_request_update',
  admin_action: 'admin_action',
  event_reminder: 'event_reminder',
  generic: 'generic',
  new_content_published: 'new_content_published',
  schedule_update: 'schedule_update',
  feature_update: 'feature_update',
  prayer_request_submitted_admin: 'prayer_request_submitted_admin',
  prayer_request_status_user: 'prayer_request_status_user',
  prayer_request_prayed_for: 'prayer_request_prayed_for',
  friend_request_received: 'friend_request_received',
  friend_request_accepted: 'friend_request_accepted',
  new_prayer_request_friend: 'new_prayer_request_friend',
  new_testimonial_friend: 'new_testimonial_friend',
  ad_expiring_soon: 'ad_expiring_soon'
};

export type notification_type = (typeof notification_type)[keyof typeof notification_type]


export const prayerrequest_visibility: {
  public: 'public',
  friends_only: 'friends_only',
  private: 'private',
  anonymous: 'anonymous'
};

export type prayerrequest_visibility = (typeof prayerrequest_visibility)[keyof typeof prayerrequest_visibility]


export const prayerrequest_category: {
  Healing: 'Healing',
  Guidance: 'Guidance',
  Family: 'Family',
  Thanksgiving: 'Thanksgiving',
  Community: 'Community',
  Personal: 'Personal',
  Other: 'Other'
};

export type prayerrequest_category = (typeof prayerrequest_category)[keyof typeof prayerrequest_category]


export const prayerrequest_status: {
  active: 'active',
  prayed_for: 'prayed_for',
  answered: 'answered',
  archived: 'archived'
};

export type prayerrequest_status = (typeof prayerrequest_status)[keyof typeof prayerrequest_status]


export const sermon_category: {
  Sermon_Series: 'Sermon_Series',
  Guest_Speaker: 'Guest_Speaker',
  Topical_Sermon: 'Topical_Sermon',
  Special_Event_Sermon: 'Special_Event_Sermon',
  Bible_Study: 'Bible_Study'
};

export type sermon_category = (typeof sermon_category)[keyof typeof sermon_category]


export const testimonial_visibility: {
  public: 'public',
  friends_only: 'friends_only'
};

export type testimonial_visibility = (typeof testimonial_visibility)[keyof typeof testimonial_visibility]


export const user_role: {
  user: 'user',
  admin: 'admin',
  owner: 'owner'
};

export type user_role = (typeof user_role)[keyof typeof user_role]


export const user_relationshipStatus: {
  Single: 'Single',
  In_a_relationship: 'In_a_relationship',
  Engaged: 'Engaged',
  Married: 'Married',
  Its_complicated: 'Its_complicated',
  Separated: 'Separated',
  Divorced: 'Divorced',
  Widowed: 'Widowed'
};

export type user_relationshipStatus = (typeof user_relationshipStatus)[keyof typeof user_relationshipStatus]


export const user_friendsListPrivacy: {
  public: 'public',
  friends: 'friends',
  private: 'private'
};

export type user_friendsListPrivacy = (typeof user_friendsListPrivacy)[keyof typeof user_friendsListPrivacy]


export const user_friendRequestPrivacy: {
  everyone: 'everyone',
  friends_of_friends: 'friends_of_friends'
};

export type user_friendRequestPrivacy = (typeof user_friendRequestPrivacy)[keyof typeof user_friendRequestPrivacy]


export const user_groupInvitePrivacy: {
  everyone: 'everyone',
  friends: 'friends'
};

export type user_groupInvitePrivacy = (typeof user_groupInvitePrivacy)[keyof typeof user_groupInvitePrivacy]

}

export type advertisement_adType = $Enums.advertisement_adType

export const advertisement_adType: typeof $Enums.advertisement_adType

export type blogpost_category = $Enums.blogpost_category

export const blogpost_category: typeof $Enums.blogpost_category

export type collectionrecord_purpose = $Enums.collectionrecord_purpose

export const collectionrecord_purpose: typeof $Enums.collectionrecord_purpose

export type contactmessage_status = $Enums.contactmessage_status

export const contactmessage_status: typeof $Enums.contactmessage_status

export type decisionlog_status = $Enums.decisionlog_status

export const decisionlog_status: typeof $Enums.decisionlog_status

export type directmediaitem_mediaType = $Enums.directmediaitem_mediaType

export const directmediaitem_mediaType: typeof $Enums.directmediaitem_mediaType

export type donationrecord_purpose = $Enums.donationrecord_purpose

export const donationrecord_purpose: typeof $Enums.donationrecord_purpose

export type donationrecord_paymentMethod = $Enums.donationrecord_paymentMethod

export const donationrecord_paymentMethod: typeof $Enums.donationrecord_paymentMethod

export type eventitem_category = $Enums.eventitem_category

export const eventitem_category: typeof $Enums.eventitem_category

export type expenserecord_category = $Enums.expenserecord_category

export const expenserecord_category: typeof $Enums.expenserecord_category

export type expenserecord_paymentMethod = $Enums.expenserecord_paymentMethod

export const expenserecord_paymentMethod: typeof $Enums.expenserecord_paymentMethod

export type expenserecord_status = $Enums.expenserecord_status

export const expenserecord_status: typeof $Enums.expenserecord_status

export type fellowshiprosteritem_rosterType = $Enums.fellowshiprosteritem_rosterType

export const fellowshiprosteritem_rosterType: typeof $Enums.fellowshiprosteritem_rosterType

export type friendship_status = $Enums.friendship_status

export const friendship_status: typeof $Enums.friendship_status

export type generatedscheduleitem_rosterType = $Enums.generatedscheduleitem_rosterType

export const generatedscheduleitem_rosterType: typeof $Enums.generatedscheduleitem_rosterType

export type group_editSettings = $Enums.group_editSettings

export const group_editSettings: typeof $Enums.group_editSettings

export type group_sendMessage = $Enums.group_sendMessage

export const group_sendMessage: typeof $Enums.group_sendMessage

export type group_addMembers = $Enums.group_addMembers

export const group_addMembers: typeof $Enums.group_addMembers

export type group_approveMembers = $Enums.group_approveMembers

export const group_approveMembers: typeof $Enums.group_approveMembers

export type groupmember_role = $Enums.groupmember_role

export const groupmember_role: typeof $Enums.groupmember_role

export type groupmessage_mediaType = $Enums.groupmessage_mediaType

export const groupmessage_mediaType: typeof $Enums.groupmessage_mediaType

export type historychapter_status = $Enums.historychapter_status

export const historychapter_status: typeof $Enums.historychapter_status

export type meetingdecisionpoint_status = $Enums.meetingdecisionpoint_status

export const meetingdecisionpoint_status: typeof $Enums.meetingdecisionpoint_status

export type meetinglog_meetingType = $Enums.meetinglog_meetingType

export const meetinglog_meetingType: typeof $Enums.meetinglog_meetingType

export type meetinglog_status = $Enums.meetinglog_status

export const meetinglog_status: typeof $Enums.meetinglog_status

export type ministry_category = $Enums.ministry_category

export const ministry_category: typeof $Enums.ministry_category

export type ministryjoinrequest_status = $Enums.ministryjoinrequest_status

export const ministryjoinrequest_status: typeof $Enums.ministryjoinrequest_status

export type newsitem_category = $Enums.newsitem_category

export const newsitem_category: typeof $Enums.newsitem_category

export type notification_type = $Enums.notification_type

export const notification_type: typeof $Enums.notification_type

export type prayerrequest_visibility = $Enums.prayerrequest_visibility

export const prayerrequest_visibility: typeof $Enums.prayerrequest_visibility

export type prayerrequest_category = $Enums.prayerrequest_category

export const prayerrequest_category: typeof $Enums.prayerrequest_category

export type prayerrequest_status = $Enums.prayerrequest_status

export const prayerrequest_status: typeof $Enums.prayerrequest_status

export type sermon_category = $Enums.sermon_category

export const sermon_category: typeof $Enums.sermon_category

export type testimonial_visibility = $Enums.testimonial_visibility

export const testimonial_visibility: typeof $Enums.testimonial_visibility

export type user_role = $Enums.user_role

export const user_role: typeof $Enums.user_role

export type user_relationshipStatus = $Enums.user_relationshipStatus

export const user_relationshipStatus: typeof $Enums.user_relationshipStatus

export type user_friendsListPrivacy = $Enums.user_friendsListPrivacy

export const user_friendsListPrivacy: typeof $Enums.user_friendsListPrivacy

export type user_friendRequestPrivacy = $Enums.user_friendRequestPrivacy

export const user_friendRequestPrivacy: typeof $Enums.user_friendRequestPrivacy

export type user_groupInvitePrivacy = $Enums.user_groupInvitePrivacy

export const user_groupInvitePrivacy: typeof $Enums.user_groupInvitePrivacy

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Aboutsections
 * const aboutsections = await prisma.aboutsection.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Aboutsections
   * const aboutsections = await prisma.aboutsection.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.aboutsection`: Exposes CRUD operations for the **aboutsection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aboutsections
    * const aboutsections = await prisma.aboutsection.findMany()
    * ```
    */
  get aboutsection(): Prisma.aboutsectionDelegate<ExtArgs>;

  /**
   * `prisma.adminactionlog`: Exposes CRUD operations for the **adminactionlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adminactionlogs
    * const adminactionlogs = await prisma.adminactionlog.findMany()
    * ```
    */
  get adminactionlog(): Prisma.adminactionlogDelegate<ExtArgs>;

  /**
   * `prisma.advertisement`: Exposes CRUD operations for the **advertisement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advertisements
    * const advertisements = await prisma.advertisement.findMany()
    * ```
    */
  get advertisement(): Prisma.advertisementDelegate<ExtArgs>;

  /**
   * `prisma.blogpost`: Exposes CRUD operations for the **blogpost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogposts
    * const blogposts = await prisma.blogpost.findMany()
    * ```
    */
  get blogpost(): Prisma.blogpostDelegate<ExtArgs>;

  /**
   * `prisma.branchchurch`: Exposes CRUD operations for the **branchchurch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branchchurches
    * const branchchurches = await prisma.branchchurch.findMany()
    * ```
    */
  get branchchurch(): Prisma.branchchurchDelegate<ExtArgs>;

  /**
   * `prisma.churchmember`: Exposes CRUD operations for the **churchmember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Churchmembers
    * const churchmembers = await prisma.churchmember.findMany()
    * ```
    */
  get churchmember(): Prisma.churchmemberDelegate<ExtArgs>;

  /**
   * `prisma.collectionrecord`: Exposes CRUD operations for the **collectionrecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collectionrecords
    * const collectionrecords = await prisma.collectionrecord.findMany()
    * ```
    */
  get collectionrecord(): Prisma.collectionrecordDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.commentDelegate<ExtArgs>;

  /**
   * `prisma.contactmessage`: Exposes CRUD operations for the **contactmessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactmessages
    * const contactmessages = await prisma.contactmessage.findMany()
    * ```
    */
  get contactmessage(): Prisma.contactmessageDelegate<ExtArgs>;

  /**
   * `prisma.decisionlog`: Exposes CRUD operations for the **decisionlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Decisionlogs
    * const decisionlogs = await prisma.decisionlog.findMany()
    * ```
    */
  get decisionlog(): Prisma.decisionlogDelegate<ExtArgs>;

  /**
   * `prisma.directmediaitem`: Exposes CRUD operations for the **directmediaitem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Directmediaitems
    * const directmediaitems = await prisma.directmediaitem.findMany()
    * ```
    */
  get directmediaitem(): Prisma.directmediaitemDelegate<ExtArgs>;

  /**
   * `prisma.donatepagecontent`: Exposes CRUD operations for the **donatepagecontent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donatepagecontents
    * const donatepagecontents = await prisma.donatepagecontent.findMany()
    * ```
    */
  get donatepagecontent(): Prisma.donatepagecontentDelegate<ExtArgs>;

  /**
   * `prisma.donationrecord`: Exposes CRUD operations for the **donationrecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donationrecords
    * const donationrecords = await prisma.donationrecord.findMany()
    * ```
    */
  get donationrecord(): Prisma.donationrecordDelegate<ExtArgs>;

  /**
   * `prisma.donordetail`: Exposes CRUD operations for the **donordetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donordetails
    * const donordetails = await prisma.donordetail.findMany()
    * ```
    */
  get donordetail(): Prisma.donordetailDelegate<ExtArgs>;

  /**
   * `prisma.eventitem`: Exposes CRUD operations for the **eventitem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventitems
    * const eventitems = await prisma.eventitem.findMany()
    * ```
    */
  get eventitem(): Prisma.eventitemDelegate<ExtArgs>;

  /**
   * `prisma.expenserecord`: Exposes CRUD operations for the **expenserecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenserecords
    * const expenserecords = await prisma.expenserecord.findMany()
    * ```
    */
  get expenserecord(): Prisma.expenserecordDelegate<ExtArgs>;

  /**
   * `prisma.fellowshiprosteritem`: Exposes CRUD operations for the **fellowshiprosteritem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fellowshiprosteritems
    * const fellowshiprosteritems = await prisma.fellowshiprosteritem.findMany()
    * ```
    */
  get fellowshiprosteritem(): Prisma.fellowshiprosteritemDelegate<ExtArgs>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.friendshipDelegate<ExtArgs>;

  /**
   * `prisma.frontendactivitylog`: Exposes CRUD operations for the **frontendactivitylog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Frontendactivitylogs
    * const frontendactivitylogs = await prisma.frontendactivitylog.findMany()
    * ```
    */
  get frontendactivitylog(): Prisma.frontendactivitylogDelegate<ExtArgs>;

  /**
   * `prisma.generatedscheduleitem`: Exposes CRUD operations for the **generatedscheduleitem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Generatedscheduleitems
    * const generatedscheduleitems = await prisma.generatedscheduleitem.findMany()
    * ```
    */
  get generatedscheduleitem(): Prisma.generatedscheduleitemDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.groupDelegate<ExtArgs>;

  /**
   * `prisma.groupmember`: Exposes CRUD operations for the **groupmember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groupmembers
    * const groupmembers = await prisma.groupmember.findMany()
    * ```
    */
  get groupmember(): Prisma.groupmemberDelegate<ExtArgs>;

  /**
   * `prisma.groupmessage`: Exposes CRUD operations for the **groupmessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groupmessages
    * const groupmessages = await prisma.groupmessage.findMany()
    * ```
    */
  get groupmessage(): Prisma.groupmessageDelegate<ExtArgs>;

  /**
   * `prisma.historychapter`: Exposes CRUD operations for the **historychapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historychapters
    * const historychapters = await prisma.historychapter.findMany()
    * ```
    */
  get historychapter(): Prisma.historychapterDelegate<ExtArgs>;

  /**
   * `prisma.historymilestone`: Exposes CRUD operations for the **historymilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historymilestones
    * const historymilestones = await prisma.historymilestone.findMany()
    * ```
    */
  get historymilestone(): Prisma.historymilestoneDelegate<ExtArgs>;

  /**
   * `prisma.homeslide`: Exposes CRUD operations for the **homeslide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Homeslides
    * const homeslides = await prisma.homeslide.findMany()
    * ```
    */
  get homeslide(): Prisma.homeslideDelegate<ExtArgs>;

  /**
   * `prisma.keyperson`: Exposes CRUD operations for the **keyperson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keypeople
    * const keypeople = await prisma.keyperson.findMany()
    * ```
    */
  get keyperson(): Prisma.keypersonDelegate<ExtArgs>;

  /**
   * `prisma.meetingdecisionpoint`: Exposes CRUD operations for the **meetingdecisionpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetingdecisionpoints
    * const meetingdecisionpoints = await prisma.meetingdecisionpoint.findMany()
    * ```
    */
  get meetingdecisionpoint(): Prisma.meetingdecisionpointDelegate<ExtArgs>;

  /**
   * `prisma.meetinglog`: Exposes CRUD operations for the **meetinglog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetinglogs
    * const meetinglogs = await prisma.meetinglog.findMany()
    * ```
    */
  get meetinglog(): Prisma.meetinglogDelegate<ExtArgs>;

  /**
   * `prisma.ministry`: Exposes CRUD operations for the **ministry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ministries
    * const ministries = await prisma.ministry.findMany()
    * ```
    */
  get ministry(): Prisma.ministryDelegate<ExtArgs>;

  /**
   * `prisma.ministryjoinrequest`: Exposes CRUD operations for the **ministryjoinrequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ministryjoinrequests
    * const ministryjoinrequests = await prisma.ministryjoinrequest.findMany()
    * ```
    */
  get ministryjoinrequest(): Prisma.ministryjoinrequestDelegate<ExtArgs>;

  /**
   * `prisma.monthlythemeimage`: Exposes CRUD operations for the **monthlythemeimage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monthlythemeimages
    * const monthlythemeimages = await prisma.monthlythemeimage.findMany()
    * ```
    */
  get monthlythemeimage(): Prisma.monthlythemeimageDelegate<ExtArgs>;

  /**
   * `prisma.newsitem`: Exposes CRUD operations for the **newsitem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Newsitems
    * const newsitems = await prisma.newsitem.findMany()
    * ```
    */
  get newsitem(): Prisma.newsitemDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs>;

  /**
   * `prisma.prayer`: Exposes CRUD operations for the **prayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prayers
    * const prayers = await prisma.prayer.findMany()
    * ```
    */
  get prayer(): Prisma.prayerDelegate<ExtArgs>;

  /**
   * `prisma.prayerrequest`: Exposes CRUD operations for the **prayerrequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prayerrequests
    * const prayerrequests = await prisma.prayerrequest.findMany()
    * ```
    */
  get prayerrequest(): Prisma.prayerrequestDelegate<ExtArgs>;

  /**
   * `prisma.responsibility`: Exposes CRUD operations for the **responsibility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Responsibilities
    * const responsibilities = await prisma.responsibility.findMany()
    * ```
    */
  get responsibility(): Prisma.responsibilityDelegate<ExtArgs>;

  /**
   * `prisma.sermon`: Exposes CRUD operations for the **sermon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sermons
    * const sermons = await prisma.sermon.findMany()
    * ```
    */
  get sermon(): Prisma.sermonDelegate<ExtArgs>;

  /**
   * `prisma.testimonial`: Exposes CRUD operations for the **testimonial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testimonials
    * const testimonials = await prisma.testimonial.findMany()
    * ```
    */
  get testimonial(): Prisma.testimonialDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    aboutsection: 'aboutsection',
    adminactionlog: 'adminactionlog',
    advertisement: 'advertisement',
    blogpost: 'blogpost',
    branchchurch: 'branchchurch',
    churchmember: 'churchmember',
    collectionrecord: 'collectionrecord',
    comment: 'comment',
    contactmessage: 'contactmessage',
    decisionlog: 'decisionlog',
    directmediaitem: 'directmediaitem',
    donatepagecontent: 'donatepagecontent',
    donationrecord: 'donationrecord',
    donordetail: 'donordetail',
    eventitem: 'eventitem',
    expenserecord: 'expenserecord',
    fellowshiprosteritem: 'fellowshiprosteritem',
    friendship: 'friendship',
    frontendactivitylog: 'frontendactivitylog',
    generatedscheduleitem: 'generatedscheduleitem',
    group: 'group',
    groupmember: 'groupmember',
    groupmessage: 'groupmessage',
    historychapter: 'historychapter',
    historymilestone: 'historymilestone',
    homeslide: 'homeslide',
    keyperson: 'keyperson',
    meetingdecisionpoint: 'meetingdecisionpoint',
    meetinglog: 'meetinglog',
    ministry: 'ministry',
    ministryjoinrequest: 'ministryjoinrequest',
    monthlythemeimage: 'monthlythemeimage',
    newsitem: 'newsitem',
    notification: 'notification',
    prayer: 'prayer',
    prayerrequest: 'prayerrequest',
    responsibility: 'responsibility',
    sermon: 'sermon',
    testimonial: 'testimonial',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "aboutsection" | "adminactionlog" | "advertisement" | "blogpost" | "branchchurch" | "churchmember" | "collectionrecord" | "comment" | "contactmessage" | "decisionlog" | "directmediaitem" | "donatepagecontent" | "donationrecord" | "donordetail" | "eventitem" | "expenserecord" | "fellowshiprosteritem" | "friendship" | "frontendactivitylog" | "generatedscheduleitem" | "group" | "groupmember" | "groupmessage" | "historychapter" | "historymilestone" | "homeslide" | "keyperson" | "meetingdecisionpoint" | "meetinglog" | "ministry" | "ministryjoinrequest" | "monthlythemeimage" | "newsitem" | "notification" | "prayer" | "prayerrequest" | "responsibility" | "sermon" | "testimonial" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      aboutsection: {
        payload: Prisma.$aboutsectionPayload<ExtArgs>
        fields: Prisma.aboutsectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aboutsectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aboutsectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload>
          }
          findFirst: {
            args: Prisma.aboutsectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aboutsectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload>
          }
          findMany: {
            args: Prisma.aboutsectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload>[]
          }
          create: {
            args: Prisma.aboutsectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload>
          }
          createMany: {
            args: Prisma.aboutsectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.aboutsectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload>
          }
          update: {
            args: Prisma.aboutsectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload>
          }
          deleteMany: {
            args: Prisma.aboutsectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aboutsectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.aboutsectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aboutsectionPayload>
          }
          aggregate: {
            args: Prisma.AboutsectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAboutsection>
          }
          groupBy: {
            args: Prisma.aboutsectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AboutsectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.aboutsectionCountArgs<ExtArgs>
            result: $Utils.Optional<AboutsectionCountAggregateOutputType> | number
          }
        }
      }
      adminactionlog: {
        payload: Prisma.$adminactionlogPayload<ExtArgs>
        fields: Prisma.adminactionlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminactionlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminactionlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload>
          }
          findFirst: {
            args: Prisma.adminactionlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminactionlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload>
          }
          findMany: {
            args: Prisma.adminactionlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload>[]
          }
          create: {
            args: Prisma.adminactionlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload>
          }
          createMany: {
            args: Prisma.adminactionlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.adminactionlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload>
          }
          update: {
            args: Prisma.adminactionlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload>
          }
          deleteMany: {
            args: Prisma.adminactionlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminactionlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminactionlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminactionlogPayload>
          }
          aggregate: {
            args: Prisma.AdminactionlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminactionlog>
          }
          groupBy: {
            args: Prisma.adminactionlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminactionlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminactionlogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminactionlogCountAggregateOutputType> | number
          }
        }
      }
      advertisement: {
        payload: Prisma.$advertisementPayload<ExtArgs>
        fields: Prisma.advertisementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.advertisementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.advertisementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload>
          }
          findFirst: {
            args: Prisma.advertisementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.advertisementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload>
          }
          findMany: {
            args: Prisma.advertisementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload>[]
          }
          create: {
            args: Prisma.advertisementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload>
          }
          createMany: {
            args: Prisma.advertisementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.advertisementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload>
          }
          update: {
            args: Prisma.advertisementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload>
          }
          deleteMany: {
            args: Prisma.advertisementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.advertisementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.advertisementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advertisementPayload>
          }
          aggregate: {
            args: Prisma.AdvertisementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvertisement>
          }
          groupBy: {
            args: Prisma.advertisementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvertisementGroupByOutputType>[]
          }
          count: {
            args: Prisma.advertisementCountArgs<ExtArgs>
            result: $Utils.Optional<AdvertisementCountAggregateOutputType> | number
          }
        }
      }
      blogpost: {
        payload: Prisma.$blogpostPayload<ExtArgs>
        fields: Prisma.blogpostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blogpostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blogpostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload>
          }
          findFirst: {
            args: Prisma.blogpostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blogpostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload>
          }
          findMany: {
            args: Prisma.blogpostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload>[]
          }
          create: {
            args: Prisma.blogpostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload>
          }
          createMany: {
            args: Prisma.blogpostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blogpostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload>
          }
          update: {
            args: Prisma.blogpostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload>
          }
          deleteMany: {
            args: Prisma.blogpostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blogpostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blogpostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogpostPayload>
          }
          aggregate: {
            args: Prisma.BlogpostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogpost>
          }
          groupBy: {
            args: Prisma.blogpostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogpostGroupByOutputType>[]
          }
          count: {
            args: Prisma.blogpostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogpostCountAggregateOutputType> | number
          }
        }
      }
      branchchurch: {
        payload: Prisma.$branchchurchPayload<ExtArgs>
        fields: Prisma.branchchurchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.branchchurchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.branchchurchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload>
          }
          findFirst: {
            args: Prisma.branchchurchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.branchchurchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload>
          }
          findMany: {
            args: Prisma.branchchurchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload>[]
          }
          create: {
            args: Prisma.branchchurchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload>
          }
          createMany: {
            args: Prisma.branchchurchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.branchchurchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload>
          }
          update: {
            args: Prisma.branchchurchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload>
          }
          deleteMany: {
            args: Prisma.branchchurchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.branchchurchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.branchchurchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchchurchPayload>
          }
          aggregate: {
            args: Prisma.BranchchurchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranchchurch>
          }
          groupBy: {
            args: Prisma.branchchurchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchchurchGroupByOutputType>[]
          }
          count: {
            args: Prisma.branchchurchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchchurchCountAggregateOutputType> | number
          }
        }
      }
      churchmember: {
        payload: Prisma.$churchmemberPayload<ExtArgs>
        fields: Prisma.churchmemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.churchmemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.churchmemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload>
          }
          findFirst: {
            args: Prisma.churchmemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.churchmemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload>
          }
          findMany: {
            args: Prisma.churchmemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload>[]
          }
          create: {
            args: Prisma.churchmemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload>
          }
          createMany: {
            args: Prisma.churchmemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.churchmemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload>
          }
          update: {
            args: Prisma.churchmemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload>
          }
          deleteMany: {
            args: Prisma.churchmemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.churchmemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.churchmemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$churchmemberPayload>
          }
          aggregate: {
            args: Prisma.ChurchmemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChurchmember>
          }
          groupBy: {
            args: Prisma.churchmemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChurchmemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.churchmemberCountArgs<ExtArgs>
            result: $Utils.Optional<ChurchmemberCountAggregateOutputType> | number
          }
        }
      }
      collectionrecord: {
        payload: Prisma.$collectionrecordPayload<ExtArgs>
        fields: Prisma.collectionrecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collectionrecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collectionrecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload>
          }
          findFirst: {
            args: Prisma.collectionrecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collectionrecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload>
          }
          findMany: {
            args: Prisma.collectionrecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload>[]
          }
          create: {
            args: Prisma.collectionrecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload>
          }
          createMany: {
            args: Prisma.collectionrecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.collectionrecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload>
          }
          update: {
            args: Prisma.collectionrecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload>
          }
          deleteMany: {
            args: Prisma.collectionrecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collectionrecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.collectionrecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectionrecordPayload>
          }
          aggregate: {
            args: Prisma.CollectionrecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionrecord>
          }
          groupBy: {
            args: Prisma.collectionrecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionrecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.collectionrecordCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionrecordCountAggregateOutputType> | number
          }
        }
      }
      comment: {
        payload: Prisma.$commentPayload<ExtArgs>
        fields: Prisma.commentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          findFirst: {
            args: Prisma.commentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          findMany: {
            args: Prisma.commentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>[]
          }
          create: {
            args: Prisma.commentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          createMany: {
            args: Prisma.commentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.commentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          update: {
            args: Prisma.commentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          deleteMany: {
            args: Prisma.commentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.commentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.commentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      contactmessage: {
        payload: Prisma.$contactmessagePayload<ExtArgs>
        fields: Prisma.contactmessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactmessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactmessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload>
          }
          findFirst: {
            args: Prisma.contactmessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactmessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload>
          }
          findMany: {
            args: Prisma.contactmessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload>[]
          }
          create: {
            args: Prisma.contactmessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload>
          }
          createMany: {
            args: Prisma.contactmessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contactmessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload>
          }
          update: {
            args: Prisma.contactmessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload>
          }
          deleteMany: {
            args: Prisma.contactmessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactmessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contactmessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactmessagePayload>
          }
          aggregate: {
            args: Prisma.ContactmessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactmessage>
          }
          groupBy: {
            args: Prisma.contactmessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactmessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactmessageCountArgs<ExtArgs>
            result: $Utils.Optional<ContactmessageCountAggregateOutputType> | number
          }
        }
      }
      decisionlog: {
        payload: Prisma.$decisionlogPayload<ExtArgs>
        fields: Prisma.decisionlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.decisionlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.decisionlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload>
          }
          findFirst: {
            args: Prisma.decisionlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.decisionlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload>
          }
          findMany: {
            args: Prisma.decisionlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload>[]
          }
          create: {
            args: Prisma.decisionlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload>
          }
          createMany: {
            args: Prisma.decisionlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.decisionlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload>
          }
          update: {
            args: Prisma.decisionlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload>
          }
          deleteMany: {
            args: Prisma.decisionlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.decisionlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.decisionlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$decisionlogPayload>
          }
          aggregate: {
            args: Prisma.DecisionlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecisionlog>
          }
          groupBy: {
            args: Prisma.decisionlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecisionlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.decisionlogCountArgs<ExtArgs>
            result: $Utils.Optional<DecisionlogCountAggregateOutputType> | number
          }
        }
      }
      directmediaitem: {
        payload: Prisma.$directmediaitemPayload<ExtArgs>
        fields: Prisma.directmediaitemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.directmediaitemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.directmediaitemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload>
          }
          findFirst: {
            args: Prisma.directmediaitemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.directmediaitemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload>
          }
          findMany: {
            args: Prisma.directmediaitemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload>[]
          }
          create: {
            args: Prisma.directmediaitemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload>
          }
          createMany: {
            args: Prisma.directmediaitemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.directmediaitemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload>
          }
          update: {
            args: Prisma.directmediaitemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload>
          }
          deleteMany: {
            args: Prisma.directmediaitemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.directmediaitemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.directmediaitemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$directmediaitemPayload>
          }
          aggregate: {
            args: Prisma.DirectmediaitemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirectmediaitem>
          }
          groupBy: {
            args: Prisma.directmediaitemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectmediaitemGroupByOutputType>[]
          }
          count: {
            args: Prisma.directmediaitemCountArgs<ExtArgs>
            result: $Utils.Optional<DirectmediaitemCountAggregateOutputType> | number
          }
        }
      }
      donatepagecontent: {
        payload: Prisma.$donatepagecontentPayload<ExtArgs>
        fields: Prisma.donatepagecontentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.donatepagecontentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.donatepagecontentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload>
          }
          findFirst: {
            args: Prisma.donatepagecontentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.donatepagecontentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload>
          }
          findMany: {
            args: Prisma.donatepagecontentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload>[]
          }
          create: {
            args: Prisma.donatepagecontentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload>
          }
          createMany: {
            args: Prisma.donatepagecontentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.donatepagecontentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload>
          }
          update: {
            args: Prisma.donatepagecontentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload>
          }
          deleteMany: {
            args: Prisma.donatepagecontentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.donatepagecontentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.donatepagecontentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donatepagecontentPayload>
          }
          aggregate: {
            args: Prisma.DonatepagecontentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonatepagecontent>
          }
          groupBy: {
            args: Prisma.donatepagecontentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonatepagecontentGroupByOutputType>[]
          }
          count: {
            args: Prisma.donatepagecontentCountArgs<ExtArgs>
            result: $Utils.Optional<DonatepagecontentCountAggregateOutputType> | number
          }
        }
      }
      donationrecord: {
        payload: Prisma.$donationrecordPayload<ExtArgs>
        fields: Prisma.donationrecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.donationrecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.donationrecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload>
          }
          findFirst: {
            args: Prisma.donationrecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.donationrecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload>
          }
          findMany: {
            args: Prisma.donationrecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload>[]
          }
          create: {
            args: Prisma.donationrecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload>
          }
          createMany: {
            args: Prisma.donationrecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.donationrecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload>
          }
          update: {
            args: Prisma.donationrecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload>
          }
          deleteMany: {
            args: Prisma.donationrecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.donationrecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.donationrecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donationrecordPayload>
          }
          aggregate: {
            args: Prisma.DonationrecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonationrecord>
          }
          groupBy: {
            args: Prisma.donationrecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonationrecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.donationrecordCountArgs<ExtArgs>
            result: $Utils.Optional<DonationrecordCountAggregateOutputType> | number
          }
        }
      }
      donordetail: {
        payload: Prisma.$donordetailPayload<ExtArgs>
        fields: Prisma.donordetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.donordetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.donordetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload>
          }
          findFirst: {
            args: Prisma.donordetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.donordetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload>
          }
          findMany: {
            args: Prisma.donordetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload>[]
          }
          create: {
            args: Prisma.donordetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload>
          }
          createMany: {
            args: Prisma.donordetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.donordetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload>
          }
          update: {
            args: Prisma.donordetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload>
          }
          deleteMany: {
            args: Prisma.donordetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.donordetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.donordetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$donordetailPayload>
          }
          aggregate: {
            args: Prisma.DonordetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonordetail>
          }
          groupBy: {
            args: Prisma.donordetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonordetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.donordetailCountArgs<ExtArgs>
            result: $Utils.Optional<DonordetailCountAggregateOutputType> | number
          }
        }
      }
      eventitem: {
        payload: Prisma.$eventitemPayload<ExtArgs>
        fields: Prisma.eventitemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.eventitemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.eventitemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload>
          }
          findFirst: {
            args: Prisma.eventitemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.eventitemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload>
          }
          findMany: {
            args: Prisma.eventitemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload>[]
          }
          create: {
            args: Prisma.eventitemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload>
          }
          createMany: {
            args: Prisma.eventitemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.eventitemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload>
          }
          update: {
            args: Prisma.eventitemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload>
          }
          deleteMany: {
            args: Prisma.eventitemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.eventitemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.eventitemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$eventitemPayload>
          }
          aggregate: {
            args: Prisma.EventitemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventitem>
          }
          groupBy: {
            args: Prisma.eventitemGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventitemGroupByOutputType>[]
          }
          count: {
            args: Prisma.eventitemCountArgs<ExtArgs>
            result: $Utils.Optional<EventitemCountAggregateOutputType> | number
          }
        }
      }
      expenserecord: {
        payload: Prisma.$expenserecordPayload<ExtArgs>
        fields: Prisma.expenserecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.expenserecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.expenserecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload>
          }
          findFirst: {
            args: Prisma.expenserecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.expenserecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload>
          }
          findMany: {
            args: Prisma.expenserecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload>[]
          }
          create: {
            args: Prisma.expenserecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload>
          }
          createMany: {
            args: Prisma.expenserecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.expenserecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload>
          }
          update: {
            args: Prisma.expenserecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload>
          }
          deleteMany: {
            args: Prisma.expenserecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.expenserecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.expenserecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$expenserecordPayload>
          }
          aggregate: {
            args: Prisma.ExpenserecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenserecord>
          }
          groupBy: {
            args: Prisma.expenserecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenserecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.expenserecordCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenserecordCountAggregateOutputType> | number
          }
        }
      }
      fellowshiprosteritem: {
        payload: Prisma.$fellowshiprosteritemPayload<ExtArgs>
        fields: Prisma.fellowshiprosteritemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fellowshiprosteritemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fellowshiprosteritemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload>
          }
          findFirst: {
            args: Prisma.fellowshiprosteritemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fellowshiprosteritemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload>
          }
          findMany: {
            args: Prisma.fellowshiprosteritemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload>[]
          }
          create: {
            args: Prisma.fellowshiprosteritemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload>
          }
          createMany: {
            args: Prisma.fellowshiprosteritemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fellowshiprosteritemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload>
          }
          update: {
            args: Prisma.fellowshiprosteritemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload>
          }
          deleteMany: {
            args: Prisma.fellowshiprosteritemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fellowshiprosteritemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fellowshiprosteritemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fellowshiprosteritemPayload>
          }
          aggregate: {
            args: Prisma.FellowshiprosteritemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFellowshiprosteritem>
          }
          groupBy: {
            args: Prisma.fellowshiprosteritemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FellowshiprosteritemGroupByOutputType>[]
          }
          count: {
            args: Prisma.fellowshiprosteritemCountArgs<ExtArgs>
            result: $Utils.Optional<FellowshiprosteritemCountAggregateOutputType> | number
          }
        }
      }
      friendship: {
        payload: Prisma.$friendshipPayload<ExtArgs>
        fields: Prisma.friendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.friendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.friendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          findFirst: {
            args: Prisma.friendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.friendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          findMany: {
            args: Prisma.friendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>[]
          }
          create: {
            args: Prisma.friendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          createMany: {
            args: Prisma.friendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.friendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          update: {
            args: Prisma.friendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          deleteMany: {
            args: Prisma.friendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.friendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.friendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.friendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.friendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      frontendactivitylog: {
        payload: Prisma.$frontendactivitylogPayload<ExtArgs>
        fields: Prisma.frontendactivitylogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.frontendactivitylogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.frontendactivitylogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload>
          }
          findFirst: {
            args: Prisma.frontendactivitylogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.frontendactivitylogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload>
          }
          findMany: {
            args: Prisma.frontendactivitylogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload>[]
          }
          create: {
            args: Prisma.frontendactivitylogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload>
          }
          createMany: {
            args: Prisma.frontendactivitylogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.frontendactivitylogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload>
          }
          update: {
            args: Prisma.frontendactivitylogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload>
          }
          deleteMany: {
            args: Prisma.frontendactivitylogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.frontendactivitylogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.frontendactivitylogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$frontendactivitylogPayload>
          }
          aggregate: {
            args: Prisma.FrontendactivitylogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFrontendactivitylog>
          }
          groupBy: {
            args: Prisma.frontendactivitylogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FrontendactivitylogGroupByOutputType>[]
          }
          count: {
            args: Prisma.frontendactivitylogCountArgs<ExtArgs>
            result: $Utils.Optional<FrontendactivitylogCountAggregateOutputType> | number
          }
        }
      }
      generatedscheduleitem: {
        payload: Prisma.$generatedscheduleitemPayload<ExtArgs>
        fields: Prisma.generatedscheduleitemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.generatedscheduleitemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.generatedscheduleitemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload>
          }
          findFirst: {
            args: Prisma.generatedscheduleitemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.generatedscheduleitemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload>
          }
          findMany: {
            args: Prisma.generatedscheduleitemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload>[]
          }
          create: {
            args: Prisma.generatedscheduleitemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload>
          }
          createMany: {
            args: Prisma.generatedscheduleitemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.generatedscheduleitemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload>
          }
          update: {
            args: Prisma.generatedscheduleitemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload>
          }
          deleteMany: {
            args: Prisma.generatedscheduleitemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.generatedscheduleitemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.generatedscheduleitemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$generatedscheduleitemPayload>
          }
          aggregate: {
            args: Prisma.GeneratedscheduleitemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedscheduleitem>
          }
          groupBy: {
            args: Prisma.generatedscheduleitemGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedscheduleitemGroupByOutputType>[]
          }
          count: {
            args: Prisma.generatedscheduleitemCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedscheduleitemCountAggregateOutputType> | number
          }
        }
      }
      group: {
        payload: Prisma.$groupPayload<ExtArgs>
        fields: Prisma.groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          findFirst: {
            args: Prisma.groupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          findMany: {
            args: Prisma.groupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>[]
          }
          create: {
            args: Prisma.groupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          createMany: {
            args: Prisma.groupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.groupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          update: {
            args: Prisma.groupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          deleteMany: {
            args: Prisma.groupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.groupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.groupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      groupmember: {
        payload: Prisma.$groupmemberPayload<ExtArgs>
        fields: Prisma.groupmemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupmemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupmemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload>
          }
          findFirst: {
            args: Prisma.groupmemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupmemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload>
          }
          findMany: {
            args: Prisma.groupmemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload>[]
          }
          create: {
            args: Prisma.groupmemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload>
          }
          createMany: {
            args: Prisma.groupmemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.groupmemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload>
          }
          update: {
            args: Prisma.groupmemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload>
          }
          deleteMany: {
            args: Prisma.groupmemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupmemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.groupmemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmemberPayload>
          }
          aggregate: {
            args: Prisma.GroupmemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupmember>
          }
          groupBy: {
            args: Prisma.groupmemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupmemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupmemberCountArgs<ExtArgs>
            result: $Utils.Optional<GroupmemberCountAggregateOutputType> | number
          }
        }
      }
      groupmessage: {
        payload: Prisma.$groupmessagePayload<ExtArgs>
        fields: Prisma.groupmessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupmessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupmessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload>
          }
          findFirst: {
            args: Prisma.groupmessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupmessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload>
          }
          findMany: {
            args: Prisma.groupmessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload>[]
          }
          create: {
            args: Prisma.groupmessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload>
          }
          createMany: {
            args: Prisma.groupmessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.groupmessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload>
          }
          update: {
            args: Prisma.groupmessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload>
          }
          deleteMany: {
            args: Prisma.groupmessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupmessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.groupmessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupmessagePayload>
          }
          aggregate: {
            args: Prisma.GroupmessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupmessage>
          }
          groupBy: {
            args: Prisma.groupmessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupmessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupmessageCountArgs<ExtArgs>
            result: $Utils.Optional<GroupmessageCountAggregateOutputType> | number
          }
        }
      }
      historychapter: {
        payload: Prisma.$historychapterPayload<ExtArgs>
        fields: Prisma.historychapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historychapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historychapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload>
          }
          findFirst: {
            args: Prisma.historychapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historychapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload>
          }
          findMany: {
            args: Prisma.historychapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload>[]
          }
          create: {
            args: Prisma.historychapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload>
          }
          createMany: {
            args: Prisma.historychapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.historychapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload>
          }
          update: {
            args: Prisma.historychapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload>
          }
          deleteMany: {
            args: Prisma.historychapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historychapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.historychapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historychapterPayload>
          }
          aggregate: {
            args: Prisma.HistorychapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistorychapter>
          }
          groupBy: {
            args: Prisma.historychapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistorychapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.historychapterCountArgs<ExtArgs>
            result: $Utils.Optional<HistorychapterCountAggregateOutputType> | number
          }
        }
      }
      historymilestone: {
        payload: Prisma.$historymilestonePayload<ExtArgs>
        fields: Prisma.historymilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historymilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historymilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload>
          }
          findFirst: {
            args: Prisma.historymilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historymilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload>
          }
          findMany: {
            args: Prisma.historymilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload>[]
          }
          create: {
            args: Prisma.historymilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload>
          }
          createMany: {
            args: Prisma.historymilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.historymilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload>
          }
          update: {
            args: Prisma.historymilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload>
          }
          deleteMany: {
            args: Prisma.historymilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historymilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.historymilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historymilestonePayload>
          }
          aggregate: {
            args: Prisma.HistorymilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistorymilestone>
          }
          groupBy: {
            args: Prisma.historymilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistorymilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.historymilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<HistorymilestoneCountAggregateOutputType> | number
          }
        }
      }
      homeslide: {
        payload: Prisma.$homeslidePayload<ExtArgs>
        fields: Prisma.homeslideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.homeslideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.homeslideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload>
          }
          findFirst: {
            args: Prisma.homeslideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.homeslideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload>
          }
          findMany: {
            args: Prisma.homeslideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload>[]
          }
          create: {
            args: Prisma.homeslideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload>
          }
          createMany: {
            args: Prisma.homeslideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.homeslideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload>
          }
          update: {
            args: Prisma.homeslideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload>
          }
          deleteMany: {
            args: Prisma.homeslideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.homeslideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.homeslideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$homeslidePayload>
          }
          aggregate: {
            args: Prisma.HomeslideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomeslide>
          }
          groupBy: {
            args: Prisma.homeslideGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomeslideGroupByOutputType>[]
          }
          count: {
            args: Prisma.homeslideCountArgs<ExtArgs>
            result: $Utils.Optional<HomeslideCountAggregateOutputType> | number
          }
        }
      }
      keyperson: {
        payload: Prisma.$keypersonPayload<ExtArgs>
        fields: Prisma.keypersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.keypersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.keypersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload>
          }
          findFirst: {
            args: Prisma.keypersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.keypersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload>
          }
          findMany: {
            args: Prisma.keypersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload>[]
          }
          create: {
            args: Prisma.keypersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload>
          }
          createMany: {
            args: Prisma.keypersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.keypersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload>
          }
          update: {
            args: Prisma.keypersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload>
          }
          deleteMany: {
            args: Prisma.keypersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.keypersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.keypersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keypersonPayload>
          }
          aggregate: {
            args: Prisma.KeypersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyperson>
          }
          groupBy: {
            args: Prisma.keypersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeypersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.keypersonCountArgs<ExtArgs>
            result: $Utils.Optional<KeypersonCountAggregateOutputType> | number
          }
        }
      }
      meetingdecisionpoint: {
        payload: Prisma.$meetingdecisionpointPayload<ExtArgs>
        fields: Prisma.meetingdecisionpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meetingdecisionpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meetingdecisionpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload>
          }
          findFirst: {
            args: Prisma.meetingdecisionpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meetingdecisionpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload>
          }
          findMany: {
            args: Prisma.meetingdecisionpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload>[]
          }
          create: {
            args: Prisma.meetingdecisionpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload>
          }
          createMany: {
            args: Prisma.meetingdecisionpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meetingdecisionpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload>
          }
          update: {
            args: Prisma.meetingdecisionpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload>
          }
          deleteMany: {
            args: Prisma.meetingdecisionpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meetingdecisionpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meetingdecisionpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingdecisionpointPayload>
          }
          aggregate: {
            args: Prisma.MeetingdecisionpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingdecisionpoint>
          }
          groupBy: {
            args: Prisma.meetingdecisionpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingdecisionpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.meetingdecisionpointCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingdecisionpointCountAggregateOutputType> | number
          }
        }
      }
      meetinglog: {
        payload: Prisma.$meetinglogPayload<ExtArgs>
        fields: Prisma.meetinglogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meetinglogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meetinglogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload>
          }
          findFirst: {
            args: Prisma.meetinglogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meetinglogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload>
          }
          findMany: {
            args: Prisma.meetinglogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload>[]
          }
          create: {
            args: Prisma.meetinglogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload>
          }
          createMany: {
            args: Prisma.meetinglogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meetinglogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload>
          }
          update: {
            args: Prisma.meetinglogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload>
          }
          deleteMany: {
            args: Prisma.meetinglogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meetinglogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meetinglogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetinglogPayload>
          }
          aggregate: {
            args: Prisma.MeetinglogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetinglog>
          }
          groupBy: {
            args: Prisma.meetinglogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetinglogGroupByOutputType>[]
          }
          count: {
            args: Prisma.meetinglogCountArgs<ExtArgs>
            result: $Utils.Optional<MeetinglogCountAggregateOutputType> | number
          }
        }
      }
      ministry: {
        payload: Prisma.$ministryPayload<ExtArgs>
        fields: Prisma.ministryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ministryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ministryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload>
          }
          findFirst: {
            args: Prisma.ministryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ministryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload>
          }
          findMany: {
            args: Prisma.ministryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload>[]
          }
          create: {
            args: Prisma.ministryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload>
          }
          createMany: {
            args: Prisma.ministryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ministryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload>
          }
          update: {
            args: Prisma.ministryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload>
          }
          deleteMany: {
            args: Prisma.ministryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ministryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ministryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryPayload>
          }
          aggregate: {
            args: Prisma.MinistryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinistry>
          }
          groupBy: {
            args: Prisma.ministryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinistryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ministryCountArgs<ExtArgs>
            result: $Utils.Optional<MinistryCountAggregateOutputType> | number
          }
        }
      }
      ministryjoinrequest: {
        payload: Prisma.$ministryjoinrequestPayload<ExtArgs>
        fields: Prisma.ministryjoinrequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ministryjoinrequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ministryjoinrequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload>
          }
          findFirst: {
            args: Prisma.ministryjoinrequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ministryjoinrequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload>
          }
          findMany: {
            args: Prisma.ministryjoinrequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload>[]
          }
          create: {
            args: Prisma.ministryjoinrequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload>
          }
          createMany: {
            args: Prisma.ministryjoinrequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ministryjoinrequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload>
          }
          update: {
            args: Prisma.ministryjoinrequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload>
          }
          deleteMany: {
            args: Prisma.ministryjoinrequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ministryjoinrequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ministryjoinrequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ministryjoinrequestPayload>
          }
          aggregate: {
            args: Prisma.MinistryjoinrequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinistryjoinrequest>
          }
          groupBy: {
            args: Prisma.ministryjoinrequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinistryjoinrequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ministryjoinrequestCountArgs<ExtArgs>
            result: $Utils.Optional<MinistryjoinrequestCountAggregateOutputType> | number
          }
        }
      }
      monthlythemeimage: {
        payload: Prisma.$monthlythemeimagePayload<ExtArgs>
        fields: Prisma.monthlythemeimageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.monthlythemeimageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.monthlythemeimageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload>
          }
          findFirst: {
            args: Prisma.monthlythemeimageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.monthlythemeimageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload>
          }
          findMany: {
            args: Prisma.monthlythemeimageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload>[]
          }
          create: {
            args: Prisma.monthlythemeimageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload>
          }
          createMany: {
            args: Prisma.monthlythemeimageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.monthlythemeimageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload>
          }
          update: {
            args: Prisma.monthlythemeimageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload>
          }
          deleteMany: {
            args: Prisma.monthlythemeimageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.monthlythemeimageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.monthlythemeimageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$monthlythemeimagePayload>
          }
          aggregate: {
            args: Prisma.MonthlythemeimageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthlythemeimage>
          }
          groupBy: {
            args: Prisma.monthlythemeimageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthlythemeimageGroupByOutputType>[]
          }
          count: {
            args: Prisma.monthlythemeimageCountArgs<ExtArgs>
            result: $Utils.Optional<MonthlythemeimageCountAggregateOutputType> | number
          }
        }
      }
      newsitem: {
        payload: Prisma.$newsitemPayload<ExtArgs>
        fields: Prisma.newsitemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsitemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsitemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload>
          }
          findFirst: {
            args: Prisma.newsitemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsitemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload>
          }
          findMany: {
            args: Prisma.newsitemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload>[]
          }
          create: {
            args: Prisma.newsitemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload>
          }
          createMany: {
            args: Prisma.newsitemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.newsitemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload>
          }
          update: {
            args: Prisma.newsitemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload>
          }
          deleteMany: {
            args: Prisma.newsitemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.newsitemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.newsitemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$newsitemPayload>
          }
          aggregate: {
            args: Prisma.NewsitemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNewsitem>
          }
          groupBy: {
            args: Prisma.newsitemGroupByArgs<ExtArgs>
            result: $Utils.Optional<NewsitemGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsitemCountArgs<ExtArgs>
            result: $Utils.Optional<NewsitemCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      prayer: {
        payload: Prisma.$prayerPayload<ExtArgs>
        fields: Prisma.prayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload>
          }
          findFirst: {
            args: Prisma.prayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload>
          }
          findMany: {
            args: Prisma.prayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload>[]
          }
          create: {
            args: Prisma.prayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload>
          }
          createMany: {
            args: Prisma.prayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.prayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload>
          }
          update: {
            args: Prisma.prayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload>
          }
          deleteMany: {
            args: Prisma.prayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerPayload>
          }
          aggregate: {
            args: Prisma.PrayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrayer>
          }
          groupBy: {
            args: Prisma.prayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.prayerCountArgs<ExtArgs>
            result: $Utils.Optional<PrayerCountAggregateOutputType> | number
          }
        }
      }
      prayerrequest: {
        payload: Prisma.$prayerrequestPayload<ExtArgs>
        fields: Prisma.prayerrequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prayerrequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prayerrequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload>
          }
          findFirst: {
            args: Prisma.prayerrequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prayerrequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload>
          }
          findMany: {
            args: Prisma.prayerrequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload>[]
          }
          create: {
            args: Prisma.prayerrequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload>
          }
          createMany: {
            args: Prisma.prayerrequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.prayerrequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload>
          }
          update: {
            args: Prisma.prayerrequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload>
          }
          deleteMany: {
            args: Prisma.prayerrequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prayerrequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.prayerrequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prayerrequestPayload>
          }
          aggregate: {
            args: Prisma.PrayerrequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrayerrequest>
          }
          groupBy: {
            args: Prisma.prayerrequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrayerrequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.prayerrequestCountArgs<ExtArgs>
            result: $Utils.Optional<PrayerrequestCountAggregateOutputType> | number
          }
        }
      }
      responsibility: {
        payload: Prisma.$responsibilityPayload<ExtArgs>
        fields: Prisma.responsibilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.responsibilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.responsibilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload>
          }
          findFirst: {
            args: Prisma.responsibilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.responsibilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload>
          }
          findMany: {
            args: Prisma.responsibilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload>[]
          }
          create: {
            args: Prisma.responsibilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload>
          }
          createMany: {
            args: Prisma.responsibilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.responsibilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload>
          }
          update: {
            args: Prisma.responsibilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload>
          }
          deleteMany: {
            args: Prisma.responsibilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.responsibilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.responsibilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsibilityPayload>
          }
          aggregate: {
            args: Prisma.ResponsibilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponsibility>
          }
          groupBy: {
            args: Prisma.responsibilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponsibilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.responsibilityCountArgs<ExtArgs>
            result: $Utils.Optional<ResponsibilityCountAggregateOutputType> | number
          }
        }
      }
      sermon: {
        payload: Prisma.$sermonPayload<ExtArgs>
        fields: Prisma.sermonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sermonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sermonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload>
          }
          findFirst: {
            args: Prisma.sermonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sermonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload>
          }
          findMany: {
            args: Prisma.sermonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload>[]
          }
          create: {
            args: Prisma.sermonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload>
          }
          createMany: {
            args: Prisma.sermonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sermonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload>
          }
          update: {
            args: Prisma.sermonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload>
          }
          deleteMany: {
            args: Prisma.sermonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sermonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sermonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sermonPayload>
          }
          aggregate: {
            args: Prisma.SermonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSermon>
          }
          groupBy: {
            args: Prisma.sermonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SermonGroupByOutputType>[]
          }
          count: {
            args: Prisma.sermonCountArgs<ExtArgs>
            result: $Utils.Optional<SermonCountAggregateOutputType> | number
          }
        }
      }
      testimonial: {
        payload: Prisma.$testimonialPayload<ExtArgs>
        fields: Prisma.testimonialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testimonialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testimonialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          findFirst: {
            args: Prisma.testimonialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testimonialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          findMany: {
            args: Prisma.testimonialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>[]
          }
          create: {
            args: Prisma.testimonialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          createMany: {
            args: Prisma.testimonialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testimonialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          update: {
            args: Prisma.testimonialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          deleteMany: {
            args: Prisma.testimonialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testimonialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testimonialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testimonialPayload>
          }
          aggregate: {
            args: Prisma.TestimonialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestimonial>
          }
          groupBy: {
            args: Prisma.testimonialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestimonialGroupByOutputType>[]
          }
          count: {
            args: Prisma.testimonialCountArgs<ExtArgs>
            result: $Utils.Optional<TestimonialCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BlogpostCountOutputType
   */

  export type BlogpostCountOutputType = {
    comment: number
  }

  export type BlogpostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | BlogpostCountOutputTypeCountCommentArgs
  }

  // Custom InputTypes
  /**
   * BlogpostCountOutputType without action
   */
  export type BlogpostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogpostCountOutputType
     */
    select?: BlogpostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogpostCountOutputType without action
   */
  export type BlogpostCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }


  /**
   * Count Type CollectionrecordCountOutputType
   */

  export type CollectionrecordCountOutputType = {
    donordetail: number
  }

  export type CollectionrecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donordetail?: boolean | CollectionrecordCountOutputTypeCountDonordetailArgs
  }

  // Custom InputTypes
  /**
   * CollectionrecordCountOutputType without action
   */
  export type CollectionrecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionrecordCountOutputType
     */
    select?: CollectionrecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionrecordCountOutputType without action
   */
  export type CollectionrecordCountOutputTypeCountDonordetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: donordetailWhereInput
  }


  /**
   * Count Type EventitemCountOutputType
   */

  export type EventitemCountOutputType = {
    comment: number
  }

  export type EventitemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | EventitemCountOutputTypeCountCommentArgs
  }

  // Custom InputTypes
  /**
   * EventitemCountOutputType without action
   */
  export type EventitemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventitemCountOutputType
     */
    select?: EventitemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventitemCountOutputType without action
   */
  export type EventitemCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }


  /**
   * Count Type FellowshiprosteritemCountOutputType
   */

  export type FellowshiprosteritemCountOutputType = {
    generatedscheduleitem: number
    responsibility: number
  }

  export type FellowshiprosteritemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedscheduleitem?: boolean | FellowshiprosteritemCountOutputTypeCountGeneratedscheduleitemArgs
    responsibility?: boolean | FellowshiprosteritemCountOutputTypeCountResponsibilityArgs
  }

  // Custom InputTypes
  /**
   * FellowshiprosteritemCountOutputType without action
   */
  export type FellowshiprosteritemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FellowshiprosteritemCountOutputType
     */
    select?: FellowshiprosteritemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FellowshiprosteritemCountOutputType without action
   */
  export type FellowshiprosteritemCountOutputTypeCountGeneratedscheduleitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: generatedscheduleitemWhereInput
  }

  /**
   * FellowshiprosteritemCountOutputType without action
   */
  export type FellowshiprosteritemCountOutputTypeCountResponsibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: responsibilityWhereInput
  }


  /**
   * Count Type GeneratedscheduleitemCountOutputType
   */

  export type GeneratedscheduleitemCountOutputType = {
    responsibility: number
  }

  export type GeneratedscheduleitemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsibility?: boolean | GeneratedscheduleitemCountOutputTypeCountResponsibilityArgs
  }

  // Custom InputTypes
  /**
   * GeneratedscheduleitemCountOutputType without action
   */
  export type GeneratedscheduleitemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedscheduleitemCountOutputType
     */
    select?: GeneratedscheduleitemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneratedscheduleitemCountOutputType without action
   */
  export type GeneratedscheduleitemCountOutputTypeCountResponsibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: responsibilityWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    groupmember: number
    groupmessage: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupmember?: boolean | GroupCountOutputTypeCountGroupmemberArgs
    groupmessage?: boolean | GroupCountOutputTypeCountGroupmessageArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountGroupmemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmemberWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountGroupmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmessageWhereInput
  }


  /**
   * Count Type HistorychapterCountOutputType
   */

  export type HistorychapterCountOutputType = {
    comment: number
  }

  export type HistorychapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | HistorychapterCountOutputTypeCountCommentArgs
  }

  // Custom InputTypes
  /**
   * HistorychapterCountOutputType without action
   */
  export type HistorychapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorychapterCountOutputType
     */
    select?: HistorychapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HistorychapterCountOutputType without action
   */
  export type HistorychapterCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }


  /**
   * Count Type MeetinglogCountOutputType
   */

  export type MeetinglogCountOutputType = {
    meetingdecisionpoint: number
  }

  export type MeetinglogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meetingdecisionpoint?: boolean | MeetinglogCountOutputTypeCountMeetingdecisionpointArgs
  }

  // Custom InputTypes
  /**
   * MeetinglogCountOutputType without action
   */
  export type MeetinglogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetinglogCountOutputType
     */
    select?: MeetinglogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeetinglogCountOutputType without action
   */
  export type MeetinglogCountOutputTypeCountMeetingdecisionpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meetingdecisionpointWhereInput
  }


  /**
   * Count Type MinistryCountOutputType
   */

  export type MinistryCountOutputType = {
    ministryjoinrequest: number
  }

  export type MinistryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ministryjoinrequest?: boolean | MinistryCountOutputTypeCountMinistryjoinrequestArgs
  }

  // Custom InputTypes
  /**
   * MinistryCountOutputType without action
   */
  export type MinistryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinistryCountOutputType
     */
    select?: MinistryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MinistryCountOutputType without action
   */
  export type MinistryCountOutputTypeCountMinistryjoinrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ministryjoinrequestWhereInput
  }


  /**
   * Count Type NewsitemCountOutputType
   */

  export type NewsitemCountOutputType = {
    comment: number
  }

  export type NewsitemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | NewsitemCountOutputTypeCountCommentArgs
  }

  // Custom InputTypes
  /**
   * NewsitemCountOutputType without action
   */
  export type NewsitemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NewsitemCountOutputType
     */
    select?: NewsitemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NewsitemCountOutputType without action
   */
  export type NewsitemCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }


  /**
   * Count Type PrayerrequestCountOutputType
   */

  export type PrayerrequestCountOutputType = {
    comment: number
    prayer: number
  }

  export type PrayerrequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | PrayerrequestCountOutputTypeCountCommentArgs
    prayer?: boolean | PrayerrequestCountOutputTypeCountPrayerArgs
  }

  // Custom InputTypes
  /**
   * PrayerrequestCountOutputType without action
   */
  export type PrayerrequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrayerrequestCountOutputType
     */
    select?: PrayerrequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrayerrequestCountOutputType without action
   */
  export type PrayerrequestCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }

  /**
   * PrayerrequestCountOutputType without action
   */
  export type PrayerrequestCountOutputTypeCountPrayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prayerWhereInput
  }


  /**
   * Count Type SermonCountOutputType
   */

  export type SermonCountOutputType = {
    comment: number
  }

  export type SermonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | SermonCountOutputTypeCountCommentArgs
  }

  // Custom InputTypes
  /**
   * SermonCountOutputType without action
   */
  export type SermonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SermonCountOutputType
     */
    select?: SermonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SermonCountOutputType without action
   */
  export type SermonCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    adminactionlog: number
    comment: number
    friendship_friendship_addresseeIdTouser: number
    friendship_friendship_requesterIdTouser: number
    frontendactivitylog: number
    groupmember: number
    groupmessage: number
    ministryjoinrequest: number
    notification: number
    prayer: number
    prayerrequest: number
    testimonial: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminactionlog?: boolean | UserCountOutputTypeCountAdminactionlogArgs
    comment?: boolean | UserCountOutputTypeCountCommentArgs
    friendship_friendship_addresseeIdTouser?: boolean | UserCountOutputTypeCountFriendship_friendship_addresseeIdTouserArgs
    friendship_friendship_requesterIdTouser?: boolean | UserCountOutputTypeCountFriendship_friendship_requesterIdTouserArgs
    frontendactivitylog?: boolean | UserCountOutputTypeCountFrontendactivitylogArgs
    groupmember?: boolean | UserCountOutputTypeCountGroupmemberArgs
    groupmessage?: boolean | UserCountOutputTypeCountGroupmessageArgs
    ministryjoinrequest?: boolean | UserCountOutputTypeCountMinistryjoinrequestArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    prayer?: boolean | UserCountOutputTypeCountPrayerArgs
    prayerrequest?: boolean | UserCountOutputTypeCountPrayerrequestArgs
    testimonial?: boolean | UserCountOutputTypeCountTestimonialArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminactionlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminactionlogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendship_friendship_addresseeIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendship_friendship_requesterIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFrontendactivitylogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frontendactivitylogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupmemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMinistryjoinrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ministryjoinrequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prayerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrayerrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prayerrequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testimonialWhereInput
  }


  /**
   * Models
   */

  /**
   * Model aboutsection
   */

  export type AggregateAboutsection = {
    _count: AboutsectionCountAggregateOutputType | null
    _avg: AboutsectionAvgAggregateOutputType | null
    _sum: AboutsectionSumAggregateOutputType | null
    _min: AboutsectionMinAggregateOutputType | null
    _max: AboutsectionMaxAggregateOutputType | null
  }

  export type AboutsectionAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type AboutsectionSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type AboutsectionMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    imageUrl: string | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    isCoreSection: boolean | null
    displayOrder: number | null
    createdAt: Date | null
  }

  export type AboutsectionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    imageUrl: string | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    isCoreSection: boolean | null
    displayOrder: number | null
    createdAt: Date | null
  }

  export type AboutsectionCountAggregateOutputType = {
    id: number
    title: number
    content: number
    imageUrl: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    isCoreSection: number
    displayOrder: number
    createdAt: number
    _all: number
  }


  export type AboutsectionAvgAggregateInputType = {
    displayOrder?: true
  }

  export type AboutsectionSumAggregateInputType = {
    displayOrder?: true
  }

  export type AboutsectionMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    imageUrl?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    isCoreSection?: true
    displayOrder?: true
    createdAt?: true
  }

  export type AboutsectionMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    imageUrl?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    isCoreSection?: true
    displayOrder?: true
    createdAt?: true
  }

  export type AboutsectionCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    imageUrl?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    isCoreSection?: true
    displayOrder?: true
    createdAt?: true
    _all?: true
  }

  export type AboutsectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aboutsection to aggregate.
     */
    where?: aboutsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aboutsections to fetch.
     */
    orderBy?: aboutsectionOrderByWithRelationInput | aboutsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aboutsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aboutsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aboutsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aboutsections
    **/
    _count?: true | AboutsectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AboutsectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AboutsectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutsectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutsectionMaxAggregateInputType
  }

  export type GetAboutsectionAggregateType<T extends AboutsectionAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutsection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutsection[P]>
      : GetScalarType<T[P], AggregateAboutsection[P]>
  }




  export type aboutsectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aboutsectionWhereInput
    orderBy?: aboutsectionOrderByWithAggregationInput | aboutsectionOrderByWithAggregationInput[]
    by: AboutsectionScalarFieldEnum[] | AboutsectionScalarFieldEnum
    having?: aboutsectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutsectionCountAggregateInputType | true
    _avg?: AboutsectionAvgAggregateInputType
    _sum?: AboutsectionSumAggregateInputType
    _min?: AboutsectionMinAggregateInputType
    _max?: AboutsectionMaxAggregateInputType
  }

  export type AboutsectionGroupByOutputType = {
    id: string
    title: string
    content: string
    imageUrl: string | null
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    isCoreSection: boolean
    displayOrder: number
    createdAt: Date
    _count: AboutsectionCountAggregateOutputType | null
    _avg: AboutsectionAvgAggregateOutputType | null
    _sum: AboutsectionSumAggregateOutputType | null
    _min: AboutsectionMinAggregateOutputType | null
    _max: AboutsectionMaxAggregateOutputType | null
  }

  type GetAboutsectionGroupByPayload<T extends aboutsectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutsectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutsectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutsectionGroupByOutputType[P]>
            : GetScalarType<T[P], AboutsectionGroupByOutputType[P]>
        }
      >
    >


  export type aboutsectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    isCoreSection?: boolean
    displayOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aboutsection"]>


  export type aboutsectionSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    imageUrl?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    isCoreSection?: boolean
    displayOrder?: boolean
    createdAt?: boolean
  }


  export type $aboutsectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aboutsection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      imageUrl: string | null
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      isCoreSection: boolean
      displayOrder: number
      createdAt: Date
    }, ExtArgs["result"]["aboutsection"]>
    composites: {}
  }

  type aboutsectionGetPayload<S extends boolean | null | undefined | aboutsectionDefaultArgs> = $Result.GetResult<Prisma.$aboutsectionPayload, S>

  type aboutsectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<aboutsectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AboutsectionCountAggregateInputType | true
    }

  export interface aboutsectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aboutsection'], meta: { name: 'aboutsection' } }
    /**
     * Find zero or one Aboutsection that matches the filter.
     * @param {aboutsectionFindUniqueArgs} args - Arguments to find a Aboutsection
     * @example
     * // Get one Aboutsection
     * const aboutsection = await prisma.aboutsection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aboutsectionFindUniqueArgs>(args: SelectSubset<T, aboutsectionFindUniqueArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Aboutsection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {aboutsectionFindUniqueOrThrowArgs} args - Arguments to find a Aboutsection
     * @example
     * // Get one Aboutsection
     * const aboutsection = await prisma.aboutsection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aboutsectionFindUniqueOrThrowArgs>(args: SelectSubset<T, aboutsectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Aboutsection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutsectionFindFirstArgs} args - Arguments to find a Aboutsection
     * @example
     * // Get one Aboutsection
     * const aboutsection = await prisma.aboutsection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aboutsectionFindFirstArgs>(args?: SelectSubset<T, aboutsectionFindFirstArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Aboutsection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutsectionFindFirstOrThrowArgs} args - Arguments to find a Aboutsection
     * @example
     * // Get one Aboutsection
     * const aboutsection = await prisma.aboutsection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aboutsectionFindFirstOrThrowArgs>(args?: SelectSubset<T, aboutsectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Aboutsections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutsectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aboutsections
     * const aboutsections = await prisma.aboutsection.findMany()
     * 
     * // Get first 10 Aboutsections
     * const aboutsections = await prisma.aboutsection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutsectionWithIdOnly = await prisma.aboutsection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends aboutsectionFindManyArgs>(args?: SelectSubset<T, aboutsectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Aboutsection.
     * @param {aboutsectionCreateArgs} args - Arguments to create a Aboutsection.
     * @example
     * // Create one Aboutsection
     * const Aboutsection = await prisma.aboutsection.create({
     *   data: {
     *     // ... data to create a Aboutsection
     *   }
     * })
     * 
     */
    create<T extends aboutsectionCreateArgs>(args: SelectSubset<T, aboutsectionCreateArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Aboutsections.
     * @param {aboutsectionCreateManyArgs} args - Arguments to create many Aboutsections.
     * @example
     * // Create many Aboutsections
     * const aboutsection = await prisma.aboutsection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aboutsectionCreateManyArgs>(args?: SelectSubset<T, aboutsectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Aboutsection.
     * @param {aboutsectionDeleteArgs} args - Arguments to delete one Aboutsection.
     * @example
     * // Delete one Aboutsection
     * const Aboutsection = await prisma.aboutsection.delete({
     *   where: {
     *     // ... filter to delete one Aboutsection
     *   }
     * })
     * 
     */
    delete<T extends aboutsectionDeleteArgs>(args: SelectSubset<T, aboutsectionDeleteArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Aboutsection.
     * @param {aboutsectionUpdateArgs} args - Arguments to update one Aboutsection.
     * @example
     * // Update one Aboutsection
     * const aboutsection = await prisma.aboutsection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aboutsectionUpdateArgs>(args: SelectSubset<T, aboutsectionUpdateArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Aboutsections.
     * @param {aboutsectionDeleteManyArgs} args - Arguments to filter Aboutsections to delete.
     * @example
     * // Delete a few Aboutsections
     * const { count } = await prisma.aboutsection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aboutsectionDeleteManyArgs>(args?: SelectSubset<T, aboutsectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aboutsections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutsectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aboutsections
     * const aboutsection = await prisma.aboutsection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aboutsectionUpdateManyArgs>(args: SelectSubset<T, aboutsectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aboutsection.
     * @param {aboutsectionUpsertArgs} args - Arguments to update or create a Aboutsection.
     * @example
     * // Update or create a Aboutsection
     * const aboutsection = await prisma.aboutsection.upsert({
     *   create: {
     *     // ... data to create a Aboutsection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aboutsection we want to update
     *   }
     * })
     */
    upsert<T extends aboutsectionUpsertArgs>(args: SelectSubset<T, aboutsectionUpsertArgs<ExtArgs>>): Prisma__aboutsectionClient<$Result.GetResult<Prisma.$aboutsectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Aboutsections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutsectionCountArgs} args - Arguments to filter Aboutsections to count.
     * @example
     * // Count the number of Aboutsections
     * const count = await prisma.aboutsection.count({
     *   where: {
     *     // ... the filter for the Aboutsections we want to count
     *   }
     * })
    **/
    count<T extends aboutsectionCountArgs>(
      args?: Subset<T, aboutsectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutsectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aboutsection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutsectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutsectionAggregateArgs>(args: Subset<T, AboutsectionAggregateArgs>): Prisma.PrismaPromise<GetAboutsectionAggregateType<T>>

    /**
     * Group by Aboutsection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutsectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aboutsectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aboutsectionGroupByArgs['orderBy'] }
        : { orderBy?: aboutsectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aboutsectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutsectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aboutsection model
   */
  readonly fields: aboutsectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aboutsection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aboutsectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aboutsection model
   */ 
  interface aboutsectionFieldRefs {
    readonly id: FieldRef<"aboutsection", 'String'>
    readonly title: FieldRef<"aboutsection", 'String'>
    readonly content: FieldRef<"aboutsection", 'String'>
    readonly imageUrl: FieldRef<"aboutsection", 'String'>
    readonly updatedAt: FieldRef<"aboutsection", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"aboutsection", 'String'>
    readonly postedByOwnerName: FieldRef<"aboutsection", 'String'>
    readonly isCoreSection: FieldRef<"aboutsection", 'Boolean'>
    readonly displayOrder: FieldRef<"aboutsection", 'Int'>
    readonly createdAt: FieldRef<"aboutsection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * aboutsection findUnique
   */
  export type aboutsectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * Filter, which aboutsection to fetch.
     */
    where: aboutsectionWhereUniqueInput
  }

  /**
   * aboutsection findUniqueOrThrow
   */
  export type aboutsectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * Filter, which aboutsection to fetch.
     */
    where: aboutsectionWhereUniqueInput
  }

  /**
   * aboutsection findFirst
   */
  export type aboutsectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * Filter, which aboutsection to fetch.
     */
    where?: aboutsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aboutsections to fetch.
     */
    orderBy?: aboutsectionOrderByWithRelationInput | aboutsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aboutsections.
     */
    cursor?: aboutsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aboutsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aboutsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aboutsections.
     */
    distinct?: AboutsectionScalarFieldEnum | AboutsectionScalarFieldEnum[]
  }

  /**
   * aboutsection findFirstOrThrow
   */
  export type aboutsectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * Filter, which aboutsection to fetch.
     */
    where?: aboutsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aboutsections to fetch.
     */
    orderBy?: aboutsectionOrderByWithRelationInput | aboutsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aboutsections.
     */
    cursor?: aboutsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aboutsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aboutsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aboutsections.
     */
    distinct?: AboutsectionScalarFieldEnum | AboutsectionScalarFieldEnum[]
  }

  /**
   * aboutsection findMany
   */
  export type aboutsectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * Filter, which aboutsections to fetch.
     */
    where?: aboutsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aboutsections to fetch.
     */
    orderBy?: aboutsectionOrderByWithRelationInput | aboutsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aboutsections.
     */
    cursor?: aboutsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aboutsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aboutsections.
     */
    skip?: number
    distinct?: AboutsectionScalarFieldEnum | AboutsectionScalarFieldEnum[]
  }

  /**
   * aboutsection create
   */
  export type aboutsectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * The data needed to create a aboutsection.
     */
    data: XOR<aboutsectionCreateInput, aboutsectionUncheckedCreateInput>
  }

  /**
   * aboutsection createMany
   */
  export type aboutsectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aboutsections.
     */
    data: aboutsectionCreateManyInput | aboutsectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aboutsection update
   */
  export type aboutsectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * The data needed to update a aboutsection.
     */
    data: XOR<aboutsectionUpdateInput, aboutsectionUncheckedUpdateInput>
    /**
     * Choose, which aboutsection to update.
     */
    where: aboutsectionWhereUniqueInput
  }

  /**
   * aboutsection updateMany
   */
  export type aboutsectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aboutsections.
     */
    data: XOR<aboutsectionUpdateManyMutationInput, aboutsectionUncheckedUpdateManyInput>
    /**
     * Filter which aboutsections to update
     */
    where?: aboutsectionWhereInput
  }

  /**
   * aboutsection upsert
   */
  export type aboutsectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * The filter to search for the aboutsection to update in case it exists.
     */
    where: aboutsectionWhereUniqueInput
    /**
     * In case the aboutsection found by the `where` argument doesn't exist, create a new aboutsection with this data.
     */
    create: XOR<aboutsectionCreateInput, aboutsectionUncheckedCreateInput>
    /**
     * In case the aboutsection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aboutsectionUpdateInput, aboutsectionUncheckedUpdateInput>
  }

  /**
   * aboutsection delete
   */
  export type aboutsectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
    /**
     * Filter which aboutsection to delete.
     */
    where: aboutsectionWhereUniqueInput
  }

  /**
   * aboutsection deleteMany
   */
  export type aboutsectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aboutsections to delete
     */
    where?: aboutsectionWhereInput
  }

  /**
   * aboutsection without action
   */
  export type aboutsectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aboutsection
     */
    select?: aboutsectionSelect<ExtArgs> | null
  }


  /**
   * Model adminactionlog
   */

  export type AggregateAdminactionlog = {
    _count: AdminactionlogCountAggregateOutputType | null
    _min: AdminactionlogMinAggregateOutputType | null
    _max: AdminactionlogMaxAggregateOutputType | null
  }

  export type AdminactionlogMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    adminId: string | null
    adminName: string | null
    action: string | null
    targetId: string | null
    details: string | null
  }

  export type AdminactionlogMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    adminId: string | null
    adminName: string | null
    action: string | null
    targetId: string | null
    details: string | null
  }

  export type AdminactionlogCountAggregateOutputType = {
    id: number
    timestamp: number
    adminId: number
    adminName: number
    action: number
    targetId: number
    details: number
    _all: number
  }


  export type AdminactionlogMinAggregateInputType = {
    id?: true
    timestamp?: true
    adminId?: true
    adminName?: true
    action?: true
    targetId?: true
    details?: true
  }

  export type AdminactionlogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    adminId?: true
    adminName?: true
    action?: true
    targetId?: true
    details?: true
  }

  export type AdminactionlogCountAggregateInputType = {
    id?: true
    timestamp?: true
    adminId?: true
    adminName?: true
    action?: true
    targetId?: true
    details?: true
    _all?: true
  }

  export type AdminactionlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which adminactionlog to aggregate.
     */
    where?: adminactionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adminactionlogs to fetch.
     */
    orderBy?: adminactionlogOrderByWithRelationInput | adminactionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminactionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adminactionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adminactionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned adminactionlogs
    **/
    _count?: true | AdminactionlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminactionlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminactionlogMaxAggregateInputType
  }

  export type GetAdminactionlogAggregateType<T extends AdminactionlogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminactionlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminactionlog[P]>
      : GetScalarType<T[P], AggregateAdminactionlog[P]>
  }




  export type adminactionlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminactionlogWhereInput
    orderBy?: adminactionlogOrderByWithAggregationInput | adminactionlogOrderByWithAggregationInput[]
    by: AdminactionlogScalarFieldEnum[] | AdminactionlogScalarFieldEnum
    having?: adminactionlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminactionlogCountAggregateInputType | true
    _min?: AdminactionlogMinAggregateInputType
    _max?: AdminactionlogMaxAggregateInputType
  }

  export type AdminactionlogGroupByOutputType = {
    id: string
    timestamp: Date
    adminId: string
    adminName: string
    action: string
    targetId: string | null
    details: string | null
    _count: AdminactionlogCountAggregateOutputType | null
    _min: AdminactionlogMinAggregateOutputType | null
    _max: AdminactionlogMaxAggregateOutputType | null
  }

  type GetAdminactionlogGroupByPayload<T extends adminactionlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminactionlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminactionlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminactionlogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminactionlogGroupByOutputType[P]>
        }
      >
    >


  export type adminactionlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    adminId?: boolean
    adminName?: boolean
    action?: boolean
    targetId?: boolean
    details?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminactionlog"]>


  export type adminactionlogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    adminId?: boolean
    adminName?: boolean
    action?: boolean
    targetId?: boolean
    details?: boolean
  }

  export type adminactionlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $adminactionlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "adminactionlog"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      adminId: string
      adminName: string
      action: string
      targetId: string | null
      details: string | null
    }, ExtArgs["result"]["adminactionlog"]>
    composites: {}
  }

  type adminactionlogGetPayload<S extends boolean | null | undefined | adminactionlogDefaultArgs> = $Result.GetResult<Prisma.$adminactionlogPayload, S>

  type adminactionlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<adminactionlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminactionlogCountAggregateInputType | true
    }

  export interface adminactionlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['adminactionlog'], meta: { name: 'adminactionlog' } }
    /**
     * Find zero or one Adminactionlog that matches the filter.
     * @param {adminactionlogFindUniqueArgs} args - Arguments to find a Adminactionlog
     * @example
     * // Get one Adminactionlog
     * const adminactionlog = await prisma.adminactionlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminactionlogFindUniqueArgs>(args: SelectSubset<T, adminactionlogFindUniqueArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Adminactionlog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {adminactionlogFindUniqueOrThrowArgs} args - Arguments to find a Adminactionlog
     * @example
     * // Get one Adminactionlog
     * const adminactionlog = await prisma.adminactionlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminactionlogFindUniqueOrThrowArgs>(args: SelectSubset<T, adminactionlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Adminactionlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminactionlogFindFirstArgs} args - Arguments to find a Adminactionlog
     * @example
     * // Get one Adminactionlog
     * const adminactionlog = await prisma.adminactionlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminactionlogFindFirstArgs>(args?: SelectSubset<T, adminactionlogFindFirstArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Adminactionlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminactionlogFindFirstOrThrowArgs} args - Arguments to find a Adminactionlog
     * @example
     * // Get one Adminactionlog
     * const adminactionlog = await prisma.adminactionlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminactionlogFindFirstOrThrowArgs>(args?: SelectSubset<T, adminactionlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Adminactionlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminactionlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adminactionlogs
     * const adminactionlogs = await prisma.adminactionlog.findMany()
     * 
     * // Get first 10 Adminactionlogs
     * const adminactionlogs = await prisma.adminactionlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminactionlogWithIdOnly = await prisma.adminactionlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminactionlogFindManyArgs>(args?: SelectSubset<T, adminactionlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Adminactionlog.
     * @param {adminactionlogCreateArgs} args - Arguments to create a Adminactionlog.
     * @example
     * // Create one Adminactionlog
     * const Adminactionlog = await prisma.adminactionlog.create({
     *   data: {
     *     // ... data to create a Adminactionlog
     *   }
     * })
     * 
     */
    create<T extends adminactionlogCreateArgs>(args: SelectSubset<T, adminactionlogCreateArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Adminactionlogs.
     * @param {adminactionlogCreateManyArgs} args - Arguments to create many Adminactionlogs.
     * @example
     * // Create many Adminactionlogs
     * const adminactionlog = await prisma.adminactionlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminactionlogCreateManyArgs>(args?: SelectSubset<T, adminactionlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Adminactionlog.
     * @param {adminactionlogDeleteArgs} args - Arguments to delete one Adminactionlog.
     * @example
     * // Delete one Adminactionlog
     * const Adminactionlog = await prisma.adminactionlog.delete({
     *   where: {
     *     // ... filter to delete one Adminactionlog
     *   }
     * })
     * 
     */
    delete<T extends adminactionlogDeleteArgs>(args: SelectSubset<T, adminactionlogDeleteArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Adminactionlog.
     * @param {adminactionlogUpdateArgs} args - Arguments to update one Adminactionlog.
     * @example
     * // Update one Adminactionlog
     * const adminactionlog = await prisma.adminactionlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminactionlogUpdateArgs>(args: SelectSubset<T, adminactionlogUpdateArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Adminactionlogs.
     * @param {adminactionlogDeleteManyArgs} args - Arguments to filter Adminactionlogs to delete.
     * @example
     * // Delete a few Adminactionlogs
     * const { count } = await prisma.adminactionlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminactionlogDeleteManyArgs>(args?: SelectSubset<T, adminactionlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adminactionlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminactionlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adminactionlogs
     * const adminactionlog = await prisma.adminactionlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminactionlogUpdateManyArgs>(args: SelectSubset<T, adminactionlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Adminactionlog.
     * @param {adminactionlogUpsertArgs} args - Arguments to update or create a Adminactionlog.
     * @example
     * // Update or create a Adminactionlog
     * const adminactionlog = await prisma.adminactionlog.upsert({
     *   create: {
     *     // ... data to create a Adminactionlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adminactionlog we want to update
     *   }
     * })
     */
    upsert<T extends adminactionlogUpsertArgs>(args: SelectSubset<T, adminactionlogUpsertArgs<ExtArgs>>): Prisma__adminactionlogClient<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Adminactionlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminactionlogCountArgs} args - Arguments to filter Adminactionlogs to count.
     * @example
     * // Count the number of Adminactionlogs
     * const count = await prisma.adminactionlog.count({
     *   where: {
     *     // ... the filter for the Adminactionlogs we want to count
     *   }
     * })
    **/
    count<T extends adminactionlogCountArgs>(
      args?: Subset<T, adminactionlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminactionlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adminactionlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminactionlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminactionlogAggregateArgs>(args: Subset<T, AdminactionlogAggregateArgs>): Prisma.PrismaPromise<GetAdminactionlogAggregateType<T>>

    /**
     * Group by Adminactionlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminactionlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminactionlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminactionlogGroupByArgs['orderBy'] }
        : { orderBy?: adminactionlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminactionlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminactionlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the adminactionlog model
   */
  readonly fields: adminactionlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for adminactionlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminactionlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the adminactionlog model
   */ 
  interface adminactionlogFieldRefs {
    readonly id: FieldRef<"adminactionlog", 'String'>
    readonly timestamp: FieldRef<"adminactionlog", 'DateTime'>
    readonly adminId: FieldRef<"adminactionlog", 'String'>
    readonly adminName: FieldRef<"adminactionlog", 'String'>
    readonly action: FieldRef<"adminactionlog", 'String'>
    readonly targetId: FieldRef<"adminactionlog", 'String'>
    readonly details: FieldRef<"adminactionlog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * adminactionlog findUnique
   */
  export type adminactionlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * Filter, which adminactionlog to fetch.
     */
    where: adminactionlogWhereUniqueInput
  }

  /**
   * adminactionlog findUniqueOrThrow
   */
  export type adminactionlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * Filter, which adminactionlog to fetch.
     */
    where: adminactionlogWhereUniqueInput
  }

  /**
   * adminactionlog findFirst
   */
  export type adminactionlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * Filter, which adminactionlog to fetch.
     */
    where?: adminactionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adminactionlogs to fetch.
     */
    orderBy?: adminactionlogOrderByWithRelationInput | adminactionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for adminactionlogs.
     */
    cursor?: adminactionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adminactionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adminactionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of adminactionlogs.
     */
    distinct?: AdminactionlogScalarFieldEnum | AdminactionlogScalarFieldEnum[]
  }

  /**
   * adminactionlog findFirstOrThrow
   */
  export type adminactionlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * Filter, which adminactionlog to fetch.
     */
    where?: adminactionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adminactionlogs to fetch.
     */
    orderBy?: adminactionlogOrderByWithRelationInput | adminactionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for adminactionlogs.
     */
    cursor?: adminactionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adminactionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adminactionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of adminactionlogs.
     */
    distinct?: AdminactionlogScalarFieldEnum | AdminactionlogScalarFieldEnum[]
  }

  /**
   * adminactionlog findMany
   */
  export type adminactionlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * Filter, which adminactionlogs to fetch.
     */
    where?: adminactionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of adminactionlogs to fetch.
     */
    orderBy?: adminactionlogOrderByWithRelationInput | adminactionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing adminactionlogs.
     */
    cursor?: adminactionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` adminactionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` adminactionlogs.
     */
    skip?: number
    distinct?: AdminactionlogScalarFieldEnum | AdminactionlogScalarFieldEnum[]
  }

  /**
   * adminactionlog create
   */
  export type adminactionlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * The data needed to create a adminactionlog.
     */
    data: XOR<adminactionlogCreateInput, adminactionlogUncheckedCreateInput>
  }

  /**
   * adminactionlog createMany
   */
  export type adminactionlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many adminactionlogs.
     */
    data: adminactionlogCreateManyInput | adminactionlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * adminactionlog update
   */
  export type adminactionlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * The data needed to update a adminactionlog.
     */
    data: XOR<adminactionlogUpdateInput, adminactionlogUncheckedUpdateInput>
    /**
     * Choose, which adminactionlog to update.
     */
    where: adminactionlogWhereUniqueInput
  }

  /**
   * adminactionlog updateMany
   */
  export type adminactionlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update adminactionlogs.
     */
    data: XOR<adminactionlogUpdateManyMutationInput, adminactionlogUncheckedUpdateManyInput>
    /**
     * Filter which adminactionlogs to update
     */
    where?: adminactionlogWhereInput
  }

  /**
   * adminactionlog upsert
   */
  export type adminactionlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * The filter to search for the adminactionlog to update in case it exists.
     */
    where: adminactionlogWhereUniqueInput
    /**
     * In case the adminactionlog found by the `where` argument doesn't exist, create a new adminactionlog with this data.
     */
    create: XOR<adminactionlogCreateInput, adminactionlogUncheckedCreateInput>
    /**
     * In case the adminactionlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminactionlogUpdateInput, adminactionlogUncheckedUpdateInput>
  }

  /**
   * adminactionlog delete
   */
  export type adminactionlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    /**
     * Filter which adminactionlog to delete.
     */
    where: adminactionlogWhereUniqueInput
  }

  /**
   * adminactionlog deleteMany
   */
  export type adminactionlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which adminactionlogs to delete
     */
    where?: adminactionlogWhereInput
  }

  /**
   * adminactionlog without action
   */
  export type adminactionlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
  }


  /**
   * Model advertisement
   */

  export type AggregateAdvertisement = {
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  export type AdvertisementAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type AdvertisementSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type AdvertisementMinAggregateOutputType = {
    id: string | null
    name: string | null
    adType: $Enums.advertisement_adType | null
    imageUrl: string | null
    videoUrl: string | null
    linkUrl: string | null
    altText: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    displayOrder: number | null
    adSizeKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type AdvertisementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    adType: $Enums.advertisement_adType | null
    imageUrl: string | null
    videoUrl: string | null
    linkUrl: string | null
    altText: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    displayOrder: number | null
    adSizeKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type AdvertisementCountAggregateOutputType = {
    id: number
    name: number
    adType: number
    imageUrl: number
    videoUrl: number
    linkUrl: number
    altText: number
    placements: number
    startDate: number
    endDate: number
    isActive: number
    displayOrder: number
    adSizeKey: number
    createdAt: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    _all: number
  }


  export type AdvertisementAvgAggregateInputType = {
    displayOrder?: true
  }

  export type AdvertisementSumAggregateInputType = {
    displayOrder?: true
  }

  export type AdvertisementMinAggregateInputType = {
    id?: true
    name?: true
    adType?: true
    imageUrl?: true
    videoUrl?: true
    linkUrl?: true
    altText?: true
    startDate?: true
    endDate?: true
    isActive?: true
    displayOrder?: true
    adSizeKey?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type AdvertisementMaxAggregateInputType = {
    id?: true
    name?: true
    adType?: true
    imageUrl?: true
    videoUrl?: true
    linkUrl?: true
    altText?: true
    startDate?: true
    endDate?: true
    isActive?: true
    displayOrder?: true
    adSizeKey?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type AdvertisementCountAggregateInputType = {
    id?: true
    name?: true
    adType?: true
    imageUrl?: true
    videoUrl?: true
    linkUrl?: true
    altText?: true
    placements?: true
    startDate?: true
    endDate?: true
    isActive?: true
    displayOrder?: true
    adSizeKey?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    _all?: true
  }

  export type AdvertisementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which advertisement to aggregate.
     */
    where?: advertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advertisements to fetch.
     */
    orderBy?: advertisementOrderByWithRelationInput | advertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: advertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned advertisements
    **/
    _count?: true | AdvertisementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisementMaxAggregateInputType
  }

  export type GetAdvertisementAggregateType<T extends AdvertisementAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisement[P]>
      : GetScalarType<T[P], AggregateAdvertisement[P]>
  }




  export type advertisementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: advertisementWhereInput
    orderBy?: advertisementOrderByWithAggregationInput | advertisementOrderByWithAggregationInput[]
    by: AdvertisementScalarFieldEnum[] | AdvertisementScalarFieldEnum
    having?: advertisementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisementCountAggregateInputType | true
    _avg?: AdvertisementAvgAggregateInputType
    _sum?: AdvertisementSumAggregateInputType
    _min?: AdvertisementMinAggregateInputType
    _max?: AdvertisementMaxAggregateInputType
  }

  export type AdvertisementGroupByOutputType = {
    id: string
    name: string
    adType: $Enums.advertisement_adType
    imageUrl: string | null
    videoUrl: string | null
    linkUrl: string | null
    altText: string | null
    placements: JsonValue
    startDate: Date | null
    endDate: Date | null
    isActive: boolean
    displayOrder: number | null
    adSizeKey: string | null
    createdAt: Date
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  type GetAdvertisementGroupByPayload<T extends advertisementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
        }
      >
    >


  export type advertisementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    adType?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    linkUrl?: boolean
    altText?: boolean
    placements?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    displayOrder?: boolean
    adSizeKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }, ExtArgs["result"]["advertisement"]>


  export type advertisementSelectScalar = {
    id?: boolean
    name?: boolean
    adType?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    linkUrl?: boolean
    altText?: boolean
    placements?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    displayOrder?: boolean
    adSizeKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }


  export type $advertisementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "advertisement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      adType: $Enums.advertisement_adType
      imageUrl: string | null
      videoUrl: string | null
      linkUrl: string | null
      altText: string | null
      placements: Prisma.JsonValue
      startDate: Date | null
      endDate: Date | null
      isActive: boolean
      displayOrder: number | null
      adSizeKey: string | null
      createdAt: Date
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
    }, ExtArgs["result"]["advertisement"]>
    composites: {}
  }

  type advertisementGetPayload<S extends boolean | null | undefined | advertisementDefaultArgs> = $Result.GetResult<Prisma.$advertisementPayload, S>

  type advertisementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<advertisementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvertisementCountAggregateInputType | true
    }

  export interface advertisementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['advertisement'], meta: { name: 'advertisement' } }
    /**
     * Find zero or one Advertisement that matches the filter.
     * @param {advertisementFindUniqueArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends advertisementFindUniqueArgs>(args: SelectSubset<T, advertisementFindUniqueArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Advertisement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {advertisementFindUniqueOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends advertisementFindUniqueOrThrowArgs>(args: SelectSubset<T, advertisementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advertisementFindFirstArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends advertisementFindFirstArgs>(args?: SelectSubset<T, advertisementFindFirstArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advertisementFindFirstOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends advertisementFindFirstOrThrowArgs>(args?: SelectSubset<T, advertisementFindFirstOrThrowArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advertisementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advertisements
     * const advertisements = await prisma.advertisement.findMany()
     * 
     * // Get first 10 Advertisements
     * const advertisements = await prisma.advertisement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advertisementWithIdOnly = await prisma.advertisement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends advertisementFindManyArgs>(args?: SelectSubset<T, advertisementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Advertisement.
     * @param {advertisementCreateArgs} args - Arguments to create a Advertisement.
     * @example
     * // Create one Advertisement
     * const Advertisement = await prisma.advertisement.create({
     *   data: {
     *     // ... data to create a Advertisement
     *   }
     * })
     * 
     */
    create<T extends advertisementCreateArgs>(args: SelectSubset<T, advertisementCreateArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Advertisements.
     * @param {advertisementCreateManyArgs} args - Arguments to create many Advertisements.
     * @example
     * // Create many Advertisements
     * const advertisement = await prisma.advertisement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends advertisementCreateManyArgs>(args?: SelectSubset<T, advertisementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Advertisement.
     * @param {advertisementDeleteArgs} args - Arguments to delete one Advertisement.
     * @example
     * // Delete one Advertisement
     * const Advertisement = await prisma.advertisement.delete({
     *   where: {
     *     // ... filter to delete one Advertisement
     *   }
     * })
     * 
     */
    delete<T extends advertisementDeleteArgs>(args: SelectSubset<T, advertisementDeleteArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Advertisement.
     * @param {advertisementUpdateArgs} args - Arguments to update one Advertisement.
     * @example
     * // Update one Advertisement
     * const advertisement = await prisma.advertisement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends advertisementUpdateArgs>(args: SelectSubset<T, advertisementUpdateArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Advertisements.
     * @param {advertisementDeleteManyArgs} args - Arguments to filter Advertisements to delete.
     * @example
     * // Delete a few Advertisements
     * const { count } = await prisma.advertisement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends advertisementDeleteManyArgs>(args?: SelectSubset<T, advertisementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advertisementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advertisements
     * const advertisement = await prisma.advertisement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends advertisementUpdateManyArgs>(args: SelectSubset<T, advertisementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advertisement.
     * @param {advertisementUpsertArgs} args - Arguments to update or create a Advertisement.
     * @example
     * // Update or create a Advertisement
     * const advertisement = await prisma.advertisement.upsert({
     *   create: {
     *     // ... data to create a Advertisement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advertisement we want to update
     *   }
     * })
     */
    upsert<T extends advertisementUpsertArgs>(args: SelectSubset<T, advertisementUpsertArgs<ExtArgs>>): Prisma__advertisementClient<$Result.GetResult<Prisma.$advertisementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advertisementCountArgs} args - Arguments to filter Advertisements to count.
     * @example
     * // Count the number of Advertisements
     * const count = await prisma.advertisement.count({
     *   where: {
     *     // ... the filter for the Advertisements we want to count
     *   }
     * })
    **/
    count<T extends advertisementCountArgs>(
      args?: Subset<T, advertisementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisementAggregateArgs>(args: Subset<T, AdvertisementAggregateArgs>): Prisma.PrismaPromise<GetAdvertisementAggregateType<T>>

    /**
     * Group by Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advertisementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends advertisementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: advertisementGroupByArgs['orderBy'] }
        : { orderBy?: advertisementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, advertisementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the advertisement model
   */
  readonly fields: advertisementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for advertisement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__advertisementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the advertisement model
   */ 
  interface advertisementFieldRefs {
    readonly id: FieldRef<"advertisement", 'String'>
    readonly name: FieldRef<"advertisement", 'String'>
    readonly adType: FieldRef<"advertisement", 'advertisement_adType'>
    readonly imageUrl: FieldRef<"advertisement", 'String'>
    readonly videoUrl: FieldRef<"advertisement", 'String'>
    readonly linkUrl: FieldRef<"advertisement", 'String'>
    readonly altText: FieldRef<"advertisement", 'String'>
    readonly placements: FieldRef<"advertisement", 'Json'>
    readonly startDate: FieldRef<"advertisement", 'DateTime'>
    readonly endDate: FieldRef<"advertisement", 'DateTime'>
    readonly isActive: FieldRef<"advertisement", 'Boolean'>
    readonly displayOrder: FieldRef<"advertisement", 'Int'>
    readonly adSizeKey: FieldRef<"advertisement", 'String'>
    readonly createdAt: FieldRef<"advertisement", 'DateTime'>
    readonly updatedAt: FieldRef<"advertisement", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"advertisement", 'String'>
    readonly postedByOwnerName: FieldRef<"advertisement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * advertisement findUnique
   */
  export type advertisementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * Filter, which advertisement to fetch.
     */
    where: advertisementWhereUniqueInput
  }

  /**
   * advertisement findUniqueOrThrow
   */
  export type advertisementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * Filter, which advertisement to fetch.
     */
    where: advertisementWhereUniqueInput
  }

  /**
   * advertisement findFirst
   */
  export type advertisementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * Filter, which advertisement to fetch.
     */
    where?: advertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advertisements to fetch.
     */
    orderBy?: advertisementOrderByWithRelationInput | advertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for advertisements.
     */
    cursor?: advertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * advertisement findFirstOrThrow
   */
  export type advertisementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * Filter, which advertisement to fetch.
     */
    where?: advertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advertisements to fetch.
     */
    orderBy?: advertisementOrderByWithRelationInput | advertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for advertisements.
     */
    cursor?: advertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * advertisement findMany
   */
  export type advertisementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * Filter, which advertisements to fetch.
     */
    where?: advertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advertisements to fetch.
     */
    orderBy?: advertisementOrderByWithRelationInput | advertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing advertisements.
     */
    cursor?: advertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advertisements.
     */
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * advertisement create
   */
  export type advertisementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * The data needed to create a advertisement.
     */
    data: XOR<advertisementCreateInput, advertisementUncheckedCreateInput>
  }

  /**
   * advertisement createMany
   */
  export type advertisementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many advertisements.
     */
    data: advertisementCreateManyInput | advertisementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * advertisement update
   */
  export type advertisementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * The data needed to update a advertisement.
     */
    data: XOR<advertisementUpdateInput, advertisementUncheckedUpdateInput>
    /**
     * Choose, which advertisement to update.
     */
    where: advertisementWhereUniqueInput
  }

  /**
   * advertisement updateMany
   */
  export type advertisementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update advertisements.
     */
    data: XOR<advertisementUpdateManyMutationInput, advertisementUncheckedUpdateManyInput>
    /**
     * Filter which advertisements to update
     */
    where?: advertisementWhereInput
  }

  /**
   * advertisement upsert
   */
  export type advertisementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * The filter to search for the advertisement to update in case it exists.
     */
    where: advertisementWhereUniqueInput
    /**
     * In case the advertisement found by the `where` argument doesn't exist, create a new advertisement with this data.
     */
    create: XOR<advertisementCreateInput, advertisementUncheckedCreateInput>
    /**
     * In case the advertisement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<advertisementUpdateInput, advertisementUncheckedUpdateInput>
  }

  /**
   * advertisement delete
   */
  export type advertisementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
    /**
     * Filter which advertisement to delete.
     */
    where: advertisementWhereUniqueInput
  }

  /**
   * advertisement deleteMany
   */
  export type advertisementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which advertisements to delete
     */
    where?: advertisementWhereInput
  }

  /**
   * advertisement without action
   */
  export type advertisementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advertisement
     */
    select?: advertisementSelect<ExtArgs> | null
  }


  /**
   * Model blogpost
   */

  export type AggregateBlogpost = {
    _count: BlogpostCountAggregateOutputType | null
    _avg: BlogpostAvgAggregateOutputType | null
    _sum: BlogpostSumAggregateOutputType | null
    _min: BlogpostMinAggregateOutputType | null
    _max: BlogpostMaxAggregateOutputType | null
  }

  export type BlogpostAvgAggregateOutputType = {
    likes: number | null
  }

  export type BlogpostSumAggregateOutputType = {
    likes: number | null
  }

  export type BlogpostMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.blogpost_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    likes: number | null
    audioUrl: string | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
    videoUrl: string | null
  }

  export type BlogpostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.blogpost_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    likes: number | null
    audioUrl: string | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
    videoUrl: string | null
  }

  export type BlogpostCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    linkPath: number
    category: number
    date: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    likes: number
    audioUrl: number
    mediaUrls: number
    location: number
    taggedFriends: number
    feelingActivity: number
    backgroundTheme: number
    videoUrl: number
    _all: number
  }


  export type BlogpostAvgAggregateInputType = {
    likes?: true
  }

  export type BlogpostSumAggregateInputType = {
    likes?: true
  }

  export type BlogpostMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    likes?: true
    audioUrl?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
    videoUrl?: true
  }

  export type BlogpostMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    likes?: true
    audioUrl?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
    videoUrl?: true
  }

  export type BlogpostCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    likes?: true
    audioUrl?: true
    mediaUrls?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
    videoUrl?: true
    _all?: true
  }

  export type BlogpostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogpost to aggregate.
     */
    where?: blogpostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogposts to fetch.
     */
    orderBy?: blogpostOrderByWithRelationInput | blogpostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blogpostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogposts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blogposts
    **/
    _count?: true | BlogpostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogpostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogpostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogpostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogpostMaxAggregateInputType
  }

  export type GetBlogpostAggregateType<T extends BlogpostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogpost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogpost[P]>
      : GetScalarType<T[P], AggregateBlogpost[P]>
  }




  export type blogpostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogpostWhereInput
    orderBy?: blogpostOrderByWithAggregationInput | blogpostOrderByWithAggregationInput[]
    by: BlogpostScalarFieldEnum[] | BlogpostScalarFieldEnum
    having?: blogpostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogpostCountAggregateInputType | true
    _avg?: BlogpostAvgAggregateInputType
    _sum?: BlogpostSumAggregateInputType
    _min?: BlogpostMinAggregateInputType
    _max?: BlogpostMaxAggregateInputType
  }

  export type BlogpostGroupByOutputType = {
    id: string
    title: string
    description: string
    imageUrl: string | null
    linkPath: string
    category: $Enums.blogpost_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    likes: number
    audioUrl: string | null
    mediaUrls: JsonValue | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
    videoUrl: string | null
    _count: BlogpostCountAggregateOutputType | null
    _avg: BlogpostAvgAggregateOutputType | null
    _sum: BlogpostSumAggregateOutputType | null
    _min: BlogpostMinAggregateOutputType | null
    _max: BlogpostMaxAggregateOutputType | null
  }

  type GetBlogpostGroupByPayload<T extends blogpostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogpostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogpostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogpostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogpostGroupByOutputType[P]>
        }
      >
    >


  export type blogpostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    likes?: boolean
    audioUrl?: boolean
    mediaUrls?: boolean
    location?: boolean
    taggedFriends?: boolean
    feelingActivity?: boolean
    backgroundTheme?: boolean
    videoUrl?: boolean
    comment?: boolean | blogpost$commentArgs<ExtArgs>
    _count?: boolean | BlogpostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogpost"]>


  export type blogpostSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    likes?: boolean
    audioUrl?: boolean
    mediaUrls?: boolean
    location?: boolean
    taggedFriends?: boolean
    feelingActivity?: boolean
    backgroundTheme?: boolean
    videoUrl?: boolean
  }

  export type blogpostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | blogpost$commentArgs<ExtArgs>
    _count?: boolean | BlogpostCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $blogpostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blogpost"
    objects: {
      comment: Prisma.$commentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      imageUrl: string | null
      linkPath: string
      category: $Enums.blogpost_category | null
      date: Date | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      likes: number
      audioUrl: string | null
      mediaUrls: Prisma.JsonValue | null
      location: string | null
      taggedFriends: string | null
      feelingActivity: string | null
      backgroundTheme: string | null
      videoUrl: string | null
    }, ExtArgs["result"]["blogpost"]>
    composites: {}
  }

  type blogpostGetPayload<S extends boolean | null | undefined | blogpostDefaultArgs> = $Result.GetResult<Prisma.$blogpostPayload, S>

  type blogpostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<blogpostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogpostCountAggregateInputType | true
    }

  export interface blogpostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blogpost'], meta: { name: 'blogpost' } }
    /**
     * Find zero or one Blogpost that matches the filter.
     * @param {blogpostFindUniqueArgs} args - Arguments to find a Blogpost
     * @example
     * // Get one Blogpost
     * const blogpost = await prisma.blogpost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blogpostFindUniqueArgs>(args: SelectSubset<T, blogpostFindUniqueArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Blogpost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {blogpostFindUniqueOrThrowArgs} args - Arguments to find a Blogpost
     * @example
     * // Get one Blogpost
     * const blogpost = await prisma.blogpost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blogpostFindUniqueOrThrowArgs>(args: SelectSubset<T, blogpostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Blogpost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogpostFindFirstArgs} args - Arguments to find a Blogpost
     * @example
     * // Get one Blogpost
     * const blogpost = await prisma.blogpost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blogpostFindFirstArgs>(args?: SelectSubset<T, blogpostFindFirstArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Blogpost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogpostFindFirstOrThrowArgs} args - Arguments to find a Blogpost
     * @example
     * // Get one Blogpost
     * const blogpost = await prisma.blogpost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blogpostFindFirstOrThrowArgs>(args?: SelectSubset<T, blogpostFindFirstOrThrowArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blogposts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogpostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogposts
     * const blogposts = await prisma.blogpost.findMany()
     * 
     * // Get first 10 Blogposts
     * const blogposts = await prisma.blogpost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogpostWithIdOnly = await prisma.blogpost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blogpostFindManyArgs>(args?: SelectSubset<T, blogpostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Blogpost.
     * @param {blogpostCreateArgs} args - Arguments to create a Blogpost.
     * @example
     * // Create one Blogpost
     * const Blogpost = await prisma.blogpost.create({
     *   data: {
     *     // ... data to create a Blogpost
     *   }
     * })
     * 
     */
    create<T extends blogpostCreateArgs>(args: SelectSubset<T, blogpostCreateArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blogposts.
     * @param {blogpostCreateManyArgs} args - Arguments to create many Blogposts.
     * @example
     * // Create many Blogposts
     * const blogpost = await prisma.blogpost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blogpostCreateManyArgs>(args?: SelectSubset<T, blogpostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blogpost.
     * @param {blogpostDeleteArgs} args - Arguments to delete one Blogpost.
     * @example
     * // Delete one Blogpost
     * const Blogpost = await prisma.blogpost.delete({
     *   where: {
     *     // ... filter to delete one Blogpost
     *   }
     * })
     * 
     */
    delete<T extends blogpostDeleteArgs>(args: SelectSubset<T, blogpostDeleteArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Blogpost.
     * @param {blogpostUpdateArgs} args - Arguments to update one Blogpost.
     * @example
     * // Update one Blogpost
     * const blogpost = await prisma.blogpost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blogpostUpdateArgs>(args: SelectSubset<T, blogpostUpdateArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blogposts.
     * @param {blogpostDeleteManyArgs} args - Arguments to filter Blogposts to delete.
     * @example
     * // Delete a few Blogposts
     * const { count } = await prisma.blogpost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blogpostDeleteManyArgs>(args?: SelectSubset<T, blogpostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogpostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogposts
     * const blogpost = await prisma.blogpost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blogpostUpdateManyArgs>(args: SelectSubset<T, blogpostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blogpost.
     * @param {blogpostUpsertArgs} args - Arguments to update or create a Blogpost.
     * @example
     * // Update or create a Blogpost
     * const blogpost = await prisma.blogpost.upsert({
     *   create: {
     *     // ... data to create a Blogpost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blogpost we want to update
     *   }
     * })
     */
    upsert<T extends blogpostUpsertArgs>(args: SelectSubset<T, blogpostUpsertArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blogposts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogpostCountArgs} args - Arguments to filter Blogposts to count.
     * @example
     * // Count the number of Blogposts
     * const count = await prisma.blogpost.count({
     *   where: {
     *     // ... the filter for the Blogposts we want to count
     *   }
     * })
    **/
    count<T extends blogpostCountArgs>(
      args?: Subset<T, blogpostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogpostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blogpost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogpostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogpostAggregateArgs>(args: Subset<T, BlogpostAggregateArgs>): Prisma.PrismaPromise<GetBlogpostAggregateType<T>>

    /**
     * Group by Blogpost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogpostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blogpostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blogpostGroupByArgs['orderBy'] }
        : { orderBy?: blogpostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blogpostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogpostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blogpost model
   */
  readonly fields: blogpostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blogpost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blogpostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends blogpost$commentArgs<ExtArgs> = {}>(args?: Subset<T, blogpost$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blogpost model
   */ 
  interface blogpostFieldRefs {
    readonly id: FieldRef<"blogpost", 'String'>
    readonly title: FieldRef<"blogpost", 'String'>
    readonly description: FieldRef<"blogpost", 'String'>
    readonly imageUrl: FieldRef<"blogpost", 'String'>
    readonly linkPath: FieldRef<"blogpost", 'String'>
    readonly category: FieldRef<"blogpost", 'blogpost_category'>
    readonly date: FieldRef<"blogpost", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"blogpost", 'String'>
    readonly postedByOwnerName: FieldRef<"blogpost", 'String'>
    readonly createdAt: FieldRef<"blogpost", 'DateTime'>
    readonly updatedAt: FieldRef<"blogpost", 'DateTime'>
    readonly likes: FieldRef<"blogpost", 'Int'>
    readonly audioUrl: FieldRef<"blogpost", 'String'>
    readonly mediaUrls: FieldRef<"blogpost", 'Json'>
    readonly location: FieldRef<"blogpost", 'String'>
    readonly taggedFriends: FieldRef<"blogpost", 'String'>
    readonly feelingActivity: FieldRef<"blogpost", 'String'>
    readonly backgroundTheme: FieldRef<"blogpost", 'String'>
    readonly videoUrl: FieldRef<"blogpost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blogpost findUnique
   */
  export type blogpostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * Filter, which blogpost to fetch.
     */
    where: blogpostWhereUniqueInput
  }

  /**
   * blogpost findUniqueOrThrow
   */
  export type blogpostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * Filter, which blogpost to fetch.
     */
    where: blogpostWhereUniqueInput
  }

  /**
   * blogpost findFirst
   */
  export type blogpostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * Filter, which blogpost to fetch.
     */
    where?: blogpostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogposts to fetch.
     */
    orderBy?: blogpostOrderByWithRelationInput | blogpostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogposts.
     */
    cursor?: blogpostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogposts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogposts.
     */
    distinct?: BlogpostScalarFieldEnum | BlogpostScalarFieldEnum[]
  }

  /**
   * blogpost findFirstOrThrow
   */
  export type blogpostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * Filter, which blogpost to fetch.
     */
    where?: blogpostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogposts to fetch.
     */
    orderBy?: blogpostOrderByWithRelationInput | blogpostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogposts.
     */
    cursor?: blogpostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogposts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogposts.
     */
    distinct?: BlogpostScalarFieldEnum | BlogpostScalarFieldEnum[]
  }

  /**
   * blogpost findMany
   */
  export type blogpostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * Filter, which blogposts to fetch.
     */
    where?: blogpostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogposts to fetch.
     */
    orderBy?: blogpostOrderByWithRelationInput | blogpostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blogposts.
     */
    cursor?: blogpostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogposts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogposts.
     */
    skip?: number
    distinct?: BlogpostScalarFieldEnum | BlogpostScalarFieldEnum[]
  }

  /**
   * blogpost create
   */
  export type blogpostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * The data needed to create a blogpost.
     */
    data: XOR<blogpostCreateInput, blogpostUncheckedCreateInput>
  }

  /**
   * blogpost createMany
   */
  export type blogpostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blogposts.
     */
    data: blogpostCreateManyInput | blogpostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blogpost update
   */
  export type blogpostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * The data needed to update a blogpost.
     */
    data: XOR<blogpostUpdateInput, blogpostUncheckedUpdateInput>
    /**
     * Choose, which blogpost to update.
     */
    where: blogpostWhereUniqueInput
  }

  /**
   * blogpost updateMany
   */
  export type blogpostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blogposts.
     */
    data: XOR<blogpostUpdateManyMutationInput, blogpostUncheckedUpdateManyInput>
    /**
     * Filter which blogposts to update
     */
    where?: blogpostWhereInput
  }

  /**
   * blogpost upsert
   */
  export type blogpostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * The filter to search for the blogpost to update in case it exists.
     */
    where: blogpostWhereUniqueInput
    /**
     * In case the blogpost found by the `where` argument doesn't exist, create a new blogpost with this data.
     */
    create: XOR<blogpostCreateInput, blogpostUncheckedCreateInput>
    /**
     * In case the blogpost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blogpostUpdateInput, blogpostUncheckedUpdateInput>
  }

  /**
   * blogpost delete
   */
  export type blogpostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    /**
     * Filter which blogpost to delete.
     */
    where: blogpostWhereUniqueInput
  }

  /**
   * blogpost deleteMany
   */
  export type blogpostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogposts to delete
     */
    where?: blogpostWhereInput
  }

  /**
   * blogpost.comment
   */
  export type blogpost$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * blogpost without action
   */
  export type blogpostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
  }


  /**
   * Model branchchurch
   */

  export type AggregateBranchchurch = {
    _count: BranchchurchCountAggregateOutputType | null
    _min: BranchchurchMinAggregateOutputType | null
    _max: BranchchurchMaxAggregateOutputType | null
  }

  export type BranchchurchMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    pastorName: string | null
    phone: string | null
    email: string | null
    serviceTimes: string | null
    mapEmbedUrl: string | null
    imageUrl: string | null
    description: string | null
    establishedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type BranchchurchMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    pastorName: string | null
    phone: string | null
    email: string | null
    serviceTimes: string | null
    mapEmbedUrl: string | null
    imageUrl: string | null
    description: string | null
    establishedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type BranchchurchCountAggregateOutputType = {
    id: number
    name: number
    address: number
    pastorName: number
    phone: number
    email: number
    serviceTimes: number
    mapEmbedUrl: number
    imageUrl: number
    description: number
    establishedDate: number
    createdAt: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    _all: number
  }


  export type BranchchurchMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pastorName?: true
    phone?: true
    email?: true
    serviceTimes?: true
    mapEmbedUrl?: true
    imageUrl?: true
    description?: true
    establishedDate?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type BranchchurchMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pastorName?: true
    phone?: true
    email?: true
    serviceTimes?: true
    mapEmbedUrl?: true
    imageUrl?: true
    description?: true
    establishedDate?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type BranchchurchCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    pastorName?: true
    phone?: true
    email?: true
    serviceTimes?: true
    mapEmbedUrl?: true
    imageUrl?: true
    description?: true
    establishedDate?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    _all?: true
  }

  export type BranchchurchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branchchurch to aggregate.
     */
    where?: branchchurchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchchurches to fetch.
     */
    orderBy?: branchchurchOrderByWithRelationInput | branchchurchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: branchchurchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchchurches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchchurches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned branchchurches
    **/
    _count?: true | BranchchurchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchchurchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchchurchMaxAggregateInputType
  }

  export type GetBranchchurchAggregateType<T extends BranchchurchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranchchurch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranchchurch[P]>
      : GetScalarType<T[P], AggregateBranchchurch[P]>
  }




  export type branchchurchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchchurchWhereInput
    orderBy?: branchchurchOrderByWithAggregationInput | branchchurchOrderByWithAggregationInput[]
    by: BranchchurchScalarFieldEnum[] | BranchchurchScalarFieldEnum
    having?: branchchurchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchchurchCountAggregateInputType | true
    _min?: BranchchurchMinAggregateInputType
    _max?: BranchchurchMaxAggregateInputType
  }

  export type BranchchurchGroupByOutputType = {
    id: string
    name: string
    address: string
    pastorName: string | null
    phone: string | null
    email: string | null
    serviceTimes: string
    mapEmbedUrl: string | null
    imageUrl: string | null
    description: string | null
    establishedDate: Date | null
    createdAt: Date
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    _count: BranchchurchCountAggregateOutputType | null
    _min: BranchchurchMinAggregateOutputType | null
    _max: BranchchurchMaxAggregateOutputType | null
  }

  type GetBranchchurchGroupByPayload<T extends branchchurchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchchurchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchchurchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchchurchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchchurchGroupByOutputType[P]>
        }
      >
    >


  export type branchchurchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    pastorName?: boolean
    phone?: boolean
    email?: boolean
    serviceTimes?: boolean
    mapEmbedUrl?: boolean
    imageUrl?: boolean
    description?: boolean
    establishedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }, ExtArgs["result"]["branchchurch"]>


  export type branchchurchSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    pastorName?: boolean
    phone?: boolean
    email?: boolean
    serviceTimes?: boolean
    mapEmbedUrl?: boolean
    imageUrl?: boolean
    description?: boolean
    establishedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }


  export type $branchchurchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "branchchurch"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      pastorName: string | null
      phone: string | null
      email: string | null
      serviceTimes: string
      mapEmbedUrl: string | null
      imageUrl: string | null
      description: string | null
      establishedDate: Date | null
      createdAt: Date
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
    }, ExtArgs["result"]["branchchurch"]>
    composites: {}
  }

  type branchchurchGetPayload<S extends boolean | null | undefined | branchchurchDefaultArgs> = $Result.GetResult<Prisma.$branchchurchPayload, S>

  type branchchurchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<branchchurchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BranchchurchCountAggregateInputType | true
    }

  export interface branchchurchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['branchchurch'], meta: { name: 'branchchurch' } }
    /**
     * Find zero or one Branchchurch that matches the filter.
     * @param {branchchurchFindUniqueArgs} args - Arguments to find a Branchchurch
     * @example
     * // Get one Branchchurch
     * const branchchurch = await prisma.branchchurch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends branchchurchFindUniqueArgs>(args: SelectSubset<T, branchchurchFindUniqueArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Branchchurch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {branchchurchFindUniqueOrThrowArgs} args - Arguments to find a Branchchurch
     * @example
     * // Get one Branchchurch
     * const branchchurch = await prisma.branchchurch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends branchchurchFindUniqueOrThrowArgs>(args: SelectSubset<T, branchchurchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Branchchurch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchchurchFindFirstArgs} args - Arguments to find a Branchchurch
     * @example
     * // Get one Branchchurch
     * const branchchurch = await prisma.branchchurch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends branchchurchFindFirstArgs>(args?: SelectSubset<T, branchchurchFindFirstArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Branchchurch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchchurchFindFirstOrThrowArgs} args - Arguments to find a Branchchurch
     * @example
     * // Get one Branchchurch
     * const branchchurch = await prisma.branchchurch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends branchchurchFindFirstOrThrowArgs>(args?: SelectSubset<T, branchchurchFindFirstOrThrowArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Branchchurches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchchurchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branchchurches
     * const branchchurches = await prisma.branchchurch.findMany()
     * 
     * // Get first 10 Branchchurches
     * const branchchurches = await prisma.branchchurch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchchurchWithIdOnly = await prisma.branchchurch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends branchchurchFindManyArgs>(args?: SelectSubset<T, branchchurchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Branchchurch.
     * @param {branchchurchCreateArgs} args - Arguments to create a Branchchurch.
     * @example
     * // Create one Branchchurch
     * const Branchchurch = await prisma.branchchurch.create({
     *   data: {
     *     // ... data to create a Branchchurch
     *   }
     * })
     * 
     */
    create<T extends branchchurchCreateArgs>(args: SelectSubset<T, branchchurchCreateArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Branchchurches.
     * @param {branchchurchCreateManyArgs} args - Arguments to create many Branchchurches.
     * @example
     * // Create many Branchchurches
     * const branchchurch = await prisma.branchchurch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends branchchurchCreateManyArgs>(args?: SelectSubset<T, branchchurchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branchchurch.
     * @param {branchchurchDeleteArgs} args - Arguments to delete one Branchchurch.
     * @example
     * // Delete one Branchchurch
     * const Branchchurch = await prisma.branchchurch.delete({
     *   where: {
     *     // ... filter to delete one Branchchurch
     *   }
     * })
     * 
     */
    delete<T extends branchchurchDeleteArgs>(args: SelectSubset<T, branchchurchDeleteArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Branchchurch.
     * @param {branchchurchUpdateArgs} args - Arguments to update one Branchchurch.
     * @example
     * // Update one Branchchurch
     * const branchchurch = await prisma.branchchurch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends branchchurchUpdateArgs>(args: SelectSubset<T, branchchurchUpdateArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Branchchurches.
     * @param {branchchurchDeleteManyArgs} args - Arguments to filter Branchchurches to delete.
     * @example
     * // Delete a few Branchchurches
     * const { count } = await prisma.branchchurch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends branchchurchDeleteManyArgs>(args?: SelectSubset<T, branchchurchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branchchurches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchchurchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branchchurches
     * const branchchurch = await prisma.branchchurch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends branchchurchUpdateManyArgs>(args: SelectSubset<T, branchchurchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branchchurch.
     * @param {branchchurchUpsertArgs} args - Arguments to update or create a Branchchurch.
     * @example
     * // Update or create a Branchchurch
     * const branchchurch = await prisma.branchchurch.upsert({
     *   create: {
     *     // ... data to create a Branchchurch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branchchurch we want to update
     *   }
     * })
     */
    upsert<T extends branchchurchUpsertArgs>(args: SelectSubset<T, branchchurchUpsertArgs<ExtArgs>>): Prisma__branchchurchClient<$Result.GetResult<Prisma.$branchchurchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Branchchurches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchchurchCountArgs} args - Arguments to filter Branchchurches to count.
     * @example
     * // Count the number of Branchchurches
     * const count = await prisma.branchchurch.count({
     *   where: {
     *     // ... the filter for the Branchchurches we want to count
     *   }
     * })
    **/
    count<T extends branchchurchCountArgs>(
      args?: Subset<T, branchchurchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchchurchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branchchurch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchchurchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchchurchAggregateArgs>(args: Subset<T, BranchchurchAggregateArgs>): Prisma.PrismaPromise<GetBranchchurchAggregateType<T>>

    /**
     * Group by Branchchurch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchchurchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends branchchurchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: branchchurchGroupByArgs['orderBy'] }
        : { orderBy?: branchchurchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, branchchurchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchchurchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the branchchurch model
   */
  readonly fields: branchchurchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for branchchurch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__branchchurchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the branchchurch model
   */ 
  interface branchchurchFieldRefs {
    readonly id: FieldRef<"branchchurch", 'String'>
    readonly name: FieldRef<"branchchurch", 'String'>
    readonly address: FieldRef<"branchchurch", 'String'>
    readonly pastorName: FieldRef<"branchchurch", 'String'>
    readonly phone: FieldRef<"branchchurch", 'String'>
    readonly email: FieldRef<"branchchurch", 'String'>
    readonly serviceTimes: FieldRef<"branchchurch", 'String'>
    readonly mapEmbedUrl: FieldRef<"branchchurch", 'String'>
    readonly imageUrl: FieldRef<"branchchurch", 'String'>
    readonly description: FieldRef<"branchchurch", 'String'>
    readonly establishedDate: FieldRef<"branchchurch", 'DateTime'>
    readonly createdAt: FieldRef<"branchchurch", 'DateTime'>
    readonly updatedAt: FieldRef<"branchchurch", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"branchchurch", 'String'>
    readonly postedByOwnerName: FieldRef<"branchchurch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * branchchurch findUnique
   */
  export type branchchurchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * Filter, which branchchurch to fetch.
     */
    where: branchchurchWhereUniqueInput
  }

  /**
   * branchchurch findUniqueOrThrow
   */
  export type branchchurchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * Filter, which branchchurch to fetch.
     */
    where: branchchurchWhereUniqueInput
  }

  /**
   * branchchurch findFirst
   */
  export type branchchurchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * Filter, which branchchurch to fetch.
     */
    where?: branchchurchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchchurches to fetch.
     */
    orderBy?: branchchurchOrderByWithRelationInput | branchchurchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branchchurches.
     */
    cursor?: branchchurchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchchurches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchchurches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branchchurches.
     */
    distinct?: BranchchurchScalarFieldEnum | BranchchurchScalarFieldEnum[]
  }

  /**
   * branchchurch findFirstOrThrow
   */
  export type branchchurchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * Filter, which branchchurch to fetch.
     */
    where?: branchchurchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchchurches to fetch.
     */
    orderBy?: branchchurchOrderByWithRelationInput | branchchurchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branchchurches.
     */
    cursor?: branchchurchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchchurches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchchurches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branchchurches.
     */
    distinct?: BranchchurchScalarFieldEnum | BranchchurchScalarFieldEnum[]
  }

  /**
   * branchchurch findMany
   */
  export type branchchurchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * Filter, which branchchurches to fetch.
     */
    where?: branchchurchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branchchurches to fetch.
     */
    orderBy?: branchchurchOrderByWithRelationInput | branchchurchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing branchchurches.
     */
    cursor?: branchchurchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branchchurches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branchchurches.
     */
    skip?: number
    distinct?: BranchchurchScalarFieldEnum | BranchchurchScalarFieldEnum[]
  }

  /**
   * branchchurch create
   */
  export type branchchurchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * The data needed to create a branchchurch.
     */
    data: XOR<branchchurchCreateInput, branchchurchUncheckedCreateInput>
  }

  /**
   * branchchurch createMany
   */
  export type branchchurchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many branchchurches.
     */
    data: branchchurchCreateManyInput | branchchurchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branchchurch update
   */
  export type branchchurchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * The data needed to update a branchchurch.
     */
    data: XOR<branchchurchUpdateInput, branchchurchUncheckedUpdateInput>
    /**
     * Choose, which branchchurch to update.
     */
    where: branchchurchWhereUniqueInput
  }

  /**
   * branchchurch updateMany
   */
  export type branchchurchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update branchchurches.
     */
    data: XOR<branchchurchUpdateManyMutationInput, branchchurchUncheckedUpdateManyInput>
    /**
     * Filter which branchchurches to update
     */
    where?: branchchurchWhereInput
  }

  /**
   * branchchurch upsert
   */
  export type branchchurchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * The filter to search for the branchchurch to update in case it exists.
     */
    where: branchchurchWhereUniqueInput
    /**
     * In case the branchchurch found by the `where` argument doesn't exist, create a new branchchurch with this data.
     */
    create: XOR<branchchurchCreateInput, branchchurchUncheckedCreateInput>
    /**
     * In case the branchchurch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<branchchurchUpdateInput, branchchurchUncheckedUpdateInput>
  }

  /**
   * branchchurch delete
   */
  export type branchchurchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
    /**
     * Filter which branchchurch to delete.
     */
    where: branchchurchWhereUniqueInput
  }

  /**
   * branchchurch deleteMany
   */
  export type branchchurchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branchchurches to delete
     */
    where?: branchchurchWhereInput
  }

  /**
   * branchchurch without action
   */
  export type branchchurchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branchchurch
     */
    select?: branchchurchSelect<ExtArgs> | null
  }


  /**
   * Model churchmember
   */

  export type AggregateChurchmember = {
    _count: ChurchmemberCountAggregateOutputType | null
    _min: ChurchmemberMinAggregateOutputType | null
    _max: ChurchmemberMaxAggregateOutputType | null
  }

  export type ChurchmemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    username: string | null
    contactPhone: string | null
    contactEmail: string | null
    address: string | null
    memberSince: Date | null
    dateOfBirth: Date | null
    baptismDate: Date | null
    familyMembers: string | null
    notes: string | null
    isActiveMember: boolean | null
    profileImageUrl: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChurchmemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    fullName: string | null
    username: string | null
    contactPhone: string | null
    contactEmail: string | null
    address: string | null
    memberSince: Date | null
    dateOfBirth: Date | null
    baptismDate: Date | null
    familyMembers: string | null
    notes: string | null
    isActiveMember: boolean | null
    profileImageUrl: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChurchmemberCountAggregateOutputType = {
    id: number
    userId: number
    fullName: number
    username: number
    contactPhone: number
    contactEmail: number
    address: number
    memberSince: number
    dateOfBirth: number
    baptismDate: number
    familyMembers: number
    notes: number
    isActiveMember: number
    profileImageUrl: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChurchmemberMinAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    username?: true
    contactPhone?: true
    contactEmail?: true
    address?: true
    memberSince?: true
    dateOfBirth?: true
    baptismDate?: true
    familyMembers?: true
    notes?: true
    isActiveMember?: true
    profileImageUrl?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChurchmemberMaxAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    username?: true
    contactPhone?: true
    contactEmail?: true
    address?: true
    memberSince?: true
    dateOfBirth?: true
    baptismDate?: true
    familyMembers?: true
    notes?: true
    isActiveMember?: true
    profileImageUrl?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChurchmemberCountAggregateInputType = {
    id?: true
    userId?: true
    fullName?: true
    username?: true
    contactPhone?: true
    contactEmail?: true
    address?: true
    memberSince?: true
    dateOfBirth?: true
    baptismDate?: true
    familyMembers?: true
    notes?: true
    isActiveMember?: true
    profileImageUrl?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChurchmemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which churchmember to aggregate.
     */
    where?: churchmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of churchmembers to fetch.
     */
    orderBy?: churchmemberOrderByWithRelationInput | churchmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: churchmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` churchmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` churchmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned churchmembers
    **/
    _count?: true | ChurchmemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChurchmemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChurchmemberMaxAggregateInputType
  }

  export type GetChurchmemberAggregateType<T extends ChurchmemberAggregateArgs> = {
        [P in keyof T & keyof AggregateChurchmember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChurchmember[P]>
      : GetScalarType<T[P], AggregateChurchmember[P]>
  }




  export type churchmemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: churchmemberWhereInput
    orderBy?: churchmemberOrderByWithAggregationInput | churchmemberOrderByWithAggregationInput[]
    by: ChurchmemberScalarFieldEnum[] | ChurchmemberScalarFieldEnum
    having?: churchmemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChurchmemberCountAggregateInputType | true
    _min?: ChurchmemberMinAggregateInputType
    _max?: ChurchmemberMaxAggregateInputType
  }

  export type ChurchmemberGroupByOutputType = {
    id: string
    userId: string | null
    fullName: string
    username: string | null
    contactPhone: string | null
    contactEmail: string | null
    address: string | null
    memberSince: Date
    dateOfBirth: Date | null
    baptismDate: Date | null
    familyMembers: string | null
    notes: string | null
    isActiveMember: boolean
    profileImageUrl: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChurchmemberCountAggregateOutputType | null
    _min: ChurchmemberMinAggregateOutputType | null
    _max: ChurchmemberMaxAggregateOutputType | null
  }

  type GetChurchmemberGroupByPayload<T extends churchmemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChurchmemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChurchmemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChurchmemberGroupByOutputType[P]>
            : GetScalarType<T[P], ChurchmemberGroupByOutputType[P]>
        }
      >
    >


  export type churchmemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    fullName?: boolean
    username?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    address?: boolean
    memberSince?: boolean
    dateOfBirth?: boolean
    baptismDate?: boolean
    familyMembers?: boolean
    notes?: boolean
    isActiveMember?: boolean
    profileImageUrl?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | churchmember$userArgs<ExtArgs>
  }, ExtArgs["result"]["churchmember"]>


  export type churchmemberSelectScalar = {
    id?: boolean
    userId?: boolean
    fullName?: boolean
    username?: boolean
    contactPhone?: boolean
    contactEmail?: boolean
    address?: boolean
    memberSince?: boolean
    dateOfBirth?: boolean
    baptismDate?: boolean
    familyMembers?: boolean
    notes?: boolean
    isActiveMember?: boolean
    profileImageUrl?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type churchmemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | churchmember$userArgs<ExtArgs>
  }

  export type $churchmemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "churchmember"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      fullName: string
      username: string | null
      contactPhone: string | null
      contactEmail: string | null
      address: string | null
      memberSince: Date
      dateOfBirth: Date | null
      baptismDate: Date | null
      familyMembers: string | null
      notes: string | null
      isActiveMember: boolean
      profileImageUrl: string | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["churchmember"]>
    composites: {}
  }

  type churchmemberGetPayload<S extends boolean | null | undefined | churchmemberDefaultArgs> = $Result.GetResult<Prisma.$churchmemberPayload, S>

  type churchmemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<churchmemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChurchmemberCountAggregateInputType | true
    }

  export interface churchmemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['churchmember'], meta: { name: 'churchmember' } }
    /**
     * Find zero or one Churchmember that matches the filter.
     * @param {churchmemberFindUniqueArgs} args - Arguments to find a Churchmember
     * @example
     * // Get one Churchmember
     * const churchmember = await prisma.churchmember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends churchmemberFindUniqueArgs>(args: SelectSubset<T, churchmemberFindUniqueArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Churchmember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {churchmemberFindUniqueOrThrowArgs} args - Arguments to find a Churchmember
     * @example
     * // Get one Churchmember
     * const churchmember = await prisma.churchmember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends churchmemberFindUniqueOrThrowArgs>(args: SelectSubset<T, churchmemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Churchmember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {churchmemberFindFirstArgs} args - Arguments to find a Churchmember
     * @example
     * // Get one Churchmember
     * const churchmember = await prisma.churchmember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends churchmemberFindFirstArgs>(args?: SelectSubset<T, churchmemberFindFirstArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Churchmember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {churchmemberFindFirstOrThrowArgs} args - Arguments to find a Churchmember
     * @example
     * // Get one Churchmember
     * const churchmember = await prisma.churchmember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends churchmemberFindFirstOrThrowArgs>(args?: SelectSubset<T, churchmemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Churchmembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {churchmemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Churchmembers
     * const churchmembers = await prisma.churchmember.findMany()
     * 
     * // Get first 10 Churchmembers
     * const churchmembers = await prisma.churchmember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const churchmemberWithIdOnly = await prisma.churchmember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends churchmemberFindManyArgs>(args?: SelectSubset<T, churchmemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Churchmember.
     * @param {churchmemberCreateArgs} args - Arguments to create a Churchmember.
     * @example
     * // Create one Churchmember
     * const Churchmember = await prisma.churchmember.create({
     *   data: {
     *     // ... data to create a Churchmember
     *   }
     * })
     * 
     */
    create<T extends churchmemberCreateArgs>(args: SelectSubset<T, churchmemberCreateArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Churchmembers.
     * @param {churchmemberCreateManyArgs} args - Arguments to create many Churchmembers.
     * @example
     * // Create many Churchmembers
     * const churchmember = await prisma.churchmember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends churchmemberCreateManyArgs>(args?: SelectSubset<T, churchmemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Churchmember.
     * @param {churchmemberDeleteArgs} args - Arguments to delete one Churchmember.
     * @example
     * // Delete one Churchmember
     * const Churchmember = await prisma.churchmember.delete({
     *   where: {
     *     // ... filter to delete one Churchmember
     *   }
     * })
     * 
     */
    delete<T extends churchmemberDeleteArgs>(args: SelectSubset<T, churchmemberDeleteArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Churchmember.
     * @param {churchmemberUpdateArgs} args - Arguments to update one Churchmember.
     * @example
     * // Update one Churchmember
     * const churchmember = await prisma.churchmember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends churchmemberUpdateArgs>(args: SelectSubset<T, churchmemberUpdateArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Churchmembers.
     * @param {churchmemberDeleteManyArgs} args - Arguments to filter Churchmembers to delete.
     * @example
     * // Delete a few Churchmembers
     * const { count } = await prisma.churchmember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends churchmemberDeleteManyArgs>(args?: SelectSubset<T, churchmemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Churchmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {churchmemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Churchmembers
     * const churchmember = await prisma.churchmember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends churchmemberUpdateManyArgs>(args: SelectSubset<T, churchmemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Churchmember.
     * @param {churchmemberUpsertArgs} args - Arguments to update or create a Churchmember.
     * @example
     * // Update or create a Churchmember
     * const churchmember = await prisma.churchmember.upsert({
     *   create: {
     *     // ... data to create a Churchmember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Churchmember we want to update
     *   }
     * })
     */
    upsert<T extends churchmemberUpsertArgs>(args: SelectSubset<T, churchmemberUpsertArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Churchmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {churchmemberCountArgs} args - Arguments to filter Churchmembers to count.
     * @example
     * // Count the number of Churchmembers
     * const count = await prisma.churchmember.count({
     *   where: {
     *     // ... the filter for the Churchmembers we want to count
     *   }
     * })
    **/
    count<T extends churchmemberCountArgs>(
      args?: Subset<T, churchmemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChurchmemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Churchmember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChurchmemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChurchmemberAggregateArgs>(args: Subset<T, ChurchmemberAggregateArgs>): Prisma.PrismaPromise<GetChurchmemberAggregateType<T>>

    /**
     * Group by Churchmember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {churchmemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends churchmemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: churchmemberGroupByArgs['orderBy'] }
        : { orderBy?: churchmemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, churchmemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChurchmemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the churchmember model
   */
  readonly fields: churchmemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for churchmember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__churchmemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends churchmember$userArgs<ExtArgs> = {}>(args?: Subset<T, churchmember$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the churchmember model
   */ 
  interface churchmemberFieldRefs {
    readonly id: FieldRef<"churchmember", 'String'>
    readonly userId: FieldRef<"churchmember", 'String'>
    readonly fullName: FieldRef<"churchmember", 'String'>
    readonly username: FieldRef<"churchmember", 'String'>
    readonly contactPhone: FieldRef<"churchmember", 'String'>
    readonly contactEmail: FieldRef<"churchmember", 'String'>
    readonly address: FieldRef<"churchmember", 'String'>
    readonly memberSince: FieldRef<"churchmember", 'DateTime'>
    readonly dateOfBirth: FieldRef<"churchmember", 'DateTime'>
    readonly baptismDate: FieldRef<"churchmember", 'DateTime'>
    readonly familyMembers: FieldRef<"churchmember", 'String'>
    readonly notes: FieldRef<"churchmember", 'String'>
    readonly isActiveMember: FieldRef<"churchmember", 'Boolean'>
    readonly profileImageUrl: FieldRef<"churchmember", 'String'>
    readonly postedByOwnerId: FieldRef<"churchmember", 'String'>
    readonly postedByOwnerName: FieldRef<"churchmember", 'String'>
    readonly createdAt: FieldRef<"churchmember", 'DateTime'>
    readonly updatedAt: FieldRef<"churchmember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * churchmember findUnique
   */
  export type churchmemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * Filter, which churchmember to fetch.
     */
    where: churchmemberWhereUniqueInput
  }

  /**
   * churchmember findUniqueOrThrow
   */
  export type churchmemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * Filter, which churchmember to fetch.
     */
    where: churchmemberWhereUniqueInput
  }

  /**
   * churchmember findFirst
   */
  export type churchmemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * Filter, which churchmember to fetch.
     */
    where?: churchmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of churchmembers to fetch.
     */
    orderBy?: churchmemberOrderByWithRelationInput | churchmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for churchmembers.
     */
    cursor?: churchmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` churchmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` churchmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of churchmembers.
     */
    distinct?: ChurchmemberScalarFieldEnum | ChurchmemberScalarFieldEnum[]
  }

  /**
   * churchmember findFirstOrThrow
   */
  export type churchmemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * Filter, which churchmember to fetch.
     */
    where?: churchmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of churchmembers to fetch.
     */
    orderBy?: churchmemberOrderByWithRelationInput | churchmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for churchmembers.
     */
    cursor?: churchmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` churchmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` churchmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of churchmembers.
     */
    distinct?: ChurchmemberScalarFieldEnum | ChurchmemberScalarFieldEnum[]
  }

  /**
   * churchmember findMany
   */
  export type churchmemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * Filter, which churchmembers to fetch.
     */
    where?: churchmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of churchmembers to fetch.
     */
    orderBy?: churchmemberOrderByWithRelationInput | churchmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing churchmembers.
     */
    cursor?: churchmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` churchmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` churchmembers.
     */
    skip?: number
    distinct?: ChurchmemberScalarFieldEnum | ChurchmemberScalarFieldEnum[]
  }

  /**
   * churchmember create
   */
  export type churchmemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * The data needed to create a churchmember.
     */
    data: XOR<churchmemberCreateInput, churchmemberUncheckedCreateInput>
  }

  /**
   * churchmember createMany
   */
  export type churchmemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many churchmembers.
     */
    data: churchmemberCreateManyInput | churchmemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * churchmember update
   */
  export type churchmemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * The data needed to update a churchmember.
     */
    data: XOR<churchmemberUpdateInput, churchmemberUncheckedUpdateInput>
    /**
     * Choose, which churchmember to update.
     */
    where: churchmemberWhereUniqueInput
  }

  /**
   * churchmember updateMany
   */
  export type churchmemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update churchmembers.
     */
    data: XOR<churchmemberUpdateManyMutationInput, churchmemberUncheckedUpdateManyInput>
    /**
     * Filter which churchmembers to update
     */
    where?: churchmemberWhereInput
  }

  /**
   * churchmember upsert
   */
  export type churchmemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * The filter to search for the churchmember to update in case it exists.
     */
    where: churchmemberWhereUniqueInput
    /**
     * In case the churchmember found by the `where` argument doesn't exist, create a new churchmember with this data.
     */
    create: XOR<churchmemberCreateInput, churchmemberUncheckedCreateInput>
    /**
     * In case the churchmember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<churchmemberUpdateInput, churchmemberUncheckedUpdateInput>
  }

  /**
   * churchmember delete
   */
  export type churchmemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    /**
     * Filter which churchmember to delete.
     */
    where: churchmemberWhereUniqueInput
  }

  /**
   * churchmember deleteMany
   */
  export type churchmemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which churchmembers to delete
     */
    where?: churchmemberWhereInput
  }

  /**
   * churchmember.user
   */
  export type churchmember$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * churchmember without action
   */
  export type churchmemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
  }


  /**
   * Model collectionrecord
   */

  export type AggregateCollectionrecord = {
    _count: CollectionrecordCountAggregateOutputType | null
    _avg: CollectionrecordAvgAggregateOutputType | null
    _sum: CollectionrecordSumAggregateOutputType | null
    _min: CollectionrecordMinAggregateOutputType | null
    _max: CollectionrecordMaxAggregateOutputType | null
  }

  export type CollectionrecordAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CollectionrecordSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CollectionrecordMinAggregateOutputType = {
    id: string | null
    collectorName: string | null
    collectionDate: Date | null
    amount: Decimal | null
    purpose: $Enums.collectionrecord_purpose | null
    source: string | null
    notes: string | null
    recordedAt: Date | null
    recordedByOwnerId: string | null
    recordedByOwnerName: string | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    countedBy: string | null
    isDeposited: boolean | null
    depositDate: Date | null
    bankDepositReference: string | null
  }

  export type CollectionrecordMaxAggregateOutputType = {
    id: string | null
    collectorName: string | null
    collectionDate: Date | null
    amount: Decimal | null
    purpose: $Enums.collectionrecord_purpose | null
    source: string | null
    notes: string | null
    recordedAt: Date | null
    recordedByOwnerId: string | null
    recordedByOwnerName: string | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    countedBy: string | null
    isDeposited: boolean | null
    depositDate: Date | null
    bankDepositReference: string | null
  }

  export type CollectionrecordCountAggregateOutputType = {
    id: number
    collectorName: number
    collectionDate: number
    amount: number
    purpose: number
    source: number
    notes: number
    recordedAt: number
    recordedByOwnerId: number
    recordedByOwnerName: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    countedBy: number
    isDeposited: number
    depositDate: number
    bankDepositReference: number
    _all: number
  }


  export type CollectionrecordAvgAggregateInputType = {
    amount?: true
  }

  export type CollectionrecordSumAggregateInputType = {
    amount?: true
  }

  export type CollectionrecordMinAggregateInputType = {
    id?: true
    collectorName?: true
    collectionDate?: true
    amount?: true
    purpose?: true
    source?: true
    notes?: true
    recordedAt?: true
    recordedByOwnerId?: true
    recordedByOwnerName?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    countedBy?: true
    isDeposited?: true
    depositDate?: true
    bankDepositReference?: true
  }

  export type CollectionrecordMaxAggregateInputType = {
    id?: true
    collectorName?: true
    collectionDate?: true
    amount?: true
    purpose?: true
    source?: true
    notes?: true
    recordedAt?: true
    recordedByOwnerId?: true
    recordedByOwnerName?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    countedBy?: true
    isDeposited?: true
    depositDate?: true
    bankDepositReference?: true
  }

  export type CollectionrecordCountAggregateInputType = {
    id?: true
    collectorName?: true
    collectionDate?: true
    amount?: true
    purpose?: true
    source?: true
    notes?: true
    recordedAt?: true
    recordedByOwnerId?: true
    recordedByOwnerName?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    countedBy?: true
    isDeposited?: true
    depositDate?: true
    bankDepositReference?: true
    _all?: true
  }

  export type CollectionrecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collectionrecord to aggregate.
     */
    where?: collectionrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectionrecords to fetch.
     */
    orderBy?: collectionrecordOrderByWithRelationInput | collectionrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collectionrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectionrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectionrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collectionrecords
    **/
    _count?: true | CollectionrecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionrecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionrecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionrecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionrecordMaxAggregateInputType
  }

  export type GetCollectionrecordAggregateType<T extends CollectionrecordAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionrecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionrecord[P]>
      : GetScalarType<T[P], AggregateCollectionrecord[P]>
  }




  export type collectionrecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectionrecordWhereInput
    orderBy?: collectionrecordOrderByWithAggregationInput | collectionrecordOrderByWithAggregationInput[]
    by: CollectionrecordScalarFieldEnum[] | CollectionrecordScalarFieldEnum
    having?: collectionrecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionrecordCountAggregateInputType | true
    _avg?: CollectionrecordAvgAggregateInputType
    _sum?: CollectionrecordSumAggregateInputType
    _min?: CollectionrecordMinAggregateInputType
    _max?: CollectionrecordMaxAggregateInputType
  }

  export type CollectionrecordGroupByOutputType = {
    id: string
    collectorName: string
    collectionDate: Date
    amount: Decimal
    purpose: $Enums.collectionrecord_purpose
    source: string | null
    notes: string | null
    recordedAt: Date
    recordedByOwnerId: string | null
    recordedByOwnerName: string | null
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    countedBy: string | null
    isDeposited: boolean
    depositDate: Date | null
    bankDepositReference: string | null
    _count: CollectionrecordCountAggregateOutputType | null
    _avg: CollectionrecordAvgAggregateOutputType | null
    _sum: CollectionrecordSumAggregateOutputType | null
    _min: CollectionrecordMinAggregateOutputType | null
    _max: CollectionrecordMaxAggregateOutputType | null
  }

  type GetCollectionrecordGroupByPayload<T extends collectionrecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionrecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionrecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionrecordGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionrecordGroupByOutputType[P]>
        }
      >
    >


  export type collectionrecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectorName?: boolean
    collectionDate?: boolean
    amount?: boolean
    purpose?: boolean
    source?: boolean
    notes?: boolean
    recordedAt?: boolean
    recordedByOwnerId?: boolean
    recordedByOwnerName?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    countedBy?: boolean
    isDeposited?: boolean
    depositDate?: boolean
    bankDepositReference?: boolean
    donordetail?: boolean | collectionrecord$donordetailArgs<ExtArgs>
    _count?: boolean | CollectionrecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionrecord"]>


  export type collectionrecordSelectScalar = {
    id?: boolean
    collectorName?: boolean
    collectionDate?: boolean
    amount?: boolean
    purpose?: boolean
    source?: boolean
    notes?: boolean
    recordedAt?: boolean
    recordedByOwnerId?: boolean
    recordedByOwnerName?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    countedBy?: boolean
    isDeposited?: boolean
    depositDate?: boolean
    bankDepositReference?: boolean
  }

  export type collectionrecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donordetail?: boolean | collectionrecord$donordetailArgs<ExtArgs>
    _count?: boolean | CollectionrecordCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $collectionrecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collectionrecord"
    objects: {
      donordetail: Prisma.$donordetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectorName: string
      collectionDate: Date
      amount: Prisma.Decimal
      purpose: $Enums.collectionrecord_purpose
      source: string | null
      notes: string | null
      recordedAt: Date
      recordedByOwnerId: string | null
      recordedByOwnerName: string | null
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      countedBy: string | null
      isDeposited: boolean
      depositDate: Date | null
      bankDepositReference: string | null
    }, ExtArgs["result"]["collectionrecord"]>
    composites: {}
  }

  type collectionrecordGetPayload<S extends boolean | null | undefined | collectionrecordDefaultArgs> = $Result.GetResult<Prisma.$collectionrecordPayload, S>

  type collectionrecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<collectionrecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CollectionrecordCountAggregateInputType | true
    }

  export interface collectionrecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collectionrecord'], meta: { name: 'collectionrecord' } }
    /**
     * Find zero or one Collectionrecord that matches the filter.
     * @param {collectionrecordFindUniqueArgs} args - Arguments to find a Collectionrecord
     * @example
     * // Get one Collectionrecord
     * const collectionrecord = await prisma.collectionrecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collectionrecordFindUniqueArgs>(args: SelectSubset<T, collectionrecordFindUniqueArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collectionrecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {collectionrecordFindUniqueOrThrowArgs} args - Arguments to find a Collectionrecord
     * @example
     * // Get one Collectionrecord
     * const collectionrecord = await prisma.collectionrecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collectionrecordFindUniqueOrThrowArgs>(args: SelectSubset<T, collectionrecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collectionrecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionrecordFindFirstArgs} args - Arguments to find a Collectionrecord
     * @example
     * // Get one Collectionrecord
     * const collectionrecord = await prisma.collectionrecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collectionrecordFindFirstArgs>(args?: SelectSubset<T, collectionrecordFindFirstArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collectionrecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionrecordFindFirstOrThrowArgs} args - Arguments to find a Collectionrecord
     * @example
     * // Get one Collectionrecord
     * const collectionrecord = await prisma.collectionrecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collectionrecordFindFirstOrThrowArgs>(args?: SelectSubset<T, collectionrecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collectionrecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionrecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collectionrecords
     * const collectionrecords = await prisma.collectionrecord.findMany()
     * 
     * // Get first 10 Collectionrecords
     * const collectionrecords = await prisma.collectionrecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionrecordWithIdOnly = await prisma.collectionrecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collectionrecordFindManyArgs>(args?: SelectSubset<T, collectionrecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collectionrecord.
     * @param {collectionrecordCreateArgs} args - Arguments to create a Collectionrecord.
     * @example
     * // Create one Collectionrecord
     * const Collectionrecord = await prisma.collectionrecord.create({
     *   data: {
     *     // ... data to create a Collectionrecord
     *   }
     * })
     * 
     */
    create<T extends collectionrecordCreateArgs>(args: SelectSubset<T, collectionrecordCreateArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collectionrecords.
     * @param {collectionrecordCreateManyArgs} args - Arguments to create many Collectionrecords.
     * @example
     * // Create many Collectionrecords
     * const collectionrecord = await prisma.collectionrecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collectionrecordCreateManyArgs>(args?: SelectSubset<T, collectionrecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Collectionrecord.
     * @param {collectionrecordDeleteArgs} args - Arguments to delete one Collectionrecord.
     * @example
     * // Delete one Collectionrecord
     * const Collectionrecord = await prisma.collectionrecord.delete({
     *   where: {
     *     // ... filter to delete one Collectionrecord
     *   }
     * })
     * 
     */
    delete<T extends collectionrecordDeleteArgs>(args: SelectSubset<T, collectionrecordDeleteArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collectionrecord.
     * @param {collectionrecordUpdateArgs} args - Arguments to update one Collectionrecord.
     * @example
     * // Update one Collectionrecord
     * const collectionrecord = await prisma.collectionrecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collectionrecordUpdateArgs>(args: SelectSubset<T, collectionrecordUpdateArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collectionrecords.
     * @param {collectionrecordDeleteManyArgs} args - Arguments to filter Collectionrecords to delete.
     * @example
     * // Delete a few Collectionrecords
     * const { count } = await prisma.collectionrecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collectionrecordDeleteManyArgs>(args?: SelectSubset<T, collectionrecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collectionrecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionrecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collectionrecords
     * const collectionrecord = await prisma.collectionrecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collectionrecordUpdateManyArgs>(args: SelectSubset<T, collectionrecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collectionrecord.
     * @param {collectionrecordUpsertArgs} args - Arguments to update or create a Collectionrecord.
     * @example
     * // Update or create a Collectionrecord
     * const collectionrecord = await prisma.collectionrecord.upsert({
     *   create: {
     *     // ... data to create a Collectionrecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collectionrecord we want to update
     *   }
     * })
     */
    upsert<T extends collectionrecordUpsertArgs>(args: SelectSubset<T, collectionrecordUpsertArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collectionrecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionrecordCountArgs} args - Arguments to filter Collectionrecords to count.
     * @example
     * // Count the number of Collectionrecords
     * const count = await prisma.collectionrecord.count({
     *   where: {
     *     // ... the filter for the Collectionrecords we want to count
     *   }
     * })
    **/
    count<T extends collectionrecordCountArgs>(
      args?: Subset<T, collectionrecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionrecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collectionrecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionrecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionrecordAggregateArgs>(args: Subset<T, CollectionrecordAggregateArgs>): Prisma.PrismaPromise<GetCollectionrecordAggregateType<T>>

    /**
     * Group by Collectionrecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionrecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collectionrecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collectionrecordGroupByArgs['orderBy'] }
        : { orderBy?: collectionrecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collectionrecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionrecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collectionrecord model
   */
  readonly fields: collectionrecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collectionrecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collectionrecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    donordetail<T extends collectionrecord$donordetailArgs<ExtArgs> = {}>(args?: Subset<T, collectionrecord$donordetailArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collectionrecord model
   */ 
  interface collectionrecordFieldRefs {
    readonly id: FieldRef<"collectionrecord", 'String'>
    readonly collectorName: FieldRef<"collectionrecord", 'String'>
    readonly collectionDate: FieldRef<"collectionrecord", 'DateTime'>
    readonly amount: FieldRef<"collectionrecord", 'Decimal'>
    readonly purpose: FieldRef<"collectionrecord", 'collectionrecord_purpose'>
    readonly source: FieldRef<"collectionrecord", 'String'>
    readonly notes: FieldRef<"collectionrecord", 'String'>
    readonly recordedAt: FieldRef<"collectionrecord", 'DateTime'>
    readonly recordedByOwnerId: FieldRef<"collectionrecord", 'String'>
    readonly recordedByOwnerName: FieldRef<"collectionrecord", 'String'>
    readonly updatedAt: FieldRef<"collectionrecord", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"collectionrecord", 'String'>
    readonly postedByOwnerName: FieldRef<"collectionrecord", 'String'>
    readonly createdAt: FieldRef<"collectionrecord", 'DateTime'>
    readonly countedBy: FieldRef<"collectionrecord", 'String'>
    readonly isDeposited: FieldRef<"collectionrecord", 'Boolean'>
    readonly depositDate: FieldRef<"collectionrecord", 'DateTime'>
    readonly bankDepositReference: FieldRef<"collectionrecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * collectionrecord findUnique
   */
  export type collectionrecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * Filter, which collectionrecord to fetch.
     */
    where: collectionrecordWhereUniqueInput
  }

  /**
   * collectionrecord findUniqueOrThrow
   */
  export type collectionrecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * Filter, which collectionrecord to fetch.
     */
    where: collectionrecordWhereUniqueInput
  }

  /**
   * collectionrecord findFirst
   */
  export type collectionrecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * Filter, which collectionrecord to fetch.
     */
    where?: collectionrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectionrecords to fetch.
     */
    orderBy?: collectionrecordOrderByWithRelationInput | collectionrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectionrecords.
     */
    cursor?: collectionrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectionrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectionrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectionrecords.
     */
    distinct?: CollectionrecordScalarFieldEnum | CollectionrecordScalarFieldEnum[]
  }

  /**
   * collectionrecord findFirstOrThrow
   */
  export type collectionrecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * Filter, which collectionrecord to fetch.
     */
    where?: collectionrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectionrecords to fetch.
     */
    orderBy?: collectionrecordOrderByWithRelationInput | collectionrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectionrecords.
     */
    cursor?: collectionrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectionrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectionrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectionrecords.
     */
    distinct?: CollectionrecordScalarFieldEnum | CollectionrecordScalarFieldEnum[]
  }

  /**
   * collectionrecord findMany
   */
  export type collectionrecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * Filter, which collectionrecords to fetch.
     */
    where?: collectionrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectionrecords to fetch.
     */
    orderBy?: collectionrecordOrderByWithRelationInput | collectionrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collectionrecords.
     */
    cursor?: collectionrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectionrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectionrecords.
     */
    skip?: number
    distinct?: CollectionrecordScalarFieldEnum | CollectionrecordScalarFieldEnum[]
  }

  /**
   * collectionrecord create
   */
  export type collectionrecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * The data needed to create a collectionrecord.
     */
    data: XOR<collectionrecordCreateInput, collectionrecordUncheckedCreateInput>
  }

  /**
   * collectionrecord createMany
   */
  export type collectionrecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collectionrecords.
     */
    data: collectionrecordCreateManyInput | collectionrecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collectionrecord update
   */
  export type collectionrecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * The data needed to update a collectionrecord.
     */
    data: XOR<collectionrecordUpdateInput, collectionrecordUncheckedUpdateInput>
    /**
     * Choose, which collectionrecord to update.
     */
    where: collectionrecordWhereUniqueInput
  }

  /**
   * collectionrecord updateMany
   */
  export type collectionrecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collectionrecords.
     */
    data: XOR<collectionrecordUpdateManyMutationInput, collectionrecordUncheckedUpdateManyInput>
    /**
     * Filter which collectionrecords to update
     */
    where?: collectionrecordWhereInput
  }

  /**
   * collectionrecord upsert
   */
  export type collectionrecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * The filter to search for the collectionrecord to update in case it exists.
     */
    where: collectionrecordWhereUniqueInput
    /**
     * In case the collectionrecord found by the `where` argument doesn't exist, create a new collectionrecord with this data.
     */
    create: XOR<collectionrecordCreateInput, collectionrecordUncheckedCreateInput>
    /**
     * In case the collectionrecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collectionrecordUpdateInput, collectionrecordUncheckedUpdateInput>
  }

  /**
   * collectionrecord delete
   */
  export type collectionrecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
    /**
     * Filter which collectionrecord to delete.
     */
    where: collectionrecordWhereUniqueInput
  }

  /**
   * collectionrecord deleteMany
   */
  export type collectionrecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collectionrecords to delete
     */
    where?: collectionrecordWhereInput
  }

  /**
   * collectionrecord.donordetail
   */
  export type collectionrecord$donordetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    where?: donordetailWhereInput
    orderBy?: donordetailOrderByWithRelationInput | donordetailOrderByWithRelationInput[]
    cursor?: donordetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonordetailScalarFieldEnum | DonordetailScalarFieldEnum[]
  }

  /**
   * collectionrecord without action
   */
  export type collectionrecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectionrecord
     */
    select?: collectionrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: collectionrecordInclude<ExtArgs> | null
  }


  /**
   * Model comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userProfileImageUrl: string | null
    text: string | null
    timestamp: Date | null
    editedAt: Date | null
    sermonId: string | null
    eventId: string | null
    blogPostId: string | null
    newsItemId: string | null
    historyChapterId: string | null
    prayerRequestId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userProfileImageUrl: string | null
    text: string | null
    timestamp: Date | null
    editedAt: Date | null
    sermonId: string | null
    eventId: string | null
    blogPostId: string | null
    newsItemId: string | null
    historyChapterId: string | null
    prayerRequestId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    userProfileImageUrl: number
    text: number
    timestamp: number
    editedAt: number
    sermonId: number
    eventId: number
    blogPostId: number
    newsItemId: number
    historyChapterId: number
    prayerRequestId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    text?: true
    timestamp?: true
    editedAt?: true
    sermonId?: true
    eventId?: true
    blogPostId?: true
    newsItemId?: true
    historyChapterId?: true
    prayerRequestId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    text?: true
    timestamp?: true
    editedAt?: true
    sermonId?: true
    eventId?: true
    blogPostId?: true
    newsItemId?: true
    historyChapterId?: true
    prayerRequestId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    text?: true
    timestamp?: true
    editedAt?: true
    sermonId?: true
    eventId?: true
    blogPostId?: true
    newsItemId?: true
    historyChapterId?: true
    prayerRequestId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comment to aggregate.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type commentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
    orderBy?: commentOrderByWithAggregationInput | commentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: commentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl: string | null
    text: string
    timestamp: Date
    editedAt: Date | null
    sermonId: string | null
    eventId: string | null
    blogPostId: string | null
    newsItemId: string | null
    historyChapterId: string | null
    prayerRequestId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends commentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type commentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userProfileImageUrl?: boolean
    text?: boolean
    timestamp?: boolean
    editedAt?: boolean
    sermonId?: boolean
    eventId?: boolean
    blogPostId?: boolean
    newsItemId?: boolean
    historyChapterId?: boolean
    prayerRequestId?: boolean
    blogpost?: boolean | comment$blogpostArgs<ExtArgs>
    eventitem?: boolean | comment$eventitemArgs<ExtArgs>
    historychapter?: boolean | comment$historychapterArgs<ExtArgs>
    newsitem?: boolean | comment$newsitemArgs<ExtArgs>
    prayerrequest?: boolean | comment$prayerrequestArgs<ExtArgs>
    sermon?: boolean | comment$sermonArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>


  export type commentSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    userProfileImageUrl?: boolean
    text?: boolean
    timestamp?: boolean
    editedAt?: boolean
    sermonId?: boolean
    eventId?: boolean
    blogPostId?: boolean
    newsItemId?: boolean
    historyChapterId?: boolean
    prayerRequestId?: boolean
  }

  export type commentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogpost?: boolean | comment$blogpostArgs<ExtArgs>
    eventitem?: boolean | comment$eventitemArgs<ExtArgs>
    historychapter?: boolean | comment$historychapterArgs<ExtArgs>
    newsitem?: boolean | comment$newsitemArgs<ExtArgs>
    prayerrequest?: boolean | comment$prayerrequestArgs<ExtArgs>
    sermon?: boolean | comment$sermonArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $commentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comment"
    objects: {
      blogpost: Prisma.$blogpostPayload<ExtArgs> | null
      eventitem: Prisma.$eventitemPayload<ExtArgs> | null
      historychapter: Prisma.$historychapterPayload<ExtArgs> | null
      newsitem: Prisma.$newsitemPayload<ExtArgs> | null
      prayerrequest: Prisma.$prayerrequestPayload<ExtArgs> | null
      sermon: Prisma.$sermonPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string
      userProfileImageUrl: string | null
      text: string
      timestamp: Date
      editedAt: Date | null
      sermonId: string | null
      eventId: string | null
      blogPostId: string | null
      newsItemId: string | null
      historyChapterId: string | null
      prayerRequestId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type commentGetPayload<S extends boolean | null | undefined | commentDefaultArgs> = $Result.GetResult<Prisma.$commentPayload, S>

  type commentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<commentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface commentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comment'], meta: { name: 'comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {commentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentFindUniqueArgs>(args: SelectSubset<T, commentFindUniqueArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {commentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentFindUniqueOrThrowArgs>(args: SelectSubset<T, commentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentFindFirstArgs>(args?: SelectSubset<T, commentFindFirstArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentFindFirstOrThrowArgs>(args?: SelectSubset<T, commentFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends commentFindManyArgs>(args?: SelectSubset<T, commentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {commentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends commentCreateArgs>(args: SelectSubset<T, commentCreateArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {commentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentCreateManyArgs>(args?: SelectSubset<T, commentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {commentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends commentDeleteArgs>(args: SelectSubset<T, commentDeleteArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {commentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentUpdateArgs>(args: SelectSubset<T, commentUpdateArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {commentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentDeleteManyArgs>(args?: SelectSubset<T, commentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentUpdateManyArgs>(args: SelectSubset<T, commentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {commentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends commentUpsertArgs>(args: SelectSubset<T, commentUpsertArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentCountArgs>(
      args?: Subset<T, commentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentGroupByArgs['orderBy'] }
        : { orderBy?: commentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comment model
   */
  readonly fields: commentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogpost<T extends comment$blogpostArgs<ExtArgs> = {}>(args?: Subset<T, comment$blogpostArgs<ExtArgs>>): Prisma__blogpostClient<$Result.GetResult<Prisma.$blogpostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    eventitem<T extends comment$eventitemArgs<ExtArgs> = {}>(args?: Subset<T, comment$eventitemArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    historychapter<T extends comment$historychapterArgs<ExtArgs> = {}>(args?: Subset<T, comment$historychapterArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    newsitem<T extends comment$newsitemArgs<ExtArgs> = {}>(args?: Subset<T, comment$newsitemArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prayerrequest<T extends comment$prayerrequestArgs<ExtArgs> = {}>(args?: Subset<T, comment$prayerrequestArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sermon<T extends comment$sermonArgs<ExtArgs> = {}>(args?: Subset<T, comment$sermonArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comment model
   */ 
  interface commentFieldRefs {
    readonly id: FieldRef<"comment", 'String'>
    readonly userId: FieldRef<"comment", 'String'>
    readonly userName: FieldRef<"comment", 'String'>
    readonly userProfileImageUrl: FieldRef<"comment", 'String'>
    readonly text: FieldRef<"comment", 'String'>
    readonly timestamp: FieldRef<"comment", 'DateTime'>
    readonly editedAt: FieldRef<"comment", 'DateTime'>
    readonly sermonId: FieldRef<"comment", 'String'>
    readonly eventId: FieldRef<"comment", 'String'>
    readonly blogPostId: FieldRef<"comment", 'String'>
    readonly newsItemId: FieldRef<"comment", 'String'>
    readonly historyChapterId: FieldRef<"comment", 'String'>
    readonly prayerRequestId: FieldRef<"comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * comment findUnique
   */
  export type commentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment findUniqueOrThrow
   */
  export type commentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment findFirst
   */
  export type commentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * comment findFirstOrThrow
   */
  export type commentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * comment findMany
   */
  export type commentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * comment create
   */
  export type commentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * The data needed to create a comment.
     */
    data: XOR<commentCreateInput, commentUncheckedCreateInput>
  }

  /**
   * comment createMany
   */
  export type commentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentCreateManyInput | commentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comment update
   */
  export type commentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * The data needed to update a comment.
     */
    data: XOR<commentUpdateInput, commentUncheckedUpdateInput>
    /**
     * Choose, which comment to update.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment updateMany
   */
  export type commentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentWhereInput
  }

  /**
   * comment upsert
   */
  export type commentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * The filter to search for the comment to update in case it exists.
     */
    where: commentWhereUniqueInput
    /**
     * In case the comment found by the `where` argument doesn't exist, create a new comment with this data.
     */
    create: XOR<commentCreateInput, commentUncheckedCreateInput>
    /**
     * In case the comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentUpdateInput, commentUncheckedUpdateInput>
  }

  /**
   * comment delete
   */
  export type commentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter which comment to delete.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment deleteMany
   */
  export type commentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentWhereInput
  }

  /**
   * comment.blogpost
   */
  export type comment$blogpostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogpost
     */
    select?: blogpostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogpostInclude<ExtArgs> | null
    where?: blogpostWhereInput
  }

  /**
   * comment.eventitem
   */
  export type comment$eventitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    where?: eventitemWhereInput
  }

  /**
   * comment.historychapter
   */
  export type comment$historychapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    where?: historychapterWhereInput
  }

  /**
   * comment.newsitem
   */
  export type comment$newsitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    where?: newsitemWhereInput
  }

  /**
   * comment.prayerrequest
   */
  export type comment$prayerrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    where?: prayerrequestWhereInput
  }

  /**
   * comment.sermon
   */
  export type comment$sermonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    where?: sermonWhereInput
  }

  /**
   * comment without action
   */
  export type commentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
  }


  /**
   * Model contactmessage
   */

  export type AggregateContactmessage = {
    _count: ContactmessageCountAggregateOutputType | null
    _min: ContactmessageMinAggregateOutputType | null
    _max: ContactmessageMaxAggregateOutputType | null
  }

  export type ContactmessageMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    submittedAt: Date | null
    status: $Enums.contactmessage_status | null
    repliedAt: Date | null
    replyNote: string | null
  }

  export type ContactmessageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    submittedAt: Date | null
    status: $Enums.contactmessage_status | null
    repliedAt: Date | null
    replyNote: string | null
  }

  export type ContactmessageCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    submittedAt: number
    status: number
    repliedAt: number
    replyNote: number
    _all: number
  }


  export type ContactmessageMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    submittedAt?: true
    status?: true
    repliedAt?: true
    replyNote?: true
  }

  export type ContactmessageMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    submittedAt?: true
    status?: true
    repliedAt?: true
    replyNote?: true
  }

  export type ContactmessageCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    submittedAt?: true
    status?: true
    repliedAt?: true
    replyNote?: true
    _all?: true
  }

  export type ContactmessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contactmessage to aggregate.
     */
    where?: contactmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactmessages to fetch.
     */
    orderBy?: contactmessageOrderByWithRelationInput | contactmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contactmessages
    **/
    _count?: true | ContactmessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactmessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactmessageMaxAggregateInputType
  }

  export type GetContactmessageAggregateType<T extends ContactmessageAggregateArgs> = {
        [P in keyof T & keyof AggregateContactmessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactmessage[P]>
      : GetScalarType<T[P], AggregateContactmessage[P]>
  }




  export type contactmessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactmessageWhereInput
    orderBy?: contactmessageOrderByWithAggregationInput | contactmessageOrderByWithAggregationInput[]
    by: ContactmessageScalarFieldEnum[] | ContactmessageScalarFieldEnum
    having?: contactmessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactmessageCountAggregateInputType | true
    _min?: ContactmessageMinAggregateInputType
    _max?: ContactmessageMaxAggregateInputType
  }

  export type ContactmessageGroupByOutputType = {
    id: string
    name: string
    email: string
    subject: string
    message: string
    submittedAt: Date
    status: $Enums.contactmessage_status
    repliedAt: Date | null
    replyNote: string | null
    _count: ContactmessageCountAggregateOutputType | null
    _min: ContactmessageMinAggregateOutputType | null
    _max: ContactmessageMaxAggregateOutputType | null
  }

  type GetContactmessageGroupByPayload<T extends contactmessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactmessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactmessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactmessageGroupByOutputType[P]>
            : GetScalarType<T[P], ContactmessageGroupByOutputType[P]>
        }
      >
    >


  export type contactmessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    submittedAt?: boolean
    status?: boolean
    repliedAt?: boolean
    replyNote?: boolean
  }, ExtArgs["result"]["contactmessage"]>


  export type contactmessageSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    submittedAt?: boolean
    status?: boolean
    repliedAt?: boolean
    replyNote?: boolean
  }


  export type $contactmessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contactmessage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      subject: string
      message: string
      submittedAt: Date
      status: $Enums.contactmessage_status
      repliedAt: Date | null
      replyNote: string | null
    }, ExtArgs["result"]["contactmessage"]>
    composites: {}
  }

  type contactmessageGetPayload<S extends boolean | null | undefined | contactmessageDefaultArgs> = $Result.GetResult<Prisma.$contactmessagePayload, S>

  type contactmessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contactmessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactmessageCountAggregateInputType | true
    }

  export interface contactmessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contactmessage'], meta: { name: 'contactmessage' } }
    /**
     * Find zero or one Contactmessage that matches the filter.
     * @param {contactmessageFindUniqueArgs} args - Arguments to find a Contactmessage
     * @example
     * // Get one Contactmessage
     * const contactmessage = await prisma.contactmessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactmessageFindUniqueArgs>(args: SelectSubset<T, contactmessageFindUniqueArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contactmessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {contactmessageFindUniqueOrThrowArgs} args - Arguments to find a Contactmessage
     * @example
     * // Get one Contactmessage
     * const contactmessage = await prisma.contactmessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactmessageFindUniqueOrThrowArgs>(args: SelectSubset<T, contactmessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contactmessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactmessageFindFirstArgs} args - Arguments to find a Contactmessage
     * @example
     * // Get one Contactmessage
     * const contactmessage = await prisma.contactmessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactmessageFindFirstArgs>(args?: SelectSubset<T, contactmessageFindFirstArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contactmessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactmessageFindFirstOrThrowArgs} args - Arguments to find a Contactmessage
     * @example
     * // Get one Contactmessage
     * const contactmessage = await prisma.contactmessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactmessageFindFirstOrThrowArgs>(args?: SelectSubset<T, contactmessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contactmessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactmessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactmessages
     * const contactmessages = await prisma.contactmessage.findMany()
     * 
     * // Get first 10 Contactmessages
     * const contactmessages = await prisma.contactmessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactmessageWithIdOnly = await prisma.contactmessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactmessageFindManyArgs>(args?: SelectSubset<T, contactmessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contactmessage.
     * @param {contactmessageCreateArgs} args - Arguments to create a Contactmessage.
     * @example
     * // Create one Contactmessage
     * const Contactmessage = await prisma.contactmessage.create({
     *   data: {
     *     // ... data to create a Contactmessage
     *   }
     * })
     * 
     */
    create<T extends contactmessageCreateArgs>(args: SelectSubset<T, contactmessageCreateArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contactmessages.
     * @param {contactmessageCreateManyArgs} args - Arguments to create many Contactmessages.
     * @example
     * // Create many Contactmessages
     * const contactmessage = await prisma.contactmessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactmessageCreateManyArgs>(args?: SelectSubset<T, contactmessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contactmessage.
     * @param {contactmessageDeleteArgs} args - Arguments to delete one Contactmessage.
     * @example
     * // Delete one Contactmessage
     * const Contactmessage = await prisma.contactmessage.delete({
     *   where: {
     *     // ... filter to delete one Contactmessage
     *   }
     * })
     * 
     */
    delete<T extends contactmessageDeleteArgs>(args: SelectSubset<T, contactmessageDeleteArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contactmessage.
     * @param {contactmessageUpdateArgs} args - Arguments to update one Contactmessage.
     * @example
     * // Update one Contactmessage
     * const contactmessage = await prisma.contactmessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactmessageUpdateArgs>(args: SelectSubset<T, contactmessageUpdateArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contactmessages.
     * @param {contactmessageDeleteManyArgs} args - Arguments to filter Contactmessages to delete.
     * @example
     * // Delete a few Contactmessages
     * const { count } = await prisma.contactmessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactmessageDeleteManyArgs>(args?: SelectSubset<T, contactmessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactmessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactmessages
     * const contactmessage = await prisma.contactmessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactmessageUpdateManyArgs>(args: SelectSubset<T, contactmessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contactmessage.
     * @param {contactmessageUpsertArgs} args - Arguments to update or create a Contactmessage.
     * @example
     * // Update or create a Contactmessage
     * const contactmessage = await prisma.contactmessage.upsert({
     *   create: {
     *     // ... data to create a Contactmessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contactmessage we want to update
     *   }
     * })
     */
    upsert<T extends contactmessageUpsertArgs>(args: SelectSubset<T, contactmessageUpsertArgs<ExtArgs>>): Prisma__contactmessageClient<$Result.GetResult<Prisma.$contactmessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contactmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactmessageCountArgs} args - Arguments to filter Contactmessages to count.
     * @example
     * // Count the number of Contactmessages
     * const count = await prisma.contactmessage.count({
     *   where: {
     *     // ... the filter for the Contactmessages we want to count
     *   }
     * })
    **/
    count<T extends contactmessageCountArgs>(
      args?: Subset<T, contactmessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactmessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contactmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactmessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactmessageAggregateArgs>(args: Subset<T, ContactmessageAggregateArgs>): Prisma.PrismaPromise<GetContactmessageAggregateType<T>>

    /**
     * Group by Contactmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactmessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactmessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactmessageGroupByArgs['orderBy'] }
        : { orderBy?: contactmessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactmessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactmessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contactmessage model
   */
  readonly fields: contactmessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contactmessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactmessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contactmessage model
   */ 
  interface contactmessageFieldRefs {
    readonly id: FieldRef<"contactmessage", 'String'>
    readonly name: FieldRef<"contactmessage", 'String'>
    readonly email: FieldRef<"contactmessage", 'String'>
    readonly subject: FieldRef<"contactmessage", 'String'>
    readonly message: FieldRef<"contactmessage", 'String'>
    readonly submittedAt: FieldRef<"contactmessage", 'DateTime'>
    readonly status: FieldRef<"contactmessage", 'contactmessage_status'>
    readonly repliedAt: FieldRef<"contactmessage", 'DateTime'>
    readonly replyNote: FieldRef<"contactmessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * contactmessage findUnique
   */
  export type contactmessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * Filter, which contactmessage to fetch.
     */
    where: contactmessageWhereUniqueInput
  }

  /**
   * contactmessage findUniqueOrThrow
   */
  export type contactmessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * Filter, which contactmessage to fetch.
     */
    where: contactmessageWhereUniqueInput
  }

  /**
   * contactmessage findFirst
   */
  export type contactmessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * Filter, which contactmessage to fetch.
     */
    where?: contactmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactmessages to fetch.
     */
    orderBy?: contactmessageOrderByWithRelationInput | contactmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contactmessages.
     */
    cursor?: contactmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contactmessages.
     */
    distinct?: ContactmessageScalarFieldEnum | ContactmessageScalarFieldEnum[]
  }

  /**
   * contactmessage findFirstOrThrow
   */
  export type contactmessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * Filter, which contactmessage to fetch.
     */
    where?: contactmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactmessages to fetch.
     */
    orderBy?: contactmessageOrderByWithRelationInput | contactmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contactmessages.
     */
    cursor?: contactmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contactmessages.
     */
    distinct?: ContactmessageScalarFieldEnum | ContactmessageScalarFieldEnum[]
  }

  /**
   * contactmessage findMany
   */
  export type contactmessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * Filter, which contactmessages to fetch.
     */
    where?: contactmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactmessages to fetch.
     */
    orderBy?: contactmessageOrderByWithRelationInput | contactmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contactmessages.
     */
    cursor?: contactmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactmessages.
     */
    skip?: number
    distinct?: ContactmessageScalarFieldEnum | ContactmessageScalarFieldEnum[]
  }

  /**
   * contactmessage create
   */
  export type contactmessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * The data needed to create a contactmessage.
     */
    data: XOR<contactmessageCreateInput, contactmessageUncheckedCreateInput>
  }

  /**
   * contactmessage createMany
   */
  export type contactmessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contactmessages.
     */
    data: contactmessageCreateManyInput | contactmessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contactmessage update
   */
  export type contactmessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * The data needed to update a contactmessage.
     */
    data: XOR<contactmessageUpdateInput, contactmessageUncheckedUpdateInput>
    /**
     * Choose, which contactmessage to update.
     */
    where: contactmessageWhereUniqueInput
  }

  /**
   * contactmessage updateMany
   */
  export type contactmessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contactmessages.
     */
    data: XOR<contactmessageUpdateManyMutationInput, contactmessageUncheckedUpdateManyInput>
    /**
     * Filter which contactmessages to update
     */
    where?: contactmessageWhereInput
  }

  /**
   * contactmessage upsert
   */
  export type contactmessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * The filter to search for the contactmessage to update in case it exists.
     */
    where: contactmessageWhereUniqueInput
    /**
     * In case the contactmessage found by the `where` argument doesn't exist, create a new contactmessage with this data.
     */
    create: XOR<contactmessageCreateInput, contactmessageUncheckedCreateInput>
    /**
     * In case the contactmessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactmessageUpdateInput, contactmessageUncheckedUpdateInput>
  }

  /**
   * contactmessage delete
   */
  export type contactmessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
    /**
     * Filter which contactmessage to delete.
     */
    where: contactmessageWhereUniqueInput
  }

  /**
   * contactmessage deleteMany
   */
  export type contactmessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contactmessages to delete
     */
    where?: contactmessageWhereInput
  }

  /**
   * contactmessage without action
   */
  export type contactmessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactmessage
     */
    select?: contactmessageSelect<ExtArgs> | null
  }


  /**
   * Model decisionlog
   */

  export type AggregateDecisionlog = {
    _count: DecisionlogCountAggregateOutputType | null
    _min: DecisionlogMinAggregateOutputType | null
    _max: DecisionlogMaxAggregateOutputType | null
  }

  export type DecisionlogMinAggregateOutputType = {
    id: string | null
    decisionDate: Date | null
    title: string | null
    description: string | null
    madeBy: string | null
    status: $Enums.decisionlog_status | null
    followUpActions: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DecisionlogMaxAggregateOutputType = {
    id: string | null
    decisionDate: Date | null
    title: string | null
    description: string | null
    madeBy: string | null
    status: $Enums.decisionlog_status | null
    followUpActions: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DecisionlogCountAggregateOutputType = {
    id: number
    decisionDate: number
    title: number
    description: number
    madeBy: number
    status: number
    followUpActions: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DecisionlogMinAggregateInputType = {
    id?: true
    decisionDate?: true
    title?: true
    description?: true
    madeBy?: true
    status?: true
    followUpActions?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DecisionlogMaxAggregateInputType = {
    id?: true
    decisionDate?: true
    title?: true
    description?: true
    madeBy?: true
    status?: true
    followUpActions?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DecisionlogCountAggregateInputType = {
    id?: true
    decisionDate?: true
    title?: true
    description?: true
    madeBy?: true
    status?: true
    followUpActions?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DecisionlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which decisionlog to aggregate.
     */
    where?: decisionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of decisionlogs to fetch.
     */
    orderBy?: decisionlogOrderByWithRelationInput | decisionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: decisionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` decisionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` decisionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned decisionlogs
    **/
    _count?: true | DecisionlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecisionlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecisionlogMaxAggregateInputType
  }

  export type GetDecisionlogAggregateType<T extends DecisionlogAggregateArgs> = {
        [P in keyof T & keyof AggregateDecisionlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecisionlog[P]>
      : GetScalarType<T[P], AggregateDecisionlog[P]>
  }




  export type decisionlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: decisionlogWhereInput
    orderBy?: decisionlogOrderByWithAggregationInput | decisionlogOrderByWithAggregationInput[]
    by: DecisionlogScalarFieldEnum[] | DecisionlogScalarFieldEnum
    having?: decisionlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecisionlogCountAggregateInputType | true
    _min?: DecisionlogMinAggregateInputType
    _max?: DecisionlogMaxAggregateInputType
  }

  export type DecisionlogGroupByOutputType = {
    id: string
    decisionDate: Date
    title: string
    description: string
    madeBy: string
    status: $Enums.decisionlog_status | null
    followUpActions: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    _count: DecisionlogCountAggregateOutputType | null
    _min: DecisionlogMinAggregateOutputType | null
    _max: DecisionlogMaxAggregateOutputType | null
  }

  type GetDecisionlogGroupByPayload<T extends decisionlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecisionlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecisionlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecisionlogGroupByOutputType[P]>
            : GetScalarType<T[P], DecisionlogGroupByOutputType[P]>
        }
      >
    >


  export type decisionlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    decisionDate?: boolean
    title?: boolean
    description?: boolean
    madeBy?: boolean
    status?: boolean
    followUpActions?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["decisionlog"]>


  export type decisionlogSelectScalar = {
    id?: boolean
    decisionDate?: boolean
    title?: boolean
    description?: boolean
    madeBy?: boolean
    status?: boolean
    followUpActions?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $decisionlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "decisionlog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      decisionDate: Date
      title: string
      description: string
      madeBy: string
      status: $Enums.decisionlog_status | null
      followUpActions: string | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["decisionlog"]>
    composites: {}
  }

  type decisionlogGetPayload<S extends boolean | null | undefined | decisionlogDefaultArgs> = $Result.GetResult<Prisma.$decisionlogPayload, S>

  type decisionlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<decisionlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DecisionlogCountAggregateInputType | true
    }

  export interface decisionlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['decisionlog'], meta: { name: 'decisionlog' } }
    /**
     * Find zero or one Decisionlog that matches the filter.
     * @param {decisionlogFindUniqueArgs} args - Arguments to find a Decisionlog
     * @example
     * // Get one Decisionlog
     * const decisionlog = await prisma.decisionlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends decisionlogFindUniqueArgs>(args: SelectSubset<T, decisionlogFindUniqueArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Decisionlog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {decisionlogFindUniqueOrThrowArgs} args - Arguments to find a Decisionlog
     * @example
     * // Get one Decisionlog
     * const decisionlog = await prisma.decisionlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends decisionlogFindUniqueOrThrowArgs>(args: SelectSubset<T, decisionlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Decisionlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {decisionlogFindFirstArgs} args - Arguments to find a Decisionlog
     * @example
     * // Get one Decisionlog
     * const decisionlog = await prisma.decisionlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends decisionlogFindFirstArgs>(args?: SelectSubset<T, decisionlogFindFirstArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Decisionlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {decisionlogFindFirstOrThrowArgs} args - Arguments to find a Decisionlog
     * @example
     * // Get one Decisionlog
     * const decisionlog = await prisma.decisionlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends decisionlogFindFirstOrThrowArgs>(args?: SelectSubset<T, decisionlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Decisionlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {decisionlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Decisionlogs
     * const decisionlogs = await prisma.decisionlog.findMany()
     * 
     * // Get first 10 Decisionlogs
     * const decisionlogs = await prisma.decisionlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decisionlogWithIdOnly = await prisma.decisionlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends decisionlogFindManyArgs>(args?: SelectSubset<T, decisionlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Decisionlog.
     * @param {decisionlogCreateArgs} args - Arguments to create a Decisionlog.
     * @example
     * // Create one Decisionlog
     * const Decisionlog = await prisma.decisionlog.create({
     *   data: {
     *     // ... data to create a Decisionlog
     *   }
     * })
     * 
     */
    create<T extends decisionlogCreateArgs>(args: SelectSubset<T, decisionlogCreateArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Decisionlogs.
     * @param {decisionlogCreateManyArgs} args - Arguments to create many Decisionlogs.
     * @example
     * // Create many Decisionlogs
     * const decisionlog = await prisma.decisionlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends decisionlogCreateManyArgs>(args?: SelectSubset<T, decisionlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Decisionlog.
     * @param {decisionlogDeleteArgs} args - Arguments to delete one Decisionlog.
     * @example
     * // Delete one Decisionlog
     * const Decisionlog = await prisma.decisionlog.delete({
     *   where: {
     *     // ... filter to delete one Decisionlog
     *   }
     * })
     * 
     */
    delete<T extends decisionlogDeleteArgs>(args: SelectSubset<T, decisionlogDeleteArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Decisionlog.
     * @param {decisionlogUpdateArgs} args - Arguments to update one Decisionlog.
     * @example
     * // Update one Decisionlog
     * const decisionlog = await prisma.decisionlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends decisionlogUpdateArgs>(args: SelectSubset<T, decisionlogUpdateArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Decisionlogs.
     * @param {decisionlogDeleteManyArgs} args - Arguments to filter Decisionlogs to delete.
     * @example
     * // Delete a few Decisionlogs
     * const { count } = await prisma.decisionlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends decisionlogDeleteManyArgs>(args?: SelectSubset<T, decisionlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decisionlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {decisionlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Decisionlogs
     * const decisionlog = await prisma.decisionlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends decisionlogUpdateManyArgs>(args: SelectSubset<T, decisionlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Decisionlog.
     * @param {decisionlogUpsertArgs} args - Arguments to update or create a Decisionlog.
     * @example
     * // Update or create a Decisionlog
     * const decisionlog = await prisma.decisionlog.upsert({
     *   create: {
     *     // ... data to create a Decisionlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Decisionlog we want to update
     *   }
     * })
     */
    upsert<T extends decisionlogUpsertArgs>(args: SelectSubset<T, decisionlogUpsertArgs<ExtArgs>>): Prisma__decisionlogClient<$Result.GetResult<Prisma.$decisionlogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Decisionlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {decisionlogCountArgs} args - Arguments to filter Decisionlogs to count.
     * @example
     * // Count the number of Decisionlogs
     * const count = await prisma.decisionlog.count({
     *   where: {
     *     // ... the filter for the Decisionlogs we want to count
     *   }
     * })
    **/
    count<T extends decisionlogCountArgs>(
      args?: Subset<T, decisionlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecisionlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Decisionlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecisionlogAggregateArgs>(args: Subset<T, DecisionlogAggregateArgs>): Prisma.PrismaPromise<GetDecisionlogAggregateType<T>>

    /**
     * Group by Decisionlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {decisionlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends decisionlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: decisionlogGroupByArgs['orderBy'] }
        : { orderBy?: decisionlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, decisionlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecisionlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the decisionlog model
   */
  readonly fields: decisionlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for decisionlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__decisionlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the decisionlog model
   */ 
  interface decisionlogFieldRefs {
    readonly id: FieldRef<"decisionlog", 'String'>
    readonly decisionDate: FieldRef<"decisionlog", 'DateTime'>
    readonly title: FieldRef<"decisionlog", 'String'>
    readonly description: FieldRef<"decisionlog", 'String'>
    readonly madeBy: FieldRef<"decisionlog", 'String'>
    readonly status: FieldRef<"decisionlog", 'decisionlog_status'>
    readonly followUpActions: FieldRef<"decisionlog", 'String'>
    readonly postedByOwnerId: FieldRef<"decisionlog", 'String'>
    readonly postedByOwnerName: FieldRef<"decisionlog", 'String'>
    readonly createdAt: FieldRef<"decisionlog", 'DateTime'>
    readonly updatedAt: FieldRef<"decisionlog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * decisionlog findUnique
   */
  export type decisionlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * Filter, which decisionlog to fetch.
     */
    where: decisionlogWhereUniqueInput
  }

  /**
   * decisionlog findUniqueOrThrow
   */
  export type decisionlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * Filter, which decisionlog to fetch.
     */
    where: decisionlogWhereUniqueInput
  }

  /**
   * decisionlog findFirst
   */
  export type decisionlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * Filter, which decisionlog to fetch.
     */
    where?: decisionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of decisionlogs to fetch.
     */
    orderBy?: decisionlogOrderByWithRelationInput | decisionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for decisionlogs.
     */
    cursor?: decisionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` decisionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` decisionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of decisionlogs.
     */
    distinct?: DecisionlogScalarFieldEnum | DecisionlogScalarFieldEnum[]
  }

  /**
   * decisionlog findFirstOrThrow
   */
  export type decisionlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * Filter, which decisionlog to fetch.
     */
    where?: decisionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of decisionlogs to fetch.
     */
    orderBy?: decisionlogOrderByWithRelationInput | decisionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for decisionlogs.
     */
    cursor?: decisionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` decisionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` decisionlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of decisionlogs.
     */
    distinct?: DecisionlogScalarFieldEnum | DecisionlogScalarFieldEnum[]
  }

  /**
   * decisionlog findMany
   */
  export type decisionlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * Filter, which decisionlogs to fetch.
     */
    where?: decisionlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of decisionlogs to fetch.
     */
    orderBy?: decisionlogOrderByWithRelationInput | decisionlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing decisionlogs.
     */
    cursor?: decisionlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` decisionlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` decisionlogs.
     */
    skip?: number
    distinct?: DecisionlogScalarFieldEnum | DecisionlogScalarFieldEnum[]
  }

  /**
   * decisionlog create
   */
  export type decisionlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * The data needed to create a decisionlog.
     */
    data: XOR<decisionlogCreateInput, decisionlogUncheckedCreateInput>
  }

  /**
   * decisionlog createMany
   */
  export type decisionlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many decisionlogs.
     */
    data: decisionlogCreateManyInput | decisionlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * decisionlog update
   */
  export type decisionlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * The data needed to update a decisionlog.
     */
    data: XOR<decisionlogUpdateInput, decisionlogUncheckedUpdateInput>
    /**
     * Choose, which decisionlog to update.
     */
    where: decisionlogWhereUniqueInput
  }

  /**
   * decisionlog updateMany
   */
  export type decisionlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update decisionlogs.
     */
    data: XOR<decisionlogUpdateManyMutationInput, decisionlogUncheckedUpdateManyInput>
    /**
     * Filter which decisionlogs to update
     */
    where?: decisionlogWhereInput
  }

  /**
   * decisionlog upsert
   */
  export type decisionlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * The filter to search for the decisionlog to update in case it exists.
     */
    where: decisionlogWhereUniqueInput
    /**
     * In case the decisionlog found by the `where` argument doesn't exist, create a new decisionlog with this data.
     */
    create: XOR<decisionlogCreateInput, decisionlogUncheckedCreateInput>
    /**
     * In case the decisionlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<decisionlogUpdateInput, decisionlogUncheckedUpdateInput>
  }

  /**
   * decisionlog delete
   */
  export type decisionlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
    /**
     * Filter which decisionlog to delete.
     */
    where: decisionlogWhereUniqueInput
  }

  /**
   * decisionlog deleteMany
   */
  export type decisionlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which decisionlogs to delete
     */
    where?: decisionlogWhereInput
  }

  /**
   * decisionlog without action
   */
  export type decisionlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the decisionlog
     */
    select?: decisionlogSelect<ExtArgs> | null
  }


  /**
   * Model directmediaitem
   */

  export type AggregateDirectmediaitem = {
    _count: DirectmediaitemCountAggregateOutputType | null
    _min: DirectmediaitemMinAggregateOutputType | null
    _max: DirectmediaitemMaxAggregateOutputType | null
  }

  export type DirectmediaitemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    mediaType: $Enums.directmediaitem_mediaType | null
    category: string | null
    uploadDate: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    updatedAt: Date | null
  }

  export type DirectmediaitemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    url: string | null
    mediaType: $Enums.directmediaitem_mediaType | null
    category: string | null
    uploadDate: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    updatedAt: Date | null
  }

  export type DirectmediaitemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    mediaType: number
    category: number
    tags: number
    uploadDate: number
    postedByOwnerId: number
    postedByOwnerName: number
    updatedAt: number
    _all: number
  }


  export type DirectmediaitemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    mediaType?: true
    category?: true
    uploadDate?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    updatedAt?: true
  }

  export type DirectmediaitemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    mediaType?: true
    category?: true
    uploadDate?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    updatedAt?: true
  }

  export type DirectmediaitemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    mediaType?: true
    category?: true
    tags?: true
    uploadDate?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    updatedAt?: true
    _all?: true
  }

  export type DirectmediaitemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which directmediaitem to aggregate.
     */
    where?: directmediaitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of directmediaitems to fetch.
     */
    orderBy?: directmediaitemOrderByWithRelationInput | directmediaitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: directmediaitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` directmediaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` directmediaitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned directmediaitems
    **/
    _count?: true | DirectmediaitemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectmediaitemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectmediaitemMaxAggregateInputType
  }

  export type GetDirectmediaitemAggregateType<T extends DirectmediaitemAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectmediaitem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectmediaitem[P]>
      : GetScalarType<T[P], AggregateDirectmediaitem[P]>
  }




  export type directmediaitemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: directmediaitemWhereInput
    orderBy?: directmediaitemOrderByWithAggregationInput | directmediaitemOrderByWithAggregationInput[]
    by: DirectmediaitemScalarFieldEnum[] | DirectmediaitemScalarFieldEnum
    having?: directmediaitemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectmediaitemCountAggregateInputType | true
    _min?: DirectmediaitemMinAggregateInputType
    _max?: DirectmediaitemMaxAggregateInputType
  }

  export type DirectmediaitemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    url: string
    mediaType: $Enums.directmediaitem_mediaType
    category: string | null
    tags: JsonValue | null
    uploadDate: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    updatedAt: Date
    _count: DirectmediaitemCountAggregateOutputType | null
    _min: DirectmediaitemMinAggregateOutputType | null
    _max: DirectmediaitemMaxAggregateOutputType | null
  }

  type GetDirectmediaitemGroupByPayload<T extends directmediaitemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectmediaitemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectmediaitemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectmediaitemGroupByOutputType[P]>
            : GetScalarType<T[P], DirectmediaitemGroupByOutputType[P]>
        }
      >
    >


  export type directmediaitemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    mediaType?: boolean
    category?: boolean
    tags?: boolean
    uploadDate?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["directmediaitem"]>


  export type directmediaitemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    mediaType?: boolean
    category?: boolean
    tags?: boolean
    uploadDate?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    updatedAt?: boolean
  }


  export type $directmediaitemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "directmediaitem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      url: string
      mediaType: $Enums.directmediaitem_mediaType
      category: string | null
      tags: Prisma.JsonValue | null
      uploadDate: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      updatedAt: Date
    }, ExtArgs["result"]["directmediaitem"]>
    composites: {}
  }

  type directmediaitemGetPayload<S extends boolean | null | undefined | directmediaitemDefaultArgs> = $Result.GetResult<Prisma.$directmediaitemPayload, S>

  type directmediaitemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<directmediaitemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DirectmediaitemCountAggregateInputType | true
    }

  export interface directmediaitemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['directmediaitem'], meta: { name: 'directmediaitem' } }
    /**
     * Find zero or one Directmediaitem that matches the filter.
     * @param {directmediaitemFindUniqueArgs} args - Arguments to find a Directmediaitem
     * @example
     * // Get one Directmediaitem
     * const directmediaitem = await prisma.directmediaitem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends directmediaitemFindUniqueArgs>(args: SelectSubset<T, directmediaitemFindUniqueArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Directmediaitem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {directmediaitemFindUniqueOrThrowArgs} args - Arguments to find a Directmediaitem
     * @example
     * // Get one Directmediaitem
     * const directmediaitem = await prisma.directmediaitem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends directmediaitemFindUniqueOrThrowArgs>(args: SelectSubset<T, directmediaitemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Directmediaitem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directmediaitemFindFirstArgs} args - Arguments to find a Directmediaitem
     * @example
     * // Get one Directmediaitem
     * const directmediaitem = await prisma.directmediaitem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends directmediaitemFindFirstArgs>(args?: SelectSubset<T, directmediaitemFindFirstArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Directmediaitem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directmediaitemFindFirstOrThrowArgs} args - Arguments to find a Directmediaitem
     * @example
     * // Get one Directmediaitem
     * const directmediaitem = await prisma.directmediaitem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends directmediaitemFindFirstOrThrowArgs>(args?: SelectSubset<T, directmediaitemFindFirstOrThrowArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Directmediaitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directmediaitemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Directmediaitems
     * const directmediaitems = await prisma.directmediaitem.findMany()
     * 
     * // Get first 10 Directmediaitems
     * const directmediaitems = await prisma.directmediaitem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directmediaitemWithIdOnly = await prisma.directmediaitem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends directmediaitemFindManyArgs>(args?: SelectSubset<T, directmediaitemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Directmediaitem.
     * @param {directmediaitemCreateArgs} args - Arguments to create a Directmediaitem.
     * @example
     * // Create one Directmediaitem
     * const Directmediaitem = await prisma.directmediaitem.create({
     *   data: {
     *     // ... data to create a Directmediaitem
     *   }
     * })
     * 
     */
    create<T extends directmediaitemCreateArgs>(args: SelectSubset<T, directmediaitemCreateArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Directmediaitems.
     * @param {directmediaitemCreateManyArgs} args - Arguments to create many Directmediaitems.
     * @example
     * // Create many Directmediaitems
     * const directmediaitem = await prisma.directmediaitem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends directmediaitemCreateManyArgs>(args?: SelectSubset<T, directmediaitemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Directmediaitem.
     * @param {directmediaitemDeleteArgs} args - Arguments to delete one Directmediaitem.
     * @example
     * // Delete one Directmediaitem
     * const Directmediaitem = await prisma.directmediaitem.delete({
     *   where: {
     *     // ... filter to delete one Directmediaitem
     *   }
     * })
     * 
     */
    delete<T extends directmediaitemDeleteArgs>(args: SelectSubset<T, directmediaitemDeleteArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Directmediaitem.
     * @param {directmediaitemUpdateArgs} args - Arguments to update one Directmediaitem.
     * @example
     * // Update one Directmediaitem
     * const directmediaitem = await prisma.directmediaitem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends directmediaitemUpdateArgs>(args: SelectSubset<T, directmediaitemUpdateArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Directmediaitems.
     * @param {directmediaitemDeleteManyArgs} args - Arguments to filter Directmediaitems to delete.
     * @example
     * // Delete a few Directmediaitems
     * const { count } = await prisma.directmediaitem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends directmediaitemDeleteManyArgs>(args?: SelectSubset<T, directmediaitemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Directmediaitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directmediaitemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Directmediaitems
     * const directmediaitem = await prisma.directmediaitem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends directmediaitemUpdateManyArgs>(args: SelectSubset<T, directmediaitemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Directmediaitem.
     * @param {directmediaitemUpsertArgs} args - Arguments to update or create a Directmediaitem.
     * @example
     * // Update or create a Directmediaitem
     * const directmediaitem = await prisma.directmediaitem.upsert({
     *   create: {
     *     // ... data to create a Directmediaitem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Directmediaitem we want to update
     *   }
     * })
     */
    upsert<T extends directmediaitemUpsertArgs>(args: SelectSubset<T, directmediaitemUpsertArgs<ExtArgs>>): Prisma__directmediaitemClient<$Result.GetResult<Prisma.$directmediaitemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Directmediaitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directmediaitemCountArgs} args - Arguments to filter Directmediaitems to count.
     * @example
     * // Count the number of Directmediaitems
     * const count = await prisma.directmediaitem.count({
     *   where: {
     *     // ... the filter for the Directmediaitems we want to count
     *   }
     * })
    **/
    count<T extends directmediaitemCountArgs>(
      args?: Subset<T, directmediaitemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectmediaitemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Directmediaitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectmediaitemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectmediaitemAggregateArgs>(args: Subset<T, DirectmediaitemAggregateArgs>): Prisma.PrismaPromise<GetDirectmediaitemAggregateType<T>>

    /**
     * Group by Directmediaitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {directmediaitemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends directmediaitemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: directmediaitemGroupByArgs['orderBy'] }
        : { orderBy?: directmediaitemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, directmediaitemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectmediaitemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the directmediaitem model
   */
  readonly fields: directmediaitemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for directmediaitem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__directmediaitemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the directmediaitem model
   */ 
  interface directmediaitemFieldRefs {
    readonly id: FieldRef<"directmediaitem", 'String'>
    readonly title: FieldRef<"directmediaitem", 'String'>
    readonly description: FieldRef<"directmediaitem", 'String'>
    readonly url: FieldRef<"directmediaitem", 'String'>
    readonly mediaType: FieldRef<"directmediaitem", 'directmediaitem_mediaType'>
    readonly category: FieldRef<"directmediaitem", 'String'>
    readonly tags: FieldRef<"directmediaitem", 'Json'>
    readonly uploadDate: FieldRef<"directmediaitem", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"directmediaitem", 'String'>
    readonly postedByOwnerName: FieldRef<"directmediaitem", 'String'>
    readonly updatedAt: FieldRef<"directmediaitem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * directmediaitem findUnique
   */
  export type directmediaitemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * Filter, which directmediaitem to fetch.
     */
    where: directmediaitemWhereUniqueInput
  }

  /**
   * directmediaitem findUniqueOrThrow
   */
  export type directmediaitemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * Filter, which directmediaitem to fetch.
     */
    where: directmediaitemWhereUniqueInput
  }

  /**
   * directmediaitem findFirst
   */
  export type directmediaitemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * Filter, which directmediaitem to fetch.
     */
    where?: directmediaitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of directmediaitems to fetch.
     */
    orderBy?: directmediaitemOrderByWithRelationInput | directmediaitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for directmediaitems.
     */
    cursor?: directmediaitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` directmediaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` directmediaitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of directmediaitems.
     */
    distinct?: DirectmediaitemScalarFieldEnum | DirectmediaitemScalarFieldEnum[]
  }

  /**
   * directmediaitem findFirstOrThrow
   */
  export type directmediaitemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * Filter, which directmediaitem to fetch.
     */
    where?: directmediaitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of directmediaitems to fetch.
     */
    orderBy?: directmediaitemOrderByWithRelationInput | directmediaitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for directmediaitems.
     */
    cursor?: directmediaitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` directmediaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` directmediaitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of directmediaitems.
     */
    distinct?: DirectmediaitemScalarFieldEnum | DirectmediaitemScalarFieldEnum[]
  }

  /**
   * directmediaitem findMany
   */
  export type directmediaitemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * Filter, which directmediaitems to fetch.
     */
    where?: directmediaitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of directmediaitems to fetch.
     */
    orderBy?: directmediaitemOrderByWithRelationInput | directmediaitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing directmediaitems.
     */
    cursor?: directmediaitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` directmediaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` directmediaitems.
     */
    skip?: number
    distinct?: DirectmediaitemScalarFieldEnum | DirectmediaitemScalarFieldEnum[]
  }

  /**
   * directmediaitem create
   */
  export type directmediaitemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * The data needed to create a directmediaitem.
     */
    data: XOR<directmediaitemCreateInput, directmediaitemUncheckedCreateInput>
  }

  /**
   * directmediaitem createMany
   */
  export type directmediaitemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many directmediaitems.
     */
    data: directmediaitemCreateManyInput | directmediaitemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * directmediaitem update
   */
  export type directmediaitemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * The data needed to update a directmediaitem.
     */
    data: XOR<directmediaitemUpdateInput, directmediaitemUncheckedUpdateInput>
    /**
     * Choose, which directmediaitem to update.
     */
    where: directmediaitemWhereUniqueInput
  }

  /**
   * directmediaitem updateMany
   */
  export type directmediaitemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update directmediaitems.
     */
    data: XOR<directmediaitemUpdateManyMutationInput, directmediaitemUncheckedUpdateManyInput>
    /**
     * Filter which directmediaitems to update
     */
    where?: directmediaitemWhereInput
  }

  /**
   * directmediaitem upsert
   */
  export type directmediaitemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * The filter to search for the directmediaitem to update in case it exists.
     */
    where: directmediaitemWhereUniqueInput
    /**
     * In case the directmediaitem found by the `where` argument doesn't exist, create a new directmediaitem with this data.
     */
    create: XOR<directmediaitemCreateInput, directmediaitemUncheckedCreateInput>
    /**
     * In case the directmediaitem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<directmediaitemUpdateInput, directmediaitemUncheckedUpdateInput>
  }

  /**
   * directmediaitem delete
   */
  export type directmediaitemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
    /**
     * Filter which directmediaitem to delete.
     */
    where: directmediaitemWhereUniqueInput
  }

  /**
   * directmediaitem deleteMany
   */
  export type directmediaitemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which directmediaitems to delete
     */
    where?: directmediaitemWhereInput
  }

  /**
   * directmediaitem without action
   */
  export type directmediaitemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the directmediaitem
     */
    select?: directmediaitemSelect<ExtArgs> | null
  }


  /**
   * Model donatepagecontent
   */

  export type AggregateDonatepagecontent = {
    _count: DonatepagecontentCountAggregateOutputType | null
    _min: DonatepagecontentMinAggregateOutputType | null
    _max: DonatepagecontentMaxAggregateOutputType | null
  }

  export type DonatepagecontentMinAggregateOutputType = {
    id: string | null
    headerTitle: string | null
    headerSubtitle: string | null
    headerImageUrl: string | null
    localDonationsTitle: string | null
    bankName: string | null
    accountName: string | null
    accountNumber: string | null
    branch: string | null
    bankQrImageUrl: string | null
    eSewaId: string | null
    eSewaQrImageUrl: string | null
    localDonationsNote: string | null
    internationalDonationsTitle: string | null
    internationalDonationsContent: string | null
    internationalDonationsContactEmail: string | null
    internationalQrImageUrl: string | null
    receiptVerses: string | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type DonatepagecontentMaxAggregateOutputType = {
    id: string | null
    headerTitle: string | null
    headerSubtitle: string | null
    headerImageUrl: string | null
    localDonationsTitle: string | null
    bankName: string | null
    accountName: string | null
    accountNumber: string | null
    branch: string | null
    bankQrImageUrl: string | null
    eSewaId: string | null
    eSewaQrImageUrl: string | null
    localDonationsNote: string | null
    internationalDonationsTitle: string | null
    internationalDonationsContent: string | null
    internationalDonationsContactEmail: string | null
    internationalQrImageUrl: string | null
    receiptVerses: string | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type DonatepagecontentCountAggregateOutputType = {
    id: number
    headerTitle: number
    headerSubtitle: number
    headerImageUrl: number
    localDonationsTitle: number
    bankName: number
    accountName: number
    accountNumber: number
    branch: number
    bankQrImageUrl: number
    eSewaId: number
    eSewaQrImageUrl: number
    localDonationsNote: number
    internationalDonationsTitle: number
    internationalDonationsContent: number
    internationalDonationsContactEmail: number
    internationalQrImageUrl: number
    receiptVerses: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    _all: number
  }


  export type DonatepagecontentMinAggregateInputType = {
    id?: true
    headerTitle?: true
    headerSubtitle?: true
    headerImageUrl?: true
    localDonationsTitle?: true
    bankName?: true
    accountName?: true
    accountNumber?: true
    branch?: true
    bankQrImageUrl?: true
    eSewaId?: true
    eSewaQrImageUrl?: true
    localDonationsNote?: true
    internationalDonationsTitle?: true
    internationalDonationsContent?: true
    internationalDonationsContactEmail?: true
    internationalQrImageUrl?: true
    receiptVerses?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type DonatepagecontentMaxAggregateInputType = {
    id?: true
    headerTitle?: true
    headerSubtitle?: true
    headerImageUrl?: true
    localDonationsTitle?: true
    bankName?: true
    accountName?: true
    accountNumber?: true
    branch?: true
    bankQrImageUrl?: true
    eSewaId?: true
    eSewaQrImageUrl?: true
    localDonationsNote?: true
    internationalDonationsTitle?: true
    internationalDonationsContent?: true
    internationalDonationsContactEmail?: true
    internationalQrImageUrl?: true
    receiptVerses?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type DonatepagecontentCountAggregateInputType = {
    id?: true
    headerTitle?: true
    headerSubtitle?: true
    headerImageUrl?: true
    localDonationsTitle?: true
    bankName?: true
    accountName?: true
    accountNumber?: true
    branch?: true
    bankQrImageUrl?: true
    eSewaId?: true
    eSewaQrImageUrl?: true
    localDonationsNote?: true
    internationalDonationsTitle?: true
    internationalDonationsContent?: true
    internationalDonationsContactEmail?: true
    internationalQrImageUrl?: true
    receiptVerses?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    _all?: true
  }

  export type DonatepagecontentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donatepagecontent to aggregate.
     */
    where?: donatepagecontentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donatepagecontents to fetch.
     */
    orderBy?: donatepagecontentOrderByWithRelationInput | donatepagecontentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: donatepagecontentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donatepagecontents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donatepagecontents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned donatepagecontents
    **/
    _count?: true | DonatepagecontentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonatepagecontentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonatepagecontentMaxAggregateInputType
  }

  export type GetDonatepagecontentAggregateType<T extends DonatepagecontentAggregateArgs> = {
        [P in keyof T & keyof AggregateDonatepagecontent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonatepagecontent[P]>
      : GetScalarType<T[P], AggregateDonatepagecontent[P]>
  }




  export type donatepagecontentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: donatepagecontentWhereInput
    orderBy?: donatepagecontentOrderByWithAggregationInput | donatepagecontentOrderByWithAggregationInput[]
    by: DonatepagecontentScalarFieldEnum[] | DonatepagecontentScalarFieldEnum
    having?: donatepagecontentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonatepagecontentCountAggregateInputType | true
    _min?: DonatepagecontentMinAggregateInputType
    _max?: DonatepagecontentMaxAggregateInputType
  }

  export type DonatepagecontentGroupByOutputType = {
    id: string
    headerTitle: string
    headerSubtitle: string
    headerImageUrl: string
    localDonationsTitle: string
    bankName: string
    accountName: string
    accountNumber: string
    branch: string
    bankQrImageUrl: string | null
    eSewaId: string
    eSewaQrImageUrl: string | null
    localDonationsNote: string
    internationalDonationsTitle: string
    internationalDonationsContent: string
    internationalDonationsContactEmail: string
    internationalQrImageUrl: string | null
    receiptVerses: string | null
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    _count: DonatepagecontentCountAggregateOutputType | null
    _min: DonatepagecontentMinAggregateOutputType | null
    _max: DonatepagecontentMaxAggregateOutputType | null
  }

  type GetDonatepagecontentGroupByPayload<T extends donatepagecontentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonatepagecontentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonatepagecontentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonatepagecontentGroupByOutputType[P]>
            : GetScalarType<T[P], DonatepagecontentGroupByOutputType[P]>
        }
      >
    >


  export type donatepagecontentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    headerTitle?: boolean
    headerSubtitle?: boolean
    headerImageUrl?: boolean
    localDonationsTitle?: boolean
    bankName?: boolean
    accountName?: boolean
    accountNumber?: boolean
    branch?: boolean
    bankQrImageUrl?: boolean
    eSewaId?: boolean
    eSewaQrImageUrl?: boolean
    localDonationsNote?: boolean
    internationalDonationsTitle?: boolean
    internationalDonationsContent?: boolean
    internationalDonationsContactEmail?: boolean
    internationalQrImageUrl?: boolean
    receiptVerses?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }, ExtArgs["result"]["donatepagecontent"]>


  export type donatepagecontentSelectScalar = {
    id?: boolean
    headerTitle?: boolean
    headerSubtitle?: boolean
    headerImageUrl?: boolean
    localDonationsTitle?: boolean
    bankName?: boolean
    accountName?: boolean
    accountNumber?: boolean
    branch?: boolean
    bankQrImageUrl?: boolean
    eSewaId?: boolean
    eSewaQrImageUrl?: boolean
    localDonationsNote?: boolean
    internationalDonationsTitle?: boolean
    internationalDonationsContent?: boolean
    internationalDonationsContactEmail?: boolean
    internationalQrImageUrl?: boolean
    receiptVerses?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }


  export type $donatepagecontentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "donatepagecontent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      headerTitle: string
      headerSubtitle: string
      headerImageUrl: string
      localDonationsTitle: string
      bankName: string
      accountName: string
      accountNumber: string
      branch: string
      bankQrImageUrl: string | null
      eSewaId: string
      eSewaQrImageUrl: string | null
      localDonationsNote: string
      internationalDonationsTitle: string
      internationalDonationsContent: string
      internationalDonationsContactEmail: string
      internationalQrImageUrl: string | null
      receiptVerses: string | null
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
    }, ExtArgs["result"]["donatepagecontent"]>
    composites: {}
  }

  type donatepagecontentGetPayload<S extends boolean | null | undefined | donatepagecontentDefaultArgs> = $Result.GetResult<Prisma.$donatepagecontentPayload, S>

  type donatepagecontentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<donatepagecontentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DonatepagecontentCountAggregateInputType | true
    }

  export interface donatepagecontentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['donatepagecontent'], meta: { name: 'donatepagecontent' } }
    /**
     * Find zero or one Donatepagecontent that matches the filter.
     * @param {donatepagecontentFindUniqueArgs} args - Arguments to find a Donatepagecontent
     * @example
     * // Get one Donatepagecontent
     * const donatepagecontent = await prisma.donatepagecontent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends donatepagecontentFindUniqueArgs>(args: SelectSubset<T, donatepagecontentFindUniqueArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Donatepagecontent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {donatepagecontentFindUniqueOrThrowArgs} args - Arguments to find a Donatepagecontent
     * @example
     * // Get one Donatepagecontent
     * const donatepagecontent = await prisma.donatepagecontent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends donatepagecontentFindUniqueOrThrowArgs>(args: SelectSubset<T, donatepagecontentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Donatepagecontent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donatepagecontentFindFirstArgs} args - Arguments to find a Donatepagecontent
     * @example
     * // Get one Donatepagecontent
     * const donatepagecontent = await prisma.donatepagecontent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends donatepagecontentFindFirstArgs>(args?: SelectSubset<T, donatepagecontentFindFirstArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Donatepagecontent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donatepagecontentFindFirstOrThrowArgs} args - Arguments to find a Donatepagecontent
     * @example
     * // Get one Donatepagecontent
     * const donatepagecontent = await prisma.donatepagecontent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends donatepagecontentFindFirstOrThrowArgs>(args?: SelectSubset<T, donatepagecontentFindFirstOrThrowArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Donatepagecontents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donatepagecontentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donatepagecontents
     * const donatepagecontents = await prisma.donatepagecontent.findMany()
     * 
     * // Get first 10 Donatepagecontents
     * const donatepagecontents = await prisma.donatepagecontent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donatepagecontentWithIdOnly = await prisma.donatepagecontent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends donatepagecontentFindManyArgs>(args?: SelectSubset<T, donatepagecontentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Donatepagecontent.
     * @param {donatepagecontentCreateArgs} args - Arguments to create a Donatepagecontent.
     * @example
     * // Create one Donatepagecontent
     * const Donatepagecontent = await prisma.donatepagecontent.create({
     *   data: {
     *     // ... data to create a Donatepagecontent
     *   }
     * })
     * 
     */
    create<T extends donatepagecontentCreateArgs>(args: SelectSubset<T, donatepagecontentCreateArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Donatepagecontents.
     * @param {donatepagecontentCreateManyArgs} args - Arguments to create many Donatepagecontents.
     * @example
     * // Create many Donatepagecontents
     * const donatepagecontent = await prisma.donatepagecontent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends donatepagecontentCreateManyArgs>(args?: SelectSubset<T, donatepagecontentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Donatepagecontent.
     * @param {donatepagecontentDeleteArgs} args - Arguments to delete one Donatepagecontent.
     * @example
     * // Delete one Donatepagecontent
     * const Donatepagecontent = await prisma.donatepagecontent.delete({
     *   where: {
     *     // ... filter to delete one Donatepagecontent
     *   }
     * })
     * 
     */
    delete<T extends donatepagecontentDeleteArgs>(args: SelectSubset<T, donatepagecontentDeleteArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Donatepagecontent.
     * @param {donatepagecontentUpdateArgs} args - Arguments to update one Donatepagecontent.
     * @example
     * // Update one Donatepagecontent
     * const donatepagecontent = await prisma.donatepagecontent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends donatepagecontentUpdateArgs>(args: SelectSubset<T, donatepagecontentUpdateArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Donatepagecontents.
     * @param {donatepagecontentDeleteManyArgs} args - Arguments to filter Donatepagecontents to delete.
     * @example
     * // Delete a few Donatepagecontents
     * const { count } = await prisma.donatepagecontent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends donatepagecontentDeleteManyArgs>(args?: SelectSubset<T, donatepagecontentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donatepagecontents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donatepagecontentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donatepagecontents
     * const donatepagecontent = await prisma.donatepagecontent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends donatepagecontentUpdateManyArgs>(args: SelectSubset<T, donatepagecontentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Donatepagecontent.
     * @param {donatepagecontentUpsertArgs} args - Arguments to update or create a Donatepagecontent.
     * @example
     * // Update or create a Donatepagecontent
     * const donatepagecontent = await prisma.donatepagecontent.upsert({
     *   create: {
     *     // ... data to create a Donatepagecontent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donatepagecontent we want to update
     *   }
     * })
     */
    upsert<T extends donatepagecontentUpsertArgs>(args: SelectSubset<T, donatepagecontentUpsertArgs<ExtArgs>>): Prisma__donatepagecontentClient<$Result.GetResult<Prisma.$donatepagecontentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Donatepagecontents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donatepagecontentCountArgs} args - Arguments to filter Donatepagecontents to count.
     * @example
     * // Count the number of Donatepagecontents
     * const count = await prisma.donatepagecontent.count({
     *   where: {
     *     // ... the filter for the Donatepagecontents we want to count
     *   }
     * })
    **/
    count<T extends donatepagecontentCountArgs>(
      args?: Subset<T, donatepagecontentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonatepagecontentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donatepagecontent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonatepagecontentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonatepagecontentAggregateArgs>(args: Subset<T, DonatepagecontentAggregateArgs>): Prisma.PrismaPromise<GetDonatepagecontentAggregateType<T>>

    /**
     * Group by Donatepagecontent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donatepagecontentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends donatepagecontentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: donatepagecontentGroupByArgs['orderBy'] }
        : { orderBy?: donatepagecontentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, donatepagecontentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonatepagecontentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the donatepagecontent model
   */
  readonly fields: donatepagecontentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for donatepagecontent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__donatepagecontentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the donatepagecontent model
   */ 
  interface donatepagecontentFieldRefs {
    readonly id: FieldRef<"donatepagecontent", 'String'>
    readonly headerTitle: FieldRef<"donatepagecontent", 'String'>
    readonly headerSubtitle: FieldRef<"donatepagecontent", 'String'>
    readonly headerImageUrl: FieldRef<"donatepagecontent", 'String'>
    readonly localDonationsTitle: FieldRef<"donatepagecontent", 'String'>
    readonly bankName: FieldRef<"donatepagecontent", 'String'>
    readonly accountName: FieldRef<"donatepagecontent", 'String'>
    readonly accountNumber: FieldRef<"donatepagecontent", 'String'>
    readonly branch: FieldRef<"donatepagecontent", 'String'>
    readonly bankQrImageUrl: FieldRef<"donatepagecontent", 'String'>
    readonly eSewaId: FieldRef<"donatepagecontent", 'String'>
    readonly eSewaQrImageUrl: FieldRef<"donatepagecontent", 'String'>
    readonly localDonationsNote: FieldRef<"donatepagecontent", 'String'>
    readonly internationalDonationsTitle: FieldRef<"donatepagecontent", 'String'>
    readonly internationalDonationsContent: FieldRef<"donatepagecontent", 'String'>
    readonly internationalDonationsContactEmail: FieldRef<"donatepagecontent", 'String'>
    readonly internationalQrImageUrl: FieldRef<"donatepagecontent", 'String'>
    readonly receiptVerses: FieldRef<"donatepagecontent", 'String'>
    readonly updatedAt: FieldRef<"donatepagecontent", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"donatepagecontent", 'String'>
    readonly postedByOwnerName: FieldRef<"donatepagecontent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * donatepagecontent findUnique
   */
  export type donatepagecontentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * Filter, which donatepagecontent to fetch.
     */
    where: donatepagecontentWhereUniqueInput
  }

  /**
   * donatepagecontent findUniqueOrThrow
   */
  export type donatepagecontentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * Filter, which donatepagecontent to fetch.
     */
    where: donatepagecontentWhereUniqueInput
  }

  /**
   * donatepagecontent findFirst
   */
  export type donatepagecontentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * Filter, which donatepagecontent to fetch.
     */
    where?: donatepagecontentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donatepagecontents to fetch.
     */
    orderBy?: donatepagecontentOrderByWithRelationInput | donatepagecontentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donatepagecontents.
     */
    cursor?: donatepagecontentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donatepagecontents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donatepagecontents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donatepagecontents.
     */
    distinct?: DonatepagecontentScalarFieldEnum | DonatepagecontentScalarFieldEnum[]
  }

  /**
   * donatepagecontent findFirstOrThrow
   */
  export type donatepagecontentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * Filter, which donatepagecontent to fetch.
     */
    where?: donatepagecontentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donatepagecontents to fetch.
     */
    orderBy?: donatepagecontentOrderByWithRelationInput | donatepagecontentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donatepagecontents.
     */
    cursor?: donatepagecontentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donatepagecontents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donatepagecontents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donatepagecontents.
     */
    distinct?: DonatepagecontentScalarFieldEnum | DonatepagecontentScalarFieldEnum[]
  }

  /**
   * donatepagecontent findMany
   */
  export type donatepagecontentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * Filter, which donatepagecontents to fetch.
     */
    where?: donatepagecontentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donatepagecontents to fetch.
     */
    orderBy?: donatepagecontentOrderByWithRelationInput | donatepagecontentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing donatepagecontents.
     */
    cursor?: donatepagecontentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donatepagecontents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donatepagecontents.
     */
    skip?: number
    distinct?: DonatepagecontentScalarFieldEnum | DonatepagecontentScalarFieldEnum[]
  }

  /**
   * donatepagecontent create
   */
  export type donatepagecontentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * The data needed to create a donatepagecontent.
     */
    data: XOR<donatepagecontentCreateInput, donatepagecontentUncheckedCreateInput>
  }

  /**
   * donatepagecontent createMany
   */
  export type donatepagecontentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many donatepagecontents.
     */
    data: donatepagecontentCreateManyInput | donatepagecontentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * donatepagecontent update
   */
  export type donatepagecontentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * The data needed to update a donatepagecontent.
     */
    data: XOR<donatepagecontentUpdateInput, donatepagecontentUncheckedUpdateInput>
    /**
     * Choose, which donatepagecontent to update.
     */
    where: donatepagecontentWhereUniqueInput
  }

  /**
   * donatepagecontent updateMany
   */
  export type donatepagecontentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update donatepagecontents.
     */
    data: XOR<donatepagecontentUpdateManyMutationInput, donatepagecontentUncheckedUpdateManyInput>
    /**
     * Filter which donatepagecontents to update
     */
    where?: donatepagecontentWhereInput
  }

  /**
   * donatepagecontent upsert
   */
  export type donatepagecontentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * The filter to search for the donatepagecontent to update in case it exists.
     */
    where: donatepagecontentWhereUniqueInput
    /**
     * In case the donatepagecontent found by the `where` argument doesn't exist, create a new donatepagecontent with this data.
     */
    create: XOR<donatepagecontentCreateInput, donatepagecontentUncheckedCreateInput>
    /**
     * In case the donatepagecontent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<donatepagecontentUpdateInput, donatepagecontentUncheckedUpdateInput>
  }

  /**
   * donatepagecontent delete
   */
  export type donatepagecontentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
    /**
     * Filter which donatepagecontent to delete.
     */
    where: donatepagecontentWhereUniqueInput
  }

  /**
   * donatepagecontent deleteMany
   */
  export type donatepagecontentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donatepagecontents to delete
     */
    where?: donatepagecontentWhereInput
  }

  /**
   * donatepagecontent without action
   */
  export type donatepagecontentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donatepagecontent
     */
    select?: donatepagecontentSelect<ExtArgs> | null
  }


  /**
   * Model donationrecord
   */

  export type AggregateDonationrecord = {
    _count: DonationrecordCountAggregateOutputType | null
    _avg: DonationrecordAvgAggregateOutputType | null
    _sum: DonationrecordSumAggregateOutputType | null
    _min: DonationrecordMinAggregateOutputType | null
    _max: DonationrecordMaxAggregateOutputType | null
  }

  export type DonationrecordAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type DonationrecordSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type DonationrecordMinAggregateOutputType = {
    id: string | null
    donorName: string | null
    donorEmail: string | null
    donorPhone: string | null
    amount: Decimal | null
    purpose: $Enums.donationrecord_purpose | null
    donationDate: Date | null
    transactionTimestamp: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentMethod: $Enums.donationrecord_paymentMethod | null
    transactionReference: string | null
    notes: string | null
    isReceiptSent: boolean | null
  }

  export type DonationrecordMaxAggregateOutputType = {
    id: string | null
    donorName: string | null
    donorEmail: string | null
    donorPhone: string | null
    amount: Decimal | null
    purpose: $Enums.donationrecord_purpose | null
    donationDate: Date | null
    transactionTimestamp: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paymentMethod: $Enums.donationrecord_paymentMethod | null
    transactionReference: string | null
    notes: string | null
    isReceiptSent: boolean | null
  }

  export type DonationrecordCountAggregateOutputType = {
    id: number
    donorName: number
    donorEmail: number
    donorPhone: number
    amount: number
    purpose: number
    donationDate: number
    transactionTimestamp: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    paymentMethod: number
    transactionReference: number
    notes: number
    isReceiptSent: number
    _all: number
  }


  export type DonationrecordAvgAggregateInputType = {
    amount?: true
  }

  export type DonationrecordSumAggregateInputType = {
    amount?: true
  }

  export type DonationrecordMinAggregateInputType = {
    id?: true
    donorName?: true
    donorEmail?: true
    donorPhone?: true
    amount?: true
    purpose?: true
    donationDate?: true
    transactionTimestamp?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    paymentMethod?: true
    transactionReference?: true
    notes?: true
    isReceiptSent?: true
  }

  export type DonationrecordMaxAggregateInputType = {
    id?: true
    donorName?: true
    donorEmail?: true
    donorPhone?: true
    amount?: true
    purpose?: true
    donationDate?: true
    transactionTimestamp?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    paymentMethod?: true
    transactionReference?: true
    notes?: true
    isReceiptSent?: true
  }

  export type DonationrecordCountAggregateInputType = {
    id?: true
    donorName?: true
    donorEmail?: true
    donorPhone?: true
    amount?: true
    purpose?: true
    donationDate?: true
    transactionTimestamp?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    paymentMethod?: true
    transactionReference?: true
    notes?: true
    isReceiptSent?: true
    _all?: true
  }

  export type DonationrecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donationrecord to aggregate.
     */
    where?: donationrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donationrecords to fetch.
     */
    orderBy?: donationrecordOrderByWithRelationInput | donationrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: donationrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donationrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donationrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned donationrecords
    **/
    _count?: true | DonationrecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationrecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationrecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationrecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationrecordMaxAggregateInputType
  }

  export type GetDonationrecordAggregateType<T extends DonationrecordAggregateArgs> = {
        [P in keyof T & keyof AggregateDonationrecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonationrecord[P]>
      : GetScalarType<T[P], AggregateDonationrecord[P]>
  }




  export type donationrecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: donationrecordWhereInput
    orderBy?: donationrecordOrderByWithAggregationInput | donationrecordOrderByWithAggregationInput[]
    by: DonationrecordScalarFieldEnum[] | DonationrecordScalarFieldEnum
    having?: donationrecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationrecordCountAggregateInputType | true
    _avg?: DonationrecordAvgAggregateInputType
    _sum?: DonationrecordSumAggregateInputType
    _min?: DonationrecordMinAggregateInputType
    _max?: DonationrecordMaxAggregateInputType
  }

  export type DonationrecordGroupByOutputType = {
    id: string
    donorName: string
    donorEmail: string
    donorPhone: string | null
    amount: Decimal
    purpose: $Enums.donationrecord_purpose
    donationDate: Date
    transactionTimestamp: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    paymentMethod: $Enums.donationrecord_paymentMethod | null
    transactionReference: string | null
    notes: string | null
    isReceiptSent: boolean
    _count: DonationrecordCountAggregateOutputType | null
    _avg: DonationrecordAvgAggregateOutputType | null
    _sum: DonationrecordSumAggregateOutputType | null
    _min: DonationrecordMinAggregateOutputType | null
    _max: DonationrecordMaxAggregateOutputType | null
  }

  type GetDonationrecordGroupByPayload<T extends donationrecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationrecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationrecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationrecordGroupByOutputType[P]>
            : GetScalarType<T[P], DonationrecordGroupByOutputType[P]>
        }
      >
    >


  export type donationrecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    donorName?: boolean
    donorEmail?: boolean
    donorPhone?: boolean
    amount?: boolean
    purpose?: boolean
    donationDate?: boolean
    transactionTimestamp?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentMethod?: boolean
    transactionReference?: boolean
    notes?: boolean
    isReceiptSent?: boolean
  }, ExtArgs["result"]["donationrecord"]>


  export type donationrecordSelectScalar = {
    id?: boolean
    donorName?: boolean
    donorEmail?: boolean
    donorPhone?: boolean
    amount?: boolean
    purpose?: boolean
    donationDate?: boolean
    transactionTimestamp?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentMethod?: boolean
    transactionReference?: boolean
    notes?: boolean
    isReceiptSent?: boolean
  }


  export type $donationrecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "donationrecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      donorName: string
      donorEmail: string
      donorPhone: string | null
      amount: Prisma.Decimal
      purpose: $Enums.donationrecord_purpose
      donationDate: Date
      transactionTimestamp: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      paymentMethod: $Enums.donationrecord_paymentMethod | null
      transactionReference: string | null
      notes: string | null
      isReceiptSent: boolean
    }, ExtArgs["result"]["donationrecord"]>
    composites: {}
  }

  type donationrecordGetPayload<S extends boolean | null | undefined | donationrecordDefaultArgs> = $Result.GetResult<Prisma.$donationrecordPayload, S>

  type donationrecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<donationrecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DonationrecordCountAggregateInputType | true
    }

  export interface donationrecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['donationrecord'], meta: { name: 'donationrecord' } }
    /**
     * Find zero or one Donationrecord that matches the filter.
     * @param {donationrecordFindUniqueArgs} args - Arguments to find a Donationrecord
     * @example
     * // Get one Donationrecord
     * const donationrecord = await prisma.donationrecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends donationrecordFindUniqueArgs>(args: SelectSubset<T, donationrecordFindUniqueArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Donationrecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {donationrecordFindUniqueOrThrowArgs} args - Arguments to find a Donationrecord
     * @example
     * // Get one Donationrecord
     * const donationrecord = await prisma.donationrecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends donationrecordFindUniqueOrThrowArgs>(args: SelectSubset<T, donationrecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Donationrecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationrecordFindFirstArgs} args - Arguments to find a Donationrecord
     * @example
     * // Get one Donationrecord
     * const donationrecord = await prisma.donationrecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends donationrecordFindFirstArgs>(args?: SelectSubset<T, donationrecordFindFirstArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Donationrecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationrecordFindFirstOrThrowArgs} args - Arguments to find a Donationrecord
     * @example
     * // Get one Donationrecord
     * const donationrecord = await prisma.donationrecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends donationrecordFindFirstOrThrowArgs>(args?: SelectSubset<T, donationrecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Donationrecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationrecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donationrecords
     * const donationrecords = await prisma.donationrecord.findMany()
     * 
     * // Get first 10 Donationrecords
     * const donationrecords = await prisma.donationrecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationrecordWithIdOnly = await prisma.donationrecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends donationrecordFindManyArgs>(args?: SelectSubset<T, donationrecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Donationrecord.
     * @param {donationrecordCreateArgs} args - Arguments to create a Donationrecord.
     * @example
     * // Create one Donationrecord
     * const Donationrecord = await prisma.donationrecord.create({
     *   data: {
     *     // ... data to create a Donationrecord
     *   }
     * })
     * 
     */
    create<T extends donationrecordCreateArgs>(args: SelectSubset<T, donationrecordCreateArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Donationrecords.
     * @param {donationrecordCreateManyArgs} args - Arguments to create many Donationrecords.
     * @example
     * // Create many Donationrecords
     * const donationrecord = await prisma.donationrecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends donationrecordCreateManyArgs>(args?: SelectSubset<T, donationrecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Donationrecord.
     * @param {donationrecordDeleteArgs} args - Arguments to delete one Donationrecord.
     * @example
     * // Delete one Donationrecord
     * const Donationrecord = await prisma.donationrecord.delete({
     *   where: {
     *     // ... filter to delete one Donationrecord
     *   }
     * })
     * 
     */
    delete<T extends donationrecordDeleteArgs>(args: SelectSubset<T, donationrecordDeleteArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Donationrecord.
     * @param {donationrecordUpdateArgs} args - Arguments to update one Donationrecord.
     * @example
     * // Update one Donationrecord
     * const donationrecord = await prisma.donationrecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends donationrecordUpdateArgs>(args: SelectSubset<T, donationrecordUpdateArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Donationrecords.
     * @param {donationrecordDeleteManyArgs} args - Arguments to filter Donationrecords to delete.
     * @example
     * // Delete a few Donationrecords
     * const { count } = await prisma.donationrecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends donationrecordDeleteManyArgs>(args?: SelectSubset<T, donationrecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donationrecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationrecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donationrecords
     * const donationrecord = await prisma.donationrecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends donationrecordUpdateManyArgs>(args: SelectSubset<T, donationrecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Donationrecord.
     * @param {donationrecordUpsertArgs} args - Arguments to update or create a Donationrecord.
     * @example
     * // Update or create a Donationrecord
     * const donationrecord = await prisma.donationrecord.upsert({
     *   create: {
     *     // ... data to create a Donationrecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donationrecord we want to update
     *   }
     * })
     */
    upsert<T extends donationrecordUpsertArgs>(args: SelectSubset<T, donationrecordUpsertArgs<ExtArgs>>): Prisma__donationrecordClient<$Result.GetResult<Prisma.$donationrecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Donationrecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationrecordCountArgs} args - Arguments to filter Donationrecords to count.
     * @example
     * // Count the number of Donationrecords
     * const count = await prisma.donationrecord.count({
     *   where: {
     *     // ... the filter for the Donationrecords we want to count
     *   }
     * })
    **/
    count<T extends donationrecordCountArgs>(
      args?: Subset<T, donationrecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationrecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donationrecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationrecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationrecordAggregateArgs>(args: Subset<T, DonationrecordAggregateArgs>): Prisma.PrismaPromise<GetDonationrecordAggregateType<T>>

    /**
     * Group by Donationrecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donationrecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends donationrecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: donationrecordGroupByArgs['orderBy'] }
        : { orderBy?: donationrecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, donationrecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationrecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the donationrecord model
   */
  readonly fields: donationrecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for donationrecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__donationrecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the donationrecord model
   */ 
  interface donationrecordFieldRefs {
    readonly id: FieldRef<"donationrecord", 'String'>
    readonly donorName: FieldRef<"donationrecord", 'String'>
    readonly donorEmail: FieldRef<"donationrecord", 'String'>
    readonly donorPhone: FieldRef<"donationrecord", 'String'>
    readonly amount: FieldRef<"donationrecord", 'Decimal'>
    readonly purpose: FieldRef<"donationrecord", 'donationrecord_purpose'>
    readonly donationDate: FieldRef<"donationrecord", 'DateTime'>
    readonly transactionTimestamp: FieldRef<"donationrecord", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"donationrecord", 'String'>
    readonly postedByOwnerName: FieldRef<"donationrecord", 'String'>
    readonly createdAt: FieldRef<"donationrecord", 'DateTime'>
    readonly updatedAt: FieldRef<"donationrecord", 'DateTime'>
    readonly paymentMethod: FieldRef<"donationrecord", 'donationrecord_paymentMethod'>
    readonly transactionReference: FieldRef<"donationrecord", 'String'>
    readonly notes: FieldRef<"donationrecord", 'String'>
    readonly isReceiptSent: FieldRef<"donationrecord", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * donationrecord findUnique
   */
  export type donationrecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * Filter, which donationrecord to fetch.
     */
    where: donationrecordWhereUniqueInput
  }

  /**
   * donationrecord findUniqueOrThrow
   */
  export type donationrecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * Filter, which donationrecord to fetch.
     */
    where: donationrecordWhereUniqueInput
  }

  /**
   * donationrecord findFirst
   */
  export type donationrecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * Filter, which donationrecord to fetch.
     */
    where?: donationrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donationrecords to fetch.
     */
    orderBy?: donationrecordOrderByWithRelationInput | donationrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donationrecords.
     */
    cursor?: donationrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donationrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donationrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donationrecords.
     */
    distinct?: DonationrecordScalarFieldEnum | DonationrecordScalarFieldEnum[]
  }

  /**
   * donationrecord findFirstOrThrow
   */
  export type donationrecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * Filter, which donationrecord to fetch.
     */
    where?: donationrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donationrecords to fetch.
     */
    orderBy?: donationrecordOrderByWithRelationInput | donationrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donationrecords.
     */
    cursor?: donationrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donationrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donationrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donationrecords.
     */
    distinct?: DonationrecordScalarFieldEnum | DonationrecordScalarFieldEnum[]
  }

  /**
   * donationrecord findMany
   */
  export type donationrecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * Filter, which donationrecords to fetch.
     */
    where?: donationrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donationrecords to fetch.
     */
    orderBy?: donationrecordOrderByWithRelationInput | donationrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing donationrecords.
     */
    cursor?: donationrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donationrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donationrecords.
     */
    skip?: number
    distinct?: DonationrecordScalarFieldEnum | DonationrecordScalarFieldEnum[]
  }

  /**
   * donationrecord create
   */
  export type donationrecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * The data needed to create a donationrecord.
     */
    data: XOR<donationrecordCreateInput, donationrecordUncheckedCreateInput>
  }

  /**
   * donationrecord createMany
   */
  export type donationrecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many donationrecords.
     */
    data: donationrecordCreateManyInput | donationrecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * donationrecord update
   */
  export type donationrecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * The data needed to update a donationrecord.
     */
    data: XOR<donationrecordUpdateInput, donationrecordUncheckedUpdateInput>
    /**
     * Choose, which donationrecord to update.
     */
    where: donationrecordWhereUniqueInput
  }

  /**
   * donationrecord updateMany
   */
  export type donationrecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update donationrecords.
     */
    data: XOR<donationrecordUpdateManyMutationInput, donationrecordUncheckedUpdateManyInput>
    /**
     * Filter which donationrecords to update
     */
    where?: donationrecordWhereInput
  }

  /**
   * donationrecord upsert
   */
  export type donationrecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * The filter to search for the donationrecord to update in case it exists.
     */
    where: donationrecordWhereUniqueInput
    /**
     * In case the donationrecord found by the `where` argument doesn't exist, create a new donationrecord with this data.
     */
    create: XOR<donationrecordCreateInput, donationrecordUncheckedCreateInput>
    /**
     * In case the donationrecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<donationrecordUpdateInput, donationrecordUncheckedUpdateInput>
  }

  /**
   * donationrecord delete
   */
  export type donationrecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
    /**
     * Filter which donationrecord to delete.
     */
    where: donationrecordWhereUniqueInput
  }

  /**
   * donationrecord deleteMany
   */
  export type donationrecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donationrecords to delete
     */
    where?: donationrecordWhereInput
  }

  /**
   * donationrecord without action
   */
  export type donationrecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donationrecord
     */
    select?: donationrecordSelect<ExtArgs> | null
  }


  /**
   * Model donordetail
   */

  export type AggregateDonordetail = {
    _count: DonordetailCountAggregateOutputType | null
    _avg: DonordetailAvgAggregateOutputType | null
    _sum: DonordetailSumAggregateOutputType | null
    _min: DonordetailMinAggregateOutputType | null
    _max: DonordetailMaxAggregateOutputType | null
  }

  export type DonordetailAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type DonordetailSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type DonordetailMinAggregateOutputType = {
    id: string | null
    donorName: string | null
    amount: Decimal | null
    address: string | null
    contact: string | null
    collectionRecordId: string | null
  }

  export type DonordetailMaxAggregateOutputType = {
    id: string | null
    donorName: string | null
    amount: Decimal | null
    address: string | null
    contact: string | null
    collectionRecordId: string | null
  }

  export type DonordetailCountAggregateOutputType = {
    id: number
    donorName: number
    amount: number
    address: number
    contact: number
    collectionRecordId: number
    _all: number
  }


  export type DonordetailAvgAggregateInputType = {
    amount?: true
  }

  export type DonordetailSumAggregateInputType = {
    amount?: true
  }

  export type DonordetailMinAggregateInputType = {
    id?: true
    donorName?: true
    amount?: true
    address?: true
    contact?: true
    collectionRecordId?: true
  }

  export type DonordetailMaxAggregateInputType = {
    id?: true
    donorName?: true
    amount?: true
    address?: true
    contact?: true
    collectionRecordId?: true
  }

  export type DonordetailCountAggregateInputType = {
    id?: true
    donorName?: true
    amount?: true
    address?: true
    contact?: true
    collectionRecordId?: true
    _all?: true
  }

  export type DonordetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donordetail to aggregate.
     */
    where?: donordetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donordetails to fetch.
     */
    orderBy?: donordetailOrderByWithRelationInput | donordetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: donordetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donordetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donordetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned donordetails
    **/
    _count?: true | DonordetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonordetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonordetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonordetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonordetailMaxAggregateInputType
  }

  export type GetDonordetailAggregateType<T extends DonordetailAggregateArgs> = {
        [P in keyof T & keyof AggregateDonordetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonordetail[P]>
      : GetScalarType<T[P], AggregateDonordetail[P]>
  }




  export type donordetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: donordetailWhereInput
    orderBy?: donordetailOrderByWithAggregationInput | donordetailOrderByWithAggregationInput[]
    by: DonordetailScalarFieldEnum[] | DonordetailScalarFieldEnum
    having?: donordetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonordetailCountAggregateInputType | true
    _avg?: DonordetailAvgAggregateInputType
    _sum?: DonordetailSumAggregateInputType
    _min?: DonordetailMinAggregateInputType
    _max?: DonordetailMaxAggregateInputType
  }

  export type DonordetailGroupByOutputType = {
    id: string
    donorName: string
    amount: Decimal
    address: string | null
    contact: string | null
    collectionRecordId: string
    _count: DonordetailCountAggregateOutputType | null
    _avg: DonordetailAvgAggregateOutputType | null
    _sum: DonordetailSumAggregateOutputType | null
    _min: DonordetailMinAggregateOutputType | null
    _max: DonordetailMaxAggregateOutputType | null
  }

  type GetDonordetailGroupByPayload<T extends donordetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonordetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonordetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonordetailGroupByOutputType[P]>
            : GetScalarType<T[P], DonordetailGroupByOutputType[P]>
        }
      >
    >


  export type donordetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    donorName?: boolean
    amount?: boolean
    address?: boolean
    contact?: boolean
    collectionRecordId?: boolean
    collectionrecord?: boolean | collectionrecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donordetail"]>


  export type donordetailSelectScalar = {
    id?: boolean
    donorName?: boolean
    amount?: boolean
    address?: boolean
    contact?: boolean
    collectionRecordId?: boolean
  }

  export type donordetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collectionrecord?: boolean | collectionrecordDefaultArgs<ExtArgs>
  }

  export type $donordetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "donordetail"
    objects: {
      collectionrecord: Prisma.$collectionrecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      donorName: string
      amount: Prisma.Decimal
      address: string | null
      contact: string | null
      collectionRecordId: string
    }, ExtArgs["result"]["donordetail"]>
    composites: {}
  }

  type donordetailGetPayload<S extends boolean | null | undefined | donordetailDefaultArgs> = $Result.GetResult<Prisma.$donordetailPayload, S>

  type donordetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<donordetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DonordetailCountAggregateInputType | true
    }

  export interface donordetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['donordetail'], meta: { name: 'donordetail' } }
    /**
     * Find zero or one Donordetail that matches the filter.
     * @param {donordetailFindUniqueArgs} args - Arguments to find a Donordetail
     * @example
     * // Get one Donordetail
     * const donordetail = await prisma.donordetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends donordetailFindUniqueArgs>(args: SelectSubset<T, donordetailFindUniqueArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Donordetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {donordetailFindUniqueOrThrowArgs} args - Arguments to find a Donordetail
     * @example
     * // Get one Donordetail
     * const donordetail = await prisma.donordetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends donordetailFindUniqueOrThrowArgs>(args: SelectSubset<T, donordetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Donordetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donordetailFindFirstArgs} args - Arguments to find a Donordetail
     * @example
     * // Get one Donordetail
     * const donordetail = await prisma.donordetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends donordetailFindFirstArgs>(args?: SelectSubset<T, donordetailFindFirstArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Donordetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donordetailFindFirstOrThrowArgs} args - Arguments to find a Donordetail
     * @example
     * // Get one Donordetail
     * const donordetail = await prisma.donordetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends donordetailFindFirstOrThrowArgs>(args?: SelectSubset<T, donordetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Donordetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donordetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donordetails
     * const donordetails = await prisma.donordetail.findMany()
     * 
     * // Get first 10 Donordetails
     * const donordetails = await prisma.donordetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donordetailWithIdOnly = await prisma.donordetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends donordetailFindManyArgs>(args?: SelectSubset<T, donordetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Donordetail.
     * @param {donordetailCreateArgs} args - Arguments to create a Donordetail.
     * @example
     * // Create one Donordetail
     * const Donordetail = await prisma.donordetail.create({
     *   data: {
     *     // ... data to create a Donordetail
     *   }
     * })
     * 
     */
    create<T extends donordetailCreateArgs>(args: SelectSubset<T, donordetailCreateArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Donordetails.
     * @param {donordetailCreateManyArgs} args - Arguments to create many Donordetails.
     * @example
     * // Create many Donordetails
     * const donordetail = await prisma.donordetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends donordetailCreateManyArgs>(args?: SelectSubset<T, donordetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Donordetail.
     * @param {donordetailDeleteArgs} args - Arguments to delete one Donordetail.
     * @example
     * // Delete one Donordetail
     * const Donordetail = await prisma.donordetail.delete({
     *   where: {
     *     // ... filter to delete one Donordetail
     *   }
     * })
     * 
     */
    delete<T extends donordetailDeleteArgs>(args: SelectSubset<T, donordetailDeleteArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Donordetail.
     * @param {donordetailUpdateArgs} args - Arguments to update one Donordetail.
     * @example
     * // Update one Donordetail
     * const donordetail = await prisma.donordetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends donordetailUpdateArgs>(args: SelectSubset<T, donordetailUpdateArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Donordetails.
     * @param {donordetailDeleteManyArgs} args - Arguments to filter Donordetails to delete.
     * @example
     * // Delete a few Donordetails
     * const { count } = await prisma.donordetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends donordetailDeleteManyArgs>(args?: SelectSubset<T, donordetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donordetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donordetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donordetails
     * const donordetail = await prisma.donordetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends donordetailUpdateManyArgs>(args: SelectSubset<T, donordetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Donordetail.
     * @param {donordetailUpsertArgs} args - Arguments to update or create a Donordetail.
     * @example
     * // Update or create a Donordetail
     * const donordetail = await prisma.donordetail.upsert({
     *   create: {
     *     // ... data to create a Donordetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donordetail we want to update
     *   }
     * })
     */
    upsert<T extends donordetailUpsertArgs>(args: SelectSubset<T, donordetailUpsertArgs<ExtArgs>>): Prisma__donordetailClient<$Result.GetResult<Prisma.$donordetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Donordetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donordetailCountArgs} args - Arguments to filter Donordetails to count.
     * @example
     * // Count the number of Donordetails
     * const count = await prisma.donordetail.count({
     *   where: {
     *     // ... the filter for the Donordetails we want to count
     *   }
     * })
    **/
    count<T extends donordetailCountArgs>(
      args?: Subset<T, donordetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonordetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donordetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonordetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonordetailAggregateArgs>(args: Subset<T, DonordetailAggregateArgs>): Prisma.PrismaPromise<GetDonordetailAggregateType<T>>

    /**
     * Group by Donordetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {donordetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends donordetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: donordetailGroupByArgs['orderBy'] }
        : { orderBy?: donordetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, donordetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonordetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the donordetail model
   */
  readonly fields: donordetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for donordetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__donordetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collectionrecord<T extends collectionrecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, collectionrecordDefaultArgs<ExtArgs>>): Prisma__collectionrecordClient<$Result.GetResult<Prisma.$collectionrecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the donordetail model
   */ 
  interface donordetailFieldRefs {
    readonly id: FieldRef<"donordetail", 'String'>
    readonly donorName: FieldRef<"donordetail", 'String'>
    readonly amount: FieldRef<"donordetail", 'Decimal'>
    readonly address: FieldRef<"donordetail", 'String'>
    readonly contact: FieldRef<"donordetail", 'String'>
    readonly collectionRecordId: FieldRef<"donordetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * donordetail findUnique
   */
  export type donordetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * Filter, which donordetail to fetch.
     */
    where: donordetailWhereUniqueInput
  }

  /**
   * donordetail findUniqueOrThrow
   */
  export type donordetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * Filter, which donordetail to fetch.
     */
    where: donordetailWhereUniqueInput
  }

  /**
   * donordetail findFirst
   */
  export type donordetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * Filter, which donordetail to fetch.
     */
    where?: donordetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donordetails to fetch.
     */
    orderBy?: donordetailOrderByWithRelationInput | donordetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donordetails.
     */
    cursor?: donordetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donordetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donordetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donordetails.
     */
    distinct?: DonordetailScalarFieldEnum | DonordetailScalarFieldEnum[]
  }

  /**
   * donordetail findFirstOrThrow
   */
  export type donordetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * Filter, which donordetail to fetch.
     */
    where?: donordetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donordetails to fetch.
     */
    orderBy?: donordetailOrderByWithRelationInput | donordetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for donordetails.
     */
    cursor?: donordetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donordetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donordetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of donordetails.
     */
    distinct?: DonordetailScalarFieldEnum | DonordetailScalarFieldEnum[]
  }

  /**
   * donordetail findMany
   */
  export type donordetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * Filter, which donordetails to fetch.
     */
    where?: donordetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of donordetails to fetch.
     */
    orderBy?: donordetailOrderByWithRelationInput | donordetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing donordetails.
     */
    cursor?: donordetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` donordetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` donordetails.
     */
    skip?: number
    distinct?: DonordetailScalarFieldEnum | DonordetailScalarFieldEnum[]
  }

  /**
   * donordetail create
   */
  export type donordetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * The data needed to create a donordetail.
     */
    data: XOR<donordetailCreateInput, donordetailUncheckedCreateInput>
  }

  /**
   * donordetail createMany
   */
  export type donordetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many donordetails.
     */
    data: donordetailCreateManyInput | donordetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * donordetail update
   */
  export type donordetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * The data needed to update a donordetail.
     */
    data: XOR<donordetailUpdateInput, donordetailUncheckedUpdateInput>
    /**
     * Choose, which donordetail to update.
     */
    where: donordetailWhereUniqueInput
  }

  /**
   * donordetail updateMany
   */
  export type donordetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update donordetails.
     */
    data: XOR<donordetailUpdateManyMutationInput, donordetailUncheckedUpdateManyInput>
    /**
     * Filter which donordetails to update
     */
    where?: donordetailWhereInput
  }

  /**
   * donordetail upsert
   */
  export type donordetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * The filter to search for the donordetail to update in case it exists.
     */
    where: donordetailWhereUniqueInput
    /**
     * In case the donordetail found by the `where` argument doesn't exist, create a new donordetail with this data.
     */
    create: XOR<donordetailCreateInput, donordetailUncheckedCreateInput>
    /**
     * In case the donordetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<donordetailUpdateInput, donordetailUncheckedUpdateInput>
  }

  /**
   * donordetail delete
   */
  export type donordetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
    /**
     * Filter which donordetail to delete.
     */
    where: donordetailWhereUniqueInput
  }

  /**
   * donordetail deleteMany
   */
  export type donordetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which donordetails to delete
     */
    where?: donordetailWhereInput
  }

  /**
   * donordetail without action
   */
  export type donordetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the donordetail
     */
    select?: donordetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: donordetailInclude<ExtArgs> | null
  }


  /**
   * Model eventitem
   */

  export type AggregateEventitem = {
    _count: EventitemCountAggregateOutputType | null
    _avg: EventitemAvgAggregateOutputType | null
    _sum: EventitemSumAggregateOutputType | null
    _min: EventitemMinAggregateOutputType | null
    _max: EventitemMaxAggregateOutputType | null
  }

  export type EventitemAvgAggregateOutputType = {
    capacity: number | null
    likes: number | null
  }

  export type EventitemSumAggregateOutputType = {
    capacity: number | null
    likes: number | null
  }

  export type EventitemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.eventitem_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    time: string | null
    expectations: string | null
    guests: string | null
    contactPerson: string | null
    contactEmail: string | null
    contactPhone: string | null
    registrationLink: string | null
    capacity: number | null
    isFeeRequired: boolean | null
    feeAmount: string | null
    videoUrl: string | null
    audioUrl: string | null
    likes: number | null
  }

  export type EventitemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.eventitem_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    time: string | null
    expectations: string | null
    guests: string | null
    contactPerson: string | null
    contactEmail: string | null
    contactPhone: string | null
    registrationLink: string | null
    capacity: number | null
    isFeeRequired: boolean | null
    feeAmount: string | null
    videoUrl: string | null
    audioUrl: string | null
    likes: number | null
  }

  export type EventitemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    linkPath: number
    category: number
    date: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    location: number
    time: number
    expectations: number
    guests: number
    contactPerson: number
    contactEmail: number
    contactPhone: number
    registrationLink: number
    capacity: number
    isFeeRequired: number
    feeAmount: number
    videoUrl: number
    audioUrl: number
    likes: number
    _all: number
  }


  export type EventitemAvgAggregateInputType = {
    capacity?: true
    likes?: true
  }

  export type EventitemSumAggregateInputType = {
    capacity?: true
    likes?: true
  }

  export type EventitemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    time?: true
    expectations?: true
    guests?: true
    contactPerson?: true
    contactEmail?: true
    contactPhone?: true
    registrationLink?: true
    capacity?: true
    isFeeRequired?: true
    feeAmount?: true
    videoUrl?: true
    audioUrl?: true
    likes?: true
  }

  export type EventitemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    time?: true
    expectations?: true
    guests?: true
    contactPerson?: true
    contactEmail?: true
    contactPhone?: true
    registrationLink?: true
    capacity?: true
    isFeeRequired?: true
    feeAmount?: true
    videoUrl?: true
    audioUrl?: true
    likes?: true
  }

  export type EventitemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    time?: true
    expectations?: true
    guests?: true
    contactPerson?: true
    contactEmail?: true
    contactPhone?: true
    registrationLink?: true
    capacity?: true
    isFeeRequired?: true
    feeAmount?: true
    videoUrl?: true
    audioUrl?: true
    likes?: true
    _all?: true
  }

  export type EventitemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventitem to aggregate.
     */
    where?: eventitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventitems to fetch.
     */
    orderBy?: eventitemOrderByWithRelationInput | eventitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: eventitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eventitems
    **/
    _count?: true | EventitemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventitemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventitemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventitemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventitemMaxAggregateInputType
  }

  export type GetEventitemAggregateType<T extends EventitemAggregateArgs> = {
        [P in keyof T & keyof AggregateEventitem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventitem[P]>
      : GetScalarType<T[P], AggregateEventitem[P]>
  }




  export type eventitemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: eventitemWhereInput
    orderBy?: eventitemOrderByWithAggregationInput | eventitemOrderByWithAggregationInput[]
    by: EventitemScalarFieldEnum[] | EventitemScalarFieldEnum
    having?: eventitemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventitemCountAggregateInputType | true
    _avg?: EventitemAvgAggregateInputType
    _sum?: EventitemSumAggregateInputType
    _min?: EventitemMinAggregateInputType
    _max?: EventitemMaxAggregateInputType
  }

  export type EventitemGroupByOutputType = {
    id: string
    title: string
    description: string
    imageUrl: string | null
    linkPath: string
    category: $Enums.eventitem_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    location: string | null
    time: string | null
    expectations: string | null
    guests: string | null
    contactPerson: string | null
    contactEmail: string | null
    contactPhone: string | null
    registrationLink: string | null
    capacity: number | null
    isFeeRequired: boolean
    feeAmount: string | null
    videoUrl: string | null
    audioUrl: string | null
    likes: number
    _count: EventitemCountAggregateOutputType | null
    _avg: EventitemAvgAggregateOutputType | null
    _sum: EventitemSumAggregateOutputType | null
    _min: EventitemMinAggregateOutputType | null
    _max: EventitemMaxAggregateOutputType | null
  }

  type GetEventitemGroupByPayload<T extends eventitemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventitemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventitemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventitemGroupByOutputType[P]>
            : GetScalarType<T[P], EventitemGroupByOutputType[P]>
        }
      >
    >


  export type eventitemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
    time?: boolean
    expectations?: boolean
    guests?: boolean
    contactPerson?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    registrationLink?: boolean
    capacity?: boolean
    isFeeRequired?: boolean
    feeAmount?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    likes?: boolean
    comment?: boolean | eventitem$commentArgs<ExtArgs>
    _count?: boolean | EventitemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventitem"]>


  export type eventitemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean
    time?: boolean
    expectations?: boolean
    guests?: boolean
    contactPerson?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    registrationLink?: boolean
    capacity?: boolean
    isFeeRequired?: boolean
    feeAmount?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    likes?: boolean
  }

  export type eventitemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | eventitem$commentArgs<ExtArgs>
    _count?: boolean | EventitemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $eventitemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "eventitem"
    objects: {
      comment: Prisma.$commentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      imageUrl: string | null
      linkPath: string
      category: $Enums.eventitem_category | null
      date: Date | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      location: string | null
      time: string | null
      expectations: string | null
      guests: string | null
      contactPerson: string | null
      contactEmail: string | null
      contactPhone: string | null
      registrationLink: string | null
      capacity: number | null
      isFeeRequired: boolean
      feeAmount: string | null
      videoUrl: string | null
      audioUrl: string | null
      likes: number
    }, ExtArgs["result"]["eventitem"]>
    composites: {}
  }

  type eventitemGetPayload<S extends boolean | null | undefined | eventitemDefaultArgs> = $Result.GetResult<Prisma.$eventitemPayload, S>

  type eventitemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<eventitemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventitemCountAggregateInputType | true
    }

  export interface eventitemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['eventitem'], meta: { name: 'eventitem' } }
    /**
     * Find zero or one Eventitem that matches the filter.
     * @param {eventitemFindUniqueArgs} args - Arguments to find a Eventitem
     * @example
     * // Get one Eventitem
     * const eventitem = await prisma.eventitem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventitemFindUniqueArgs>(args: SelectSubset<T, eventitemFindUniqueArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Eventitem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {eventitemFindUniqueOrThrowArgs} args - Arguments to find a Eventitem
     * @example
     * // Get one Eventitem
     * const eventitem = await prisma.eventitem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventitemFindUniqueOrThrowArgs>(args: SelectSubset<T, eventitemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Eventitem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventitemFindFirstArgs} args - Arguments to find a Eventitem
     * @example
     * // Get one Eventitem
     * const eventitem = await prisma.eventitem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventitemFindFirstArgs>(args?: SelectSubset<T, eventitemFindFirstArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Eventitem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventitemFindFirstOrThrowArgs} args - Arguments to find a Eventitem
     * @example
     * // Get one Eventitem
     * const eventitem = await prisma.eventitem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventitemFindFirstOrThrowArgs>(args?: SelectSubset<T, eventitemFindFirstOrThrowArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eventitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventitemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventitems
     * const eventitems = await prisma.eventitem.findMany()
     * 
     * // Get first 10 Eventitems
     * const eventitems = await prisma.eventitem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventitemWithIdOnly = await prisma.eventitem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends eventitemFindManyArgs>(args?: SelectSubset<T, eventitemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Eventitem.
     * @param {eventitemCreateArgs} args - Arguments to create a Eventitem.
     * @example
     * // Create one Eventitem
     * const Eventitem = await prisma.eventitem.create({
     *   data: {
     *     // ... data to create a Eventitem
     *   }
     * })
     * 
     */
    create<T extends eventitemCreateArgs>(args: SelectSubset<T, eventitemCreateArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eventitems.
     * @param {eventitemCreateManyArgs} args - Arguments to create many Eventitems.
     * @example
     * // Create many Eventitems
     * const eventitem = await prisma.eventitem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends eventitemCreateManyArgs>(args?: SelectSubset<T, eventitemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Eventitem.
     * @param {eventitemDeleteArgs} args - Arguments to delete one Eventitem.
     * @example
     * // Delete one Eventitem
     * const Eventitem = await prisma.eventitem.delete({
     *   where: {
     *     // ... filter to delete one Eventitem
     *   }
     * })
     * 
     */
    delete<T extends eventitemDeleteArgs>(args: SelectSubset<T, eventitemDeleteArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Eventitem.
     * @param {eventitemUpdateArgs} args - Arguments to update one Eventitem.
     * @example
     * // Update one Eventitem
     * const eventitem = await prisma.eventitem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends eventitemUpdateArgs>(args: SelectSubset<T, eventitemUpdateArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eventitems.
     * @param {eventitemDeleteManyArgs} args - Arguments to filter Eventitems to delete.
     * @example
     * // Delete a few Eventitems
     * const { count } = await prisma.eventitem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends eventitemDeleteManyArgs>(args?: SelectSubset<T, eventitemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventitemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventitems
     * const eventitem = await prisma.eventitem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends eventitemUpdateManyArgs>(args: SelectSubset<T, eventitemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Eventitem.
     * @param {eventitemUpsertArgs} args - Arguments to update or create a Eventitem.
     * @example
     * // Update or create a Eventitem
     * const eventitem = await prisma.eventitem.upsert({
     *   create: {
     *     // ... data to create a Eventitem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eventitem we want to update
     *   }
     * })
     */
    upsert<T extends eventitemUpsertArgs>(args: SelectSubset<T, eventitemUpsertArgs<ExtArgs>>): Prisma__eventitemClient<$Result.GetResult<Prisma.$eventitemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eventitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventitemCountArgs} args - Arguments to filter Eventitems to count.
     * @example
     * // Count the number of Eventitems
     * const count = await prisma.eventitem.count({
     *   where: {
     *     // ... the filter for the Eventitems we want to count
     *   }
     * })
    **/
    count<T extends eventitemCountArgs>(
      args?: Subset<T, eventitemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventitemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eventitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventitemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventitemAggregateArgs>(args: Subset<T, EventitemAggregateArgs>): Prisma.PrismaPromise<GetEventitemAggregateType<T>>

    /**
     * Group by Eventitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventitemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends eventitemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventitemGroupByArgs['orderBy'] }
        : { orderBy?: eventitemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, eventitemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventitemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the eventitem model
   */
  readonly fields: eventitemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for eventitem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventitemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends eventitem$commentArgs<ExtArgs> = {}>(args?: Subset<T, eventitem$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the eventitem model
   */ 
  interface eventitemFieldRefs {
    readonly id: FieldRef<"eventitem", 'String'>
    readonly title: FieldRef<"eventitem", 'String'>
    readonly description: FieldRef<"eventitem", 'String'>
    readonly imageUrl: FieldRef<"eventitem", 'String'>
    readonly linkPath: FieldRef<"eventitem", 'String'>
    readonly category: FieldRef<"eventitem", 'eventitem_category'>
    readonly date: FieldRef<"eventitem", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"eventitem", 'String'>
    readonly postedByOwnerName: FieldRef<"eventitem", 'String'>
    readonly createdAt: FieldRef<"eventitem", 'DateTime'>
    readonly updatedAt: FieldRef<"eventitem", 'DateTime'>
    readonly location: FieldRef<"eventitem", 'String'>
    readonly time: FieldRef<"eventitem", 'String'>
    readonly expectations: FieldRef<"eventitem", 'String'>
    readonly guests: FieldRef<"eventitem", 'String'>
    readonly contactPerson: FieldRef<"eventitem", 'String'>
    readonly contactEmail: FieldRef<"eventitem", 'String'>
    readonly contactPhone: FieldRef<"eventitem", 'String'>
    readonly registrationLink: FieldRef<"eventitem", 'String'>
    readonly capacity: FieldRef<"eventitem", 'Int'>
    readonly isFeeRequired: FieldRef<"eventitem", 'Boolean'>
    readonly feeAmount: FieldRef<"eventitem", 'String'>
    readonly videoUrl: FieldRef<"eventitem", 'String'>
    readonly audioUrl: FieldRef<"eventitem", 'String'>
    readonly likes: FieldRef<"eventitem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * eventitem findUnique
   */
  export type eventitemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * Filter, which eventitem to fetch.
     */
    where: eventitemWhereUniqueInput
  }

  /**
   * eventitem findUniqueOrThrow
   */
  export type eventitemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * Filter, which eventitem to fetch.
     */
    where: eventitemWhereUniqueInput
  }

  /**
   * eventitem findFirst
   */
  export type eventitemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * Filter, which eventitem to fetch.
     */
    where?: eventitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventitems to fetch.
     */
    orderBy?: eventitemOrderByWithRelationInput | eventitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventitems.
     */
    cursor?: eventitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventitems.
     */
    distinct?: EventitemScalarFieldEnum | EventitemScalarFieldEnum[]
  }

  /**
   * eventitem findFirstOrThrow
   */
  export type eventitemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * Filter, which eventitem to fetch.
     */
    where?: eventitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventitems to fetch.
     */
    orderBy?: eventitemOrderByWithRelationInput | eventitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eventitems.
     */
    cursor?: eventitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of eventitems.
     */
    distinct?: EventitemScalarFieldEnum | EventitemScalarFieldEnum[]
  }

  /**
   * eventitem findMany
   */
  export type eventitemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * Filter, which eventitems to fetch.
     */
    where?: eventitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of eventitems to fetch.
     */
    orderBy?: eventitemOrderByWithRelationInput | eventitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eventitems.
     */
    cursor?: eventitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eventitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eventitems.
     */
    skip?: number
    distinct?: EventitemScalarFieldEnum | EventitemScalarFieldEnum[]
  }

  /**
   * eventitem create
   */
  export type eventitemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * The data needed to create a eventitem.
     */
    data: XOR<eventitemCreateInput, eventitemUncheckedCreateInput>
  }

  /**
   * eventitem createMany
   */
  export type eventitemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many eventitems.
     */
    data: eventitemCreateManyInput | eventitemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * eventitem update
   */
  export type eventitemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * The data needed to update a eventitem.
     */
    data: XOR<eventitemUpdateInput, eventitemUncheckedUpdateInput>
    /**
     * Choose, which eventitem to update.
     */
    where: eventitemWhereUniqueInput
  }

  /**
   * eventitem updateMany
   */
  export type eventitemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update eventitems.
     */
    data: XOR<eventitemUpdateManyMutationInput, eventitemUncheckedUpdateManyInput>
    /**
     * Filter which eventitems to update
     */
    where?: eventitemWhereInput
  }

  /**
   * eventitem upsert
   */
  export type eventitemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * The filter to search for the eventitem to update in case it exists.
     */
    where: eventitemWhereUniqueInput
    /**
     * In case the eventitem found by the `where` argument doesn't exist, create a new eventitem with this data.
     */
    create: XOR<eventitemCreateInput, eventitemUncheckedCreateInput>
    /**
     * In case the eventitem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventitemUpdateInput, eventitemUncheckedUpdateInput>
  }

  /**
   * eventitem delete
   */
  export type eventitemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
    /**
     * Filter which eventitem to delete.
     */
    where: eventitemWhereUniqueInput
  }

  /**
   * eventitem deleteMany
   */
  export type eventitemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which eventitems to delete
     */
    where?: eventitemWhereInput
  }

  /**
   * eventitem.comment
   */
  export type eventitem$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * eventitem without action
   */
  export type eventitemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the eventitem
     */
    select?: eventitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventitemInclude<ExtArgs> | null
  }


  /**
   * Model expenserecord
   */

  export type AggregateExpenserecord = {
    _count: ExpenserecordCountAggregateOutputType | null
    _avg: ExpenserecordAvgAggregateOutputType | null
    _sum: ExpenserecordSumAggregateOutputType | null
    _min: ExpenserecordMinAggregateOutputType | null
    _max: ExpenserecordMaxAggregateOutputType | null
  }

  export type ExpenserecordAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenserecordSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type ExpenserecordMinAggregateOutputType = {
    id: string | null
    expenseDate: Date | null
    category: $Enums.expenserecord_category | null
    description: string | null
    amount: Decimal | null
    payee: string | null
    paymentMethod: $Enums.expenserecord_paymentMethod | null
    transactionReference: string | null
    receiptUrl: string | null
    approvedBy: string | null
    notes: string | null
    source: string | null
    location: string | null
    status: $Enums.expenserecord_status | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenserecordMaxAggregateOutputType = {
    id: string | null
    expenseDate: Date | null
    category: $Enums.expenserecord_category | null
    description: string | null
    amount: Decimal | null
    payee: string | null
    paymentMethod: $Enums.expenserecord_paymentMethod | null
    transactionReference: string | null
    receiptUrl: string | null
    approvedBy: string | null
    notes: string | null
    source: string | null
    location: string | null
    status: $Enums.expenserecord_status | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenserecordCountAggregateOutputType = {
    id: number
    expenseDate: number
    category: number
    description: number
    amount: number
    payee: number
    paymentMethod: number
    transactionReference: number
    receiptUrl: number
    approvedBy: number
    notes: number
    source: number
    location: number
    status: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenserecordAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenserecordSumAggregateInputType = {
    amount?: true
  }

  export type ExpenserecordMinAggregateInputType = {
    id?: true
    expenseDate?: true
    category?: true
    description?: true
    amount?: true
    payee?: true
    paymentMethod?: true
    transactionReference?: true
    receiptUrl?: true
    approvedBy?: true
    notes?: true
    source?: true
    location?: true
    status?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenserecordMaxAggregateInputType = {
    id?: true
    expenseDate?: true
    category?: true
    description?: true
    amount?: true
    payee?: true
    paymentMethod?: true
    transactionReference?: true
    receiptUrl?: true
    approvedBy?: true
    notes?: true
    source?: true
    location?: true
    status?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenserecordCountAggregateInputType = {
    id?: true
    expenseDate?: true
    category?: true
    description?: true
    amount?: true
    payee?: true
    paymentMethod?: true
    transactionReference?: true
    receiptUrl?: true
    approvedBy?: true
    notes?: true
    source?: true
    location?: true
    status?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenserecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which expenserecord to aggregate.
     */
    where?: expenserecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenserecords to fetch.
     */
    orderBy?: expenserecordOrderByWithRelationInput | expenserecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: expenserecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenserecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenserecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned expenserecords
    **/
    _count?: true | ExpenserecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenserecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenserecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenserecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenserecordMaxAggregateInputType
  }

  export type GetExpenserecordAggregateType<T extends ExpenserecordAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenserecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenserecord[P]>
      : GetScalarType<T[P], AggregateExpenserecord[P]>
  }




  export type expenserecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: expenserecordWhereInput
    orderBy?: expenserecordOrderByWithAggregationInput | expenserecordOrderByWithAggregationInput[]
    by: ExpenserecordScalarFieldEnum[] | ExpenserecordScalarFieldEnum
    having?: expenserecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenserecordCountAggregateInputType | true
    _avg?: ExpenserecordAvgAggregateInputType
    _sum?: ExpenserecordSumAggregateInputType
    _min?: ExpenserecordMinAggregateInputType
    _max?: ExpenserecordMaxAggregateInputType
  }

  export type ExpenserecordGroupByOutputType = {
    id: string
    expenseDate: Date
    category: $Enums.expenserecord_category
    description: string
    amount: Decimal
    payee: string | null
    paymentMethod: $Enums.expenserecord_paymentMethod | null
    transactionReference: string | null
    receiptUrl: string | null
    approvedBy: string | null
    notes: string | null
    source: string | null
    location: string | null
    status: $Enums.expenserecord_status | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExpenserecordCountAggregateOutputType | null
    _avg: ExpenserecordAvgAggregateOutputType | null
    _sum: ExpenserecordSumAggregateOutputType | null
    _min: ExpenserecordMinAggregateOutputType | null
    _max: ExpenserecordMaxAggregateOutputType | null
  }

  type GetExpenserecordGroupByPayload<T extends expenserecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenserecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenserecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenserecordGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenserecordGroupByOutputType[P]>
        }
      >
    >


  export type expenserecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expenseDate?: boolean
    category?: boolean
    description?: boolean
    amount?: boolean
    payee?: boolean
    paymentMethod?: boolean
    transactionReference?: boolean
    receiptUrl?: boolean
    approvedBy?: boolean
    notes?: boolean
    source?: boolean
    location?: boolean
    status?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expenserecord"]>


  export type expenserecordSelectScalar = {
    id?: boolean
    expenseDate?: boolean
    category?: boolean
    description?: boolean
    amount?: boolean
    payee?: boolean
    paymentMethod?: boolean
    transactionReference?: boolean
    receiptUrl?: boolean
    approvedBy?: boolean
    notes?: boolean
    source?: boolean
    location?: boolean
    status?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $expenserecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "expenserecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expenseDate: Date
      category: $Enums.expenserecord_category
      description: string
      amount: Prisma.Decimal
      payee: string | null
      paymentMethod: $Enums.expenserecord_paymentMethod | null
      transactionReference: string | null
      receiptUrl: string | null
      approvedBy: string | null
      notes: string | null
      source: string | null
      location: string | null
      status: $Enums.expenserecord_status | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expenserecord"]>
    composites: {}
  }

  type expenserecordGetPayload<S extends boolean | null | undefined | expenserecordDefaultArgs> = $Result.GetResult<Prisma.$expenserecordPayload, S>

  type expenserecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<expenserecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenserecordCountAggregateInputType | true
    }

  export interface expenserecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['expenserecord'], meta: { name: 'expenserecord' } }
    /**
     * Find zero or one Expenserecord that matches the filter.
     * @param {expenserecordFindUniqueArgs} args - Arguments to find a Expenserecord
     * @example
     * // Get one Expenserecord
     * const expenserecord = await prisma.expenserecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends expenserecordFindUniqueArgs>(args: SelectSubset<T, expenserecordFindUniqueArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expenserecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {expenserecordFindUniqueOrThrowArgs} args - Arguments to find a Expenserecord
     * @example
     * // Get one Expenserecord
     * const expenserecord = await prisma.expenserecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends expenserecordFindUniqueOrThrowArgs>(args: SelectSubset<T, expenserecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expenserecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenserecordFindFirstArgs} args - Arguments to find a Expenserecord
     * @example
     * // Get one Expenserecord
     * const expenserecord = await prisma.expenserecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends expenserecordFindFirstArgs>(args?: SelectSubset<T, expenserecordFindFirstArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expenserecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenserecordFindFirstOrThrowArgs} args - Arguments to find a Expenserecord
     * @example
     * // Get one Expenserecord
     * const expenserecord = await prisma.expenserecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends expenserecordFindFirstOrThrowArgs>(args?: SelectSubset<T, expenserecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenserecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenserecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenserecords
     * const expenserecords = await prisma.expenserecord.findMany()
     * 
     * // Get first 10 Expenserecords
     * const expenserecords = await prisma.expenserecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenserecordWithIdOnly = await prisma.expenserecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends expenserecordFindManyArgs>(args?: SelectSubset<T, expenserecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expenserecord.
     * @param {expenserecordCreateArgs} args - Arguments to create a Expenserecord.
     * @example
     * // Create one Expenserecord
     * const Expenserecord = await prisma.expenserecord.create({
     *   data: {
     *     // ... data to create a Expenserecord
     *   }
     * })
     * 
     */
    create<T extends expenserecordCreateArgs>(args: SelectSubset<T, expenserecordCreateArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenserecords.
     * @param {expenserecordCreateManyArgs} args - Arguments to create many Expenserecords.
     * @example
     * // Create many Expenserecords
     * const expenserecord = await prisma.expenserecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends expenserecordCreateManyArgs>(args?: SelectSubset<T, expenserecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Expenserecord.
     * @param {expenserecordDeleteArgs} args - Arguments to delete one Expenserecord.
     * @example
     * // Delete one Expenserecord
     * const Expenserecord = await prisma.expenserecord.delete({
     *   where: {
     *     // ... filter to delete one Expenserecord
     *   }
     * })
     * 
     */
    delete<T extends expenserecordDeleteArgs>(args: SelectSubset<T, expenserecordDeleteArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expenserecord.
     * @param {expenserecordUpdateArgs} args - Arguments to update one Expenserecord.
     * @example
     * // Update one Expenserecord
     * const expenserecord = await prisma.expenserecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends expenserecordUpdateArgs>(args: SelectSubset<T, expenserecordUpdateArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenserecords.
     * @param {expenserecordDeleteManyArgs} args - Arguments to filter Expenserecords to delete.
     * @example
     * // Delete a few Expenserecords
     * const { count } = await prisma.expenserecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends expenserecordDeleteManyArgs>(args?: SelectSubset<T, expenserecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenserecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenserecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenserecords
     * const expenserecord = await prisma.expenserecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends expenserecordUpdateManyArgs>(args: SelectSubset<T, expenserecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expenserecord.
     * @param {expenserecordUpsertArgs} args - Arguments to update or create a Expenserecord.
     * @example
     * // Update or create a Expenserecord
     * const expenserecord = await prisma.expenserecord.upsert({
     *   create: {
     *     // ... data to create a Expenserecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expenserecord we want to update
     *   }
     * })
     */
    upsert<T extends expenserecordUpsertArgs>(args: SelectSubset<T, expenserecordUpsertArgs<ExtArgs>>): Prisma__expenserecordClient<$Result.GetResult<Prisma.$expenserecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenserecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenserecordCountArgs} args - Arguments to filter Expenserecords to count.
     * @example
     * // Count the number of Expenserecords
     * const count = await prisma.expenserecord.count({
     *   where: {
     *     // ... the filter for the Expenserecords we want to count
     *   }
     * })
    **/
    count<T extends expenserecordCountArgs>(
      args?: Subset<T, expenserecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenserecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expenserecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenserecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenserecordAggregateArgs>(args: Subset<T, ExpenserecordAggregateArgs>): Prisma.PrismaPromise<GetExpenserecordAggregateType<T>>

    /**
     * Group by Expenserecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {expenserecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends expenserecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: expenserecordGroupByArgs['orderBy'] }
        : { orderBy?: expenserecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, expenserecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenserecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the expenserecord model
   */
  readonly fields: expenserecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for expenserecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__expenserecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the expenserecord model
   */ 
  interface expenserecordFieldRefs {
    readonly id: FieldRef<"expenserecord", 'String'>
    readonly expenseDate: FieldRef<"expenserecord", 'DateTime'>
    readonly category: FieldRef<"expenserecord", 'expenserecord_category'>
    readonly description: FieldRef<"expenserecord", 'String'>
    readonly amount: FieldRef<"expenserecord", 'Decimal'>
    readonly payee: FieldRef<"expenserecord", 'String'>
    readonly paymentMethod: FieldRef<"expenserecord", 'expenserecord_paymentMethod'>
    readonly transactionReference: FieldRef<"expenserecord", 'String'>
    readonly receiptUrl: FieldRef<"expenserecord", 'String'>
    readonly approvedBy: FieldRef<"expenserecord", 'String'>
    readonly notes: FieldRef<"expenserecord", 'String'>
    readonly source: FieldRef<"expenserecord", 'String'>
    readonly location: FieldRef<"expenserecord", 'String'>
    readonly status: FieldRef<"expenserecord", 'expenserecord_status'>
    readonly postedByOwnerId: FieldRef<"expenserecord", 'String'>
    readonly postedByOwnerName: FieldRef<"expenserecord", 'String'>
    readonly createdAt: FieldRef<"expenserecord", 'DateTime'>
    readonly updatedAt: FieldRef<"expenserecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * expenserecord findUnique
   */
  export type expenserecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * Filter, which expenserecord to fetch.
     */
    where: expenserecordWhereUniqueInput
  }

  /**
   * expenserecord findUniqueOrThrow
   */
  export type expenserecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * Filter, which expenserecord to fetch.
     */
    where: expenserecordWhereUniqueInput
  }

  /**
   * expenserecord findFirst
   */
  export type expenserecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * Filter, which expenserecord to fetch.
     */
    where?: expenserecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenserecords to fetch.
     */
    orderBy?: expenserecordOrderByWithRelationInput | expenserecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for expenserecords.
     */
    cursor?: expenserecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenserecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenserecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of expenserecords.
     */
    distinct?: ExpenserecordScalarFieldEnum | ExpenserecordScalarFieldEnum[]
  }

  /**
   * expenserecord findFirstOrThrow
   */
  export type expenserecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * Filter, which expenserecord to fetch.
     */
    where?: expenserecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenserecords to fetch.
     */
    orderBy?: expenserecordOrderByWithRelationInput | expenserecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for expenserecords.
     */
    cursor?: expenserecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenserecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenserecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of expenserecords.
     */
    distinct?: ExpenserecordScalarFieldEnum | ExpenserecordScalarFieldEnum[]
  }

  /**
   * expenserecord findMany
   */
  export type expenserecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * Filter, which expenserecords to fetch.
     */
    where?: expenserecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of expenserecords to fetch.
     */
    orderBy?: expenserecordOrderByWithRelationInput | expenserecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing expenserecords.
     */
    cursor?: expenserecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` expenserecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` expenserecords.
     */
    skip?: number
    distinct?: ExpenserecordScalarFieldEnum | ExpenserecordScalarFieldEnum[]
  }

  /**
   * expenserecord create
   */
  export type expenserecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * The data needed to create a expenserecord.
     */
    data: XOR<expenserecordCreateInput, expenserecordUncheckedCreateInput>
  }

  /**
   * expenserecord createMany
   */
  export type expenserecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many expenserecords.
     */
    data: expenserecordCreateManyInput | expenserecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * expenserecord update
   */
  export type expenserecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * The data needed to update a expenserecord.
     */
    data: XOR<expenserecordUpdateInput, expenserecordUncheckedUpdateInput>
    /**
     * Choose, which expenserecord to update.
     */
    where: expenserecordWhereUniqueInput
  }

  /**
   * expenserecord updateMany
   */
  export type expenserecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update expenserecords.
     */
    data: XOR<expenserecordUpdateManyMutationInput, expenserecordUncheckedUpdateManyInput>
    /**
     * Filter which expenserecords to update
     */
    where?: expenserecordWhereInput
  }

  /**
   * expenserecord upsert
   */
  export type expenserecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * The filter to search for the expenserecord to update in case it exists.
     */
    where: expenserecordWhereUniqueInput
    /**
     * In case the expenserecord found by the `where` argument doesn't exist, create a new expenserecord with this data.
     */
    create: XOR<expenserecordCreateInput, expenserecordUncheckedCreateInput>
    /**
     * In case the expenserecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<expenserecordUpdateInput, expenserecordUncheckedUpdateInput>
  }

  /**
   * expenserecord delete
   */
  export type expenserecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
    /**
     * Filter which expenserecord to delete.
     */
    where: expenserecordWhereUniqueInput
  }

  /**
   * expenserecord deleteMany
   */
  export type expenserecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which expenserecords to delete
     */
    where?: expenserecordWhereInput
  }

  /**
   * expenserecord without action
   */
  export type expenserecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the expenserecord
     */
    select?: expenserecordSelect<ExtArgs> | null
  }


  /**
   * Model fellowshiprosteritem
   */

  export type AggregateFellowshiprosteritem = {
    _count: FellowshiprosteritemCountAggregateOutputType | null
    _min: FellowshiprosteritemMinAggregateOutputType | null
    _max: FellowshiprosteritemMaxAggregateOutputType | null
  }

  export type FellowshiprosteritemMinAggregateOutputType = {
    id: string | null
    rosterType: $Enums.fellowshiprosteritem_rosterType | null
    groupNameOrEventTitle: string | null
    assignedDate: Date | null
    timeSlot: string | null
    location: string | null
    contactNumber: string | null
    additionalNotesOrProgramDetails: string | null
    isTemplate: boolean | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FellowshiprosteritemMaxAggregateOutputType = {
    id: string | null
    rosterType: $Enums.fellowshiprosteritem_rosterType | null
    groupNameOrEventTitle: string | null
    assignedDate: Date | null
    timeSlot: string | null
    location: string | null
    contactNumber: string | null
    additionalNotesOrProgramDetails: string | null
    isTemplate: boolean | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FellowshiprosteritemCountAggregateOutputType = {
    id: number
    rosterType: number
    groupNameOrEventTitle: number
    assignedDate: number
    timeSlot: number
    location: number
    contactNumber: number
    additionalNotesOrProgramDetails: number
    isTemplate: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FellowshiprosteritemMinAggregateInputType = {
    id?: true
    rosterType?: true
    groupNameOrEventTitle?: true
    assignedDate?: true
    timeSlot?: true
    location?: true
    contactNumber?: true
    additionalNotesOrProgramDetails?: true
    isTemplate?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FellowshiprosteritemMaxAggregateInputType = {
    id?: true
    rosterType?: true
    groupNameOrEventTitle?: true
    assignedDate?: true
    timeSlot?: true
    location?: true
    contactNumber?: true
    additionalNotesOrProgramDetails?: true
    isTemplate?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FellowshiprosteritemCountAggregateInputType = {
    id?: true
    rosterType?: true
    groupNameOrEventTitle?: true
    assignedDate?: true
    timeSlot?: true
    location?: true
    contactNumber?: true
    additionalNotesOrProgramDetails?: true
    isTemplate?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FellowshiprosteritemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fellowshiprosteritem to aggregate.
     */
    where?: fellowshiprosteritemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fellowshiprosteritems to fetch.
     */
    orderBy?: fellowshiprosteritemOrderByWithRelationInput | fellowshiprosteritemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fellowshiprosteritemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fellowshiprosteritems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fellowshiprosteritems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fellowshiprosteritems
    **/
    _count?: true | FellowshiprosteritemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FellowshiprosteritemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FellowshiprosteritemMaxAggregateInputType
  }

  export type GetFellowshiprosteritemAggregateType<T extends FellowshiprosteritemAggregateArgs> = {
        [P in keyof T & keyof AggregateFellowshiprosteritem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFellowshiprosteritem[P]>
      : GetScalarType<T[P], AggregateFellowshiprosteritem[P]>
  }




  export type fellowshiprosteritemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fellowshiprosteritemWhereInput
    orderBy?: fellowshiprosteritemOrderByWithAggregationInput | fellowshiprosteritemOrderByWithAggregationInput[]
    by: FellowshiprosteritemScalarFieldEnum[] | FellowshiprosteritemScalarFieldEnum
    having?: fellowshiprosteritemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FellowshiprosteritemCountAggregateInputType | true
    _min?: FellowshiprosteritemMinAggregateInputType
    _max?: FellowshiprosteritemMaxAggregateInputType
  }

  export type FellowshiprosteritemGroupByOutputType = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date
    timeSlot: string
    location: string | null
    contactNumber: string | null
    additionalNotesOrProgramDetails: string | null
    isTemplate: boolean
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    _count: FellowshiprosteritemCountAggregateOutputType | null
    _min: FellowshiprosteritemMinAggregateOutputType | null
    _max: FellowshiprosteritemMaxAggregateOutputType | null
  }

  type GetFellowshiprosteritemGroupByPayload<T extends fellowshiprosteritemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FellowshiprosteritemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FellowshiprosteritemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FellowshiprosteritemGroupByOutputType[P]>
            : GetScalarType<T[P], FellowshiprosteritemGroupByOutputType[P]>
        }
      >
    >


  export type fellowshiprosteritemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rosterType?: boolean
    groupNameOrEventTitle?: boolean
    assignedDate?: boolean
    timeSlot?: boolean
    location?: boolean
    contactNumber?: boolean
    additionalNotesOrProgramDetails?: boolean
    isTemplate?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedscheduleitem?: boolean | fellowshiprosteritem$generatedscheduleitemArgs<ExtArgs>
    responsibility?: boolean | fellowshiprosteritem$responsibilityArgs<ExtArgs>
    _count?: boolean | FellowshiprosteritemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fellowshiprosteritem"]>


  export type fellowshiprosteritemSelectScalar = {
    id?: boolean
    rosterType?: boolean
    groupNameOrEventTitle?: boolean
    assignedDate?: boolean
    timeSlot?: boolean
    location?: boolean
    contactNumber?: boolean
    additionalNotesOrProgramDetails?: boolean
    isTemplate?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type fellowshiprosteritemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedscheduleitem?: boolean | fellowshiprosteritem$generatedscheduleitemArgs<ExtArgs>
    responsibility?: boolean | fellowshiprosteritem$responsibilityArgs<ExtArgs>
    _count?: boolean | FellowshiprosteritemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $fellowshiprosteritemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fellowshiprosteritem"
    objects: {
      generatedscheduleitem: Prisma.$generatedscheduleitemPayload<ExtArgs>[]
      responsibility: Prisma.$responsibilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rosterType: $Enums.fellowshiprosteritem_rosterType
      groupNameOrEventTitle: string
      assignedDate: Date
      timeSlot: string
      location: string | null
      contactNumber: string | null
      additionalNotesOrProgramDetails: string | null
      isTemplate: boolean
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fellowshiprosteritem"]>
    composites: {}
  }

  type fellowshiprosteritemGetPayload<S extends boolean | null | undefined | fellowshiprosteritemDefaultArgs> = $Result.GetResult<Prisma.$fellowshiprosteritemPayload, S>

  type fellowshiprosteritemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<fellowshiprosteritemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FellowshiprosteritemCountAggregateInputType | true
    }

  export interface fellowshiprosteritemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fellowshiprosteritem'], meta: { name: 'fellowshiprosteritem' } }
    /**
     * Find zero or one Fellowshiprosteritem that matches the filter.
     * @param {fellowshiprosteritemFindUniqueArgs} args - Arguments to find a Fellowshiprosteritem
     * @example
     * // Get one Fellowshiprosteritem
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fellowshiprosteritemFindUniqueArgs>(args: SelectSubset<T, fellowshiprosteritemFindUniqueArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Fellowshiprosteritem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {fellowshiprosteritemFindUniqueOrThrowArgs} args - Arguments to find a Fellowshiprosteritem
     * @example
     * // Get one Fellowshiprosteritem
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fellowshiprosteritemFindUniqueOrThrowArgs>(args: SelectSubset<T, fellowshiprosteritemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Fellowshiprosteritem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fellowshiprosteritemFindFirstArgs} args - Arguments to find a Fellowshiprosteritem
     * @example
     * // Get one Fellowshiprosteritem
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fellowshiprosteritemFindFirstArgs>(args?: SelectSubset<T, fellowshiprosteritemFindFirstArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Fellowshiprosteritem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fellowshiprosteritemFindFirstOrThrowArgs} args - Arguments to find a Fellowshiprosteritem
     * @example
     * // Get one Fellowshiprosteritem
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fellowshiprosteritemFindFirstOrThrowArgs>(args?: SelectSubset<T, fellowshiprosteritemFindFirstOrThrowArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Fellowshiprosteritems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fellowshiprosteritemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fellowshiprosteritems
     * const fellowshiprosteritems = await prisma.fellowshiprosteritem.findMany()
     * 
     * // Get first 10 Fellowshiprosteritems
     * const fellowshiprosteritems = await prisma.fellowshiprosteritem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fellowshiprosteritemWithIdOnly = await prisma.fellowshiprosteritem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fellowshiprosteritemFindManyArgs>(args?: SelectSubset<T, fellowshiprosteritemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Fellowshiprosteritem.
     * @param {fellowshiprosteritemCreateArgs} args - Arguments to create a Fellowshiprosteritem.
     * @example
     * // Create one Fellowshiprosteritem
     * const Fellowshiprosteritem = await prisma.fellowshiprosteritem.create({
     *   data: {
     *     // ... data to create a Fellowshiprosteritem
     *   }
     * })
     * 
     */
    create<T extends fellowshiprosteritemCreateArgs>(args: SelectSubset<T, fellowshiprosteritemCreateArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Fellowshiprosteritems.
     * @param {fellowshiprosteritemCreateManyArgs} args - Arguments to create many Fellowshiprosteritems.
     * @example
     * // Create many Fellowshiprosteritems
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fellowshiprosteritemCreateManyArgs>(args?: SelectSubset<T, fellowshiprosteritemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fellowshiprosteritem.
     * @param {fellowshiprosteritemDeleteArgs} args - Arguments to delete one Fellowshiprosteritem.
     * @example
     * // Delete one Fellowshiprosteritem
     * const Fellowshiprosteritem = await prisma.fellowshiprosteritem.delete({
     *   where: {
     *     // ... filter to delete one Fellowshiprosteritem
     *   }
     * })
     * 
     */
    delete<T extends fellowshiprosteritemDeleteArgs>(args: SelectSubset<T, fellowshiprosteritemDeleteArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Fellowshiprosteritem.
     * @param {fellowshiprosteritemUpdateArgs} args - Arguments to update one Fellowshiprosteritem.
     * @example
     * // Update one Fellowshiprosteritem
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fellowshiprosteritemUpdateArgs>(args: SelectSubset<T, fellowshiprosteritemUpdateArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Fellowshiprosteritems.
     * @param {fellowshiprosteritemDeleteManyArgs} args - Arguments to filter Fellowshiprosteritems to delete.
     * @example
     * // Delete a few Fellowshiprosteritems
     * const { count } = await prisma.fellowshiprosteritem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fellowshiprosteritemDeleteManyArgs>(args?: SelectSubset<T, fellowshiprosteritemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fellowshiprosteritems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fellowshiprosteritemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fellowshiprosteritems
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fellowshiprosteritemUpdateManyArgs>(args: SelectSubset<T, fellowshiprosteritemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fellowshiprosteritem.
     * @param {fellowshiprosteritemUpsertArgs} args - Arguments to update or create a Fellowshiprosteritem.
     * @example
     * // Update or create a Fellowshiprosteritem
     * const fellowshiprosteritem = await prisma.fellowshiprosteritem.upsert({
     *   create: {
     *     // ... data to create a Fellowshiprosteritem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fellowshiprosteritem we want to update
     *   }
     * })
     */
    upsert<T extends fellowshiprosteritemUpsertArgs>(args: SelectSubset<T, fellowshiprosteritemUpsertArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Fellowshiprosteritems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fellowshiprosteritemCountArgs} args - Arguments to filter Fellowshiprosteritems to count.
     * @example
     * // Count the number of Fellowshiprosteritems
     * const count = await prisma.fellowshiprosteritem.count({
     *   where: {
     *     // ... the filter for the Fellowshiprosteritems we want to count
     *   }
     * })
    **/
    count<T extends fellowshiprosteritemCountArgs>(
      args?: Subset<T, fellowshiprosteritemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FellowshiprosteritemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fellowshiprosteritem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FellowshiprosteritemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FellowshiprosteritemAggregateArgs>(args: Subset<T, FellowshiprosteritemAggregateArgs>): Prisma.PrismaPromise<GetFellowshiprosteritemAggregateType<T>>

    /**
     * Group by Fellowshiprosteritem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fellowshiprosteritemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fellowshiprosteritemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fellowshiprosteritemGroupByArgs['orderBy'] }
        : { orderBy?: fellowshiprosteritemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fellowshiprosteritemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFellowshiprosteritemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fellowshiprosteritem model
   */
  readonly fields: fellowshiprosteritemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fellowshiprosteritem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fellowshiprosteritemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generatedscheduleitem<T extends fellowshiprosteritem$generatedscheduleitemArgs<ExtArgs> = {}>(args?: Subset<T, fellowshiprosteritem$generatedscheduleitemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "findMany"> | Null>
    responsibility<T extends fellowshiprosteritem$responsibilityArgs<ExtArgs> = {}>(args?: Subset<T, fellowshiprosteritem$responsibilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fellowshiprosteritem model
   */ 
  interface fellowshiprosteritemFieldRefs {
    readonly id: FieldRef<"fellowshiprosteritem", 'String'>
    readonly rosterType: FieldRef<"fellowshiprosteritem", 'fellowshiprosteritem_rosterType'>
    readonly groupNameOrEventTitle: FieldRef<"fellowshiprosteritem", 'String'>
    readonly assignedDate: FieldRef<"fellowshiprosteritem", 'DateTime'>
    readonly timeSlot: FieldRef<"fellowshiprosteritem", 'String'>
    readonly location: FieldRef<"fellowshiprosteritem", 'String'>
    readonly contactNumber: FieldRef<"fellowshiprosteritem", 'String'>
    readonly additionalNotesOrProgramDetails: FieldRef<"fellowshiprosteritem", 'String'>
    readonly isTemplate: FieldRef<"fellowshiprosteritem", 'Boolean'>
    readonly postedByOwnerId: FieldRef<"fellowshiprosteritem", 'String'>
    readonly postedByOwnerName: FieldRef<"fellowshiprosteritem", 'String'>
    readonly createdAt: FieldRef<"fellowshiprosteritem", 'DateTime'>
    readonly updatedAt: FieldRef<"fellowshiprosteritem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * fellowshiprosteritem findUnique
   */
  export type fellowshiprosteritemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * Filter, which fellowshiprosteritem to fetch.
     */
    where: fellowshiprosteritemWhereUniqueInput
  }

  /**
   * fellowshiprosteritem findUniqueOrThrow
   */
  export type fellowshiprosteritemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * Filter, which fellowshiprosteritem to fetch.
     */
    where: fellowshiprosteritemWhereUniqueInput
  }

  /**
   * fellowshiprosteritem findFirst
   */
  export type fellowshiprosteritemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * Filter, which fellowshiprosteritem to fetch.
     */
    where?: fellowshiprosteritemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fellowshiprosteritems to fetch.
     */
    orderBy?: fellowshiprosteritemOrderByWithRelationInput | fellowshiprosteritemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fellowshiprosteritems.
     */
    cursor?: fellowshiprosteritemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fellowshiprosteritems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fellowshiprosteritems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fellowshiprosteritems.
     */
    distinct?: FellowshiprosteritemScalarFieldEnum | FellowshiprosteritemScalarFieldEnum[]
  }

  /**
   * fellowshiprosteritem findFirstOrThrow
   */
  export type fellowshiprosteritemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * Filter, which fellowshiprosteritem to fetch.
     */
    where?: fellowshiprosteritemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fellowshiprosteritems to fetch.
     */
    orderBy?: fellowshiprosteritemOrderByWithRelationInput | fellowshiprosteritemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fellowshiprosteritems.
     */
    cursor?: fellowshiprosteritemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fellowshiprosteritems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fellowshiprosteritems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fellowshiprosteritems.
     */
    distinct?: FellowshiprosteritemScalarFieldEnum | FellowshiprosteritemScalarFieldEnum[]
  }

  /**
   * fellowshiprosteritem findMany
   */
  export type fellowshiprosteritemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * Filter, which fellowshiprosteritems to fetch.
     */
    where?: fellowshiprosteritemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fellowshiprosteritems to fetch.
     */
    orderBy?: fellowshiprosteritemOrderByWithRelationInput | fellowshiprosteritemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fellowshiprosteritems.
     */
    cursor?: fellowshiprosteritemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fellowshiprosteritems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fellowshiprosteritems.
     */
    skip?: number
    distinct?: FellowshiprosteritemScalarFieldEnum | FellowshiprosteritemScalarFieldEnum[]
  }

  /**
   * fellowshiprosteritem create
   */
  export type fellowshiprosteritemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * The data needed to create a fellowshiprosteritem.
     */
    data: XOR<fellowshiprosteritemCreateInput, fellowshiprosteritemUncheckedCreateInput>
  }

  /**
   * fellowshiprosteritem createMany
   */
  export type fellowshiprosteritemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fellowshiprosteritems.
     */
    data: fellowshiprosteritemCreateManyInput | fellowshiprosteritemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fellowshiprosteritem update
   */
  export type fellowshiprosteritemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * The data needed to update a fellowshiprosteritem.
     */
    data: XOR<fellowshiprosteritemUpdateInput, fellowshiprosteritemUncheckedUpdateInput>
    /**
     * Choose, which fellowshiprosteritem to update.
     */
    where: fellowshiprosteritemWhereUniqueInput
  }

  /**
   * fellowshiprosteritem updateMany
   */
  export type fellowshiprosteritemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fellowshiprosteritems.
     */
    data: XOR<fellowshiprosteritemUpdateManyMutationInput, fellowshiprosteritemUncheckedUpdateManyInput>
    /**
     * Filter which fellowshiprosteritems to update
     */
    where?: fellowshiprosteritemWhereInput
  }

  /**
   * fellowshiprosteritem upsert
   */
  export type fellowshiprosteritemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * The filter to search for the fellowshiprosteritem to update in case it exists.
     */
    where: fellowshiprosteritemWhereUniqueInput
    /**
     * In case the fellowshiprosteritem found by the `where` argument doesn't exist, create a new fellowshiprosteritem with this data.
     */
    create: XOR<fellowshiprosteritemCreateInput, fellowshiprosteritemUncheckedCreateInput>
    /**
     * In case the fellowshiprosteritem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fellowshiprosteritemUpdateInput, fellowshiprosteritemUncheckedUpdateInput>
  }

  /**
   * fellowshiprosteritem delete
   */
  export type fellowshiprosteritemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    /**
     * Filter which fellowshiprosteritem to delete.
     */
    where: fellowshiprosteritemWhereUniqueInput
  }

  /**
   * fellowshiprosteritem deleteMany
   */
  export type fellowshiprosteritemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fellowshiprosteritems to delete
     */
    where?: fellowshiprosteritemWhereInput
  }

  /**
   * fellowshiprosteritem.generatedscheduleitem
   */
  export type fellowshiprosteritem$generatedscheduleitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    where?: generatedscheduleitemWhereInput
    orderBy?: generatedscheduleitemOrderByWithRelationInput | generatedscheduleitemOrderByWithRelationInput[]
    cursor?: generatedscheduleitemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedscheduleitemScalarFieldEnum | GeneratedscheduleitemScalarFieldEnum[]
  }

  /**
   * fellowshiprosteritem.responsibility
   */
  export type fellowshiprosteritem$responsibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    where?: responsibilityWhereInput
    orderBy?: responsibilityOrderByWithRelationInput | responsibilityOrderByWithRelationInput[]
    cursor?: responsibilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponsibilityScalarFieldEnum | ResponsibilityScalarFieldEnum[]
  }

  /**
   * fellowshiprosteritem without action
   */
  export type fellowshiprosteritemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
  }


  /**
   * Model friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    requesterId: string | null
    addresseeId: string | null
    status: $Enums.friendship_status | null
    requestedAt: Date | null
    updatedAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    requesterId: string | null
    addresseeId: string | null
    status: $Enums.friendship_status | null
    requestedAt: Date | null
    updatedAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    requesterId: number
    addresseeId: number
    status: number
    requestedAt: number
    updatedAt: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    requestedAt?: true
    updatedAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    requestedAt?: true
    updatedAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    requestedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friendship to aggregate.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type friendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithAggregationInput | friendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: friendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    requesterId: string
    addresseeId: string
    status: $Enums.friendship_status
    requestedAt: Date
    updatedAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends friendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type friendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    requestedAt?: boolean
    updatedAt?: boolean
    user_friendship_addresseeIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_requesterIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>


  export type friendshipSelectScalar = {
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    requestedAt?: boolean
    updatedAt?: boolean
  }

  export type friendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_friendship_addresseeIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_requesterIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $friendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "friendship"
    objects: {
      user_friendship_addresseeIdTouser: Prisma.$userPayload<ExtArgs>
      user_friendship_requesterIdTouser: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requesterId: string
      addresseeId: string
      status: $Enums.friendship_status
      requestedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type friendshipGetPayload<S extends boolean | null | undefined | friendshipDefaultArgs> = $Result.GetResult<Prisma.$friendshipPayload, S>

  type friendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<friendshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface friendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['friendship'], meta: { name: 'friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {friendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends friendshipFindUniqueArgs>(args: SelectSubset<T, friendshipFindUniqueArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {friendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends friendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, friendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends friendshipFindFirstArgs>(args?: SelectSubset<T, friendshipFindFirstArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends friendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, friendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends friendshipFindManyArgs>(args?: SelectSubset<T, friendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Friendship.
     * @param {friendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends friendshipCreateArgs>(args: SelectSubset<T, friendshipCreateArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Friendships.
     * @param {friendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends friendshipCreateManyArgs>(args?: SelectSubset<T, friendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Friendship.
     * @param {friendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends friendshipDeleteArgs>(args: SelectSubset<T, friendshipDeleteArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Friendship.
     * @param {friendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends friendshipUpdateArgs>(args: SelectSubset<T, friendshipUpdateArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Friendships.
     * @param {friendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends friendshipDeleteManyArgs>(args?: SelectSubset<T, friendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends friendshipUpdateManyArgs>(args: SelectSubset<T, friendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {friendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends friendshipUpsertArgs>(args: SelectSubset<T, friendshipUpsertArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends friendshipCountArgs>(
      args?: Subset<T, friendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends friendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: friendshipGroupByArgs['orderBy'] }
        : { orderBy?: friendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, friendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the friendship model
   */
  readonly fields: friendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__friendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_friendship_addresseeIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user_friendship_requesterIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the friendship model
   */ 
  interface friendshipFieldRefs {
    readonly id: FieldRef<"friendship", 'String'>
    readonly requesterId: FieldRef<"friendship", 'String'>
    readonly addresseeId: FieldRef<"friendship", 'String'>
    readonly status: FieldRef<"friendship", 'friendship_status'>
    readonly requestedAt: FieldRef<"friendship", 'DateTime'>
    readonly updatedAt: FieldRef<"friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * friendship findUnique
   */
  export type friendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship findUniqueOrThrow
   */
  export type friendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship findFirst
   */
  export type friendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship findFirstOrThrow
   */
  export type friendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship findMany
   */
  export type friendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendships to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship create
   */
  export type friendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a friendship.
     */
    data: XOR<friendshipCreateInput, friendshipUncheckedCreateInput>
  }

  /**
   * friendship createMany
   */
  export type friendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many friendships.
     */
    data: friendshipCreateManyInput | friendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * friendship update
   */
  export type friendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a friendship.
     */
    data: XOR<friendshipUpdateInput, friendshipUncheckedUpdateInput>
    /**
     * Choose, which friendship to update.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship updateMany
   */
  export type friendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update friendships.
     */
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyInput>
    /**
     * Filter which friendships to update
     */
    where?: friendshipWhereInput
  }

  /**
   * friendship upsert
   */
  export type friendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the friendship to update in case it exists.
     */
    where: friendshipWhereUniqueInput
    /**
     * In case the friendship found by the `where` argument doesn't exist, create a new friendship with this data.
     */
    create: XOR<friendshipCreateInput, friendshipUncheckedCreateInput>
    /**
     * In case the friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<friendshipUpdateInput, friendshipUncheckedUpdateInput>
  }

  /**
   * friendship delete
   */
  export type friendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter which friendship to delete.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship deleteMany
   */
  export type friendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friendships to delete
     */
    where?: friendshipWhereInput
  }

  /**
   * friendship without action
   */
  export type friendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
  }


  /**
   * Model frontendactivitylog
   */

  export type AggregateFrontendactivitylog = {
    _count: FrontendactivitylogCountAggregateOutputType | null
    _min: FrontendactivitylogMinAggregateOutputType | null
    _max: FrontendactivitylogMaxAggregateOutputType | null
  }

  export type FrontendactivitylogMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    userId: string | null
    description: string | null
    type: string | null
    itemId: string | null
    itemType: string | null
  }

  export type FrontendactivitylogMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    userId: string | null
    description: string | null
    type: string | null
    itemId: string | null
    itemType: string | null
  }

  export type FrontendactivitylogCountAggregateOutputType = {
    id: number
    timestamp: number
    userId: number
    description: number
    type: number
    itemId: number
    itemType: number
    _all: number
  }


  export type FrontendactivitylogMinAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    description?: true
    type?: true
    itemId?: true
    itemType?: true
  }

  export type FrontendactivitylogMaxAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    description?: true
    type?: true
    itemId?: true
    itemType?: true
  }

  export type FrontendactivitylogCountAggregateInputType = {
    id?: true
    timestamp?: true
    userId?: true
    description?: true
    type?: true
    itemId?: true
    itemType?: true
    _all?: true
  }

  export type FrontendactivitylogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which frontendactivitylog to aggregate.
     */
    where?: frontendactivitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frontendactivitylogs to fetch.
     */
    orderBy?: frontendactivitylogOrderByWithRelationInput | frontendactivitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: frontendactivitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frontendactivitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frontendactivitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned frontendactivitylogs
    **/
    _count?: true | FrontendactivitylogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FrontendactivitylogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FrontendactivitylogMaxAggregateInputType
  }

  export type GetFrontendactivitylogAggregateType<T extends FrontendactivitylogAggregateArgs> = {
        [P in keyof T & keyof AggregateFrontendactivitylog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFrontendactivitylog[P]>
      : GetScalarType<T[P], AggregateFrontendactivitylog[P]>
  }




  export type frontendactivitylogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: frontendactivitylogWhereInput
    orderBy?: frontendactivitylogOrderByWithAggregationInput | frontendactivitylogOrderByWithAggregationInput[]
    by: FrontendactivitylogScalarFieldEnum[] | FrontendactivitylogScalarFieldEnum
    having?: frontendactivitylogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FrontendactivitylogCountAggregateInputType | true
    _min?: FrontendactivitylogMinAggregateInputType
    _max?: FrontendactivitylogMaxAggregateInputType
  }

  export type FrontendactivitylogGroupByOutputType = {
    id: string
    timestamp: Date
    userId: string | null
    description: string
    type: string
    itemId: string | null
    itemType: string | null
    _count: FrontendactivitylogCountAggregateOutputType | null
    _min: FrontendactivitylogMinAggregateOutputType | null
    _max: FrontendactivitylogMaxAggregateOutputType | null
  }

  type GetFrontendactivitylogGroupByPayload<T extends frontendactivitylogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FrontendactivitylogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FrontendactivitylogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FrontendactivitylogGroupByOutputType[P]>
            : GetScalarType<T[P], FrontendactivitylogGroupByOutputType[P]>
        }
      >
    >


  export type frontendactivitylogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    description?: boolean
    type?: boolean
    itemId?: boolean
    itemType?: boolean
    user?: boolean | frontendactivitylog$userArgs<ExtArgs>
  }, ExtArgs["result"]["frontendactivitylog"]>


  export type frontendactivitylogSelectScalar = {
    id?: boolean
    timestamp?: boolean
    userId?: boolean
    description?: boolean
    type?: boolean
    itemId?: boolean
    itemType?: boolean
  }

  export type frontendactivitylogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | frontendactivitylog$userArgs<ExtArgs>
  }

  export type $frontendactivitylogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "frontendactivitylog"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      userId: string | null
      description: string
      type: string
      itemId: string | null
      itemType: string | null
    }, ExtArgs["result"]["frontendactivitylog"]>
    composites: {}
  }

  type frontendactivitylogGetPayload<S extends boolean | null | undefined | frontendactivitylogDefaultArgs> = $Result.GetResult<Prisma.$frontendactivitylogPayload, S>

  type frontendactivitylogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<frontendactivitylogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FrontendactivitylogCountAggregateInputType | true
    }

  export interface frontendactivitylogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['frontendactivitylog'], meta: { name: 'frontendactivitylog' } }
    /**
     * Find zero or one Frontendactivitylog that matches the filter.
     * @param {frontendactivitylogFindUniqueArgs} args - Arguments to find a Frontendactivitylog
     * @example
     * // Get one Frontendactivitylog
     * const frontendactivitylog = await prisma.frontendactivitylog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends frontendactivitylogFindUniqueArgs>(args: SelectSubset<T, frontendactivitylogFindUniqueArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Frontendactivitylog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {frontendactivitylogFindUniqueOrThrowArgs} args - Arguments to find a Frontendactivitylog
     * @example
     * // Get one Frontendactivitylog
     * const frontendactivitylog = await prisma.frontendactivitylog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends frontendactivitylogFindUniqueOrThrowArgs>(args: SelectSubset<T, frontendactivitylogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Frontendactivitylog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frontendactivitylogFindFirstArgs} args - Arguments to find a Frontendactivitylog
     * @example
     * // Get one Frontendactivitylog
     * const frontendactivitylog = await prisma.frontendactivitylog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends frontendactivitylogFindFirstArgs>(args?: SelectSubset<T, frontendactivitylogFindFirstArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Frontendactivitylog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frontendactivitylogFindFirstOrThrowArgs} args - Arguments to find a Frontendactivitylog
     * @example
     * // Get one Frontendactivitylog
     * const frontendactivitylog = await prisma.frontendactivitylog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends frontendactivitylogFindFirstOrThrowArgs>(args?: SelectSubset<T, frontendactivitylogFindFirstOrThrowArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Frontendactivitylogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frontendactivitylogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Frontendactivitylogs
     * const frontendactivitylogs = await prisma.frontendactivitylog.findMany()
     * 
     * // Get first 10 Frontendactivitylogs
     * const frontendactivitylogs = await prisma.frontendactivitylog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const frontendactivitylogWithIdOnly = await prisma.frontendactivitylog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends frontendactivitylogFindManyArgs>(args?: SelectSubset<T, frontendactivitylogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Frontendactivitylog.
     * @param {frontendactivitylogCreateArgs} args - Arguments to create a Frontendactivitylog.
     * @example
     * // Create one Frontendactivitylog
     * const Frontendactivitylog = await prisma.frontendactivitylog.create({
     *   data: {
     *     // ... data to create a Frontendactivitylog
     *   }
     * })
     * 
     */
    create<T extends frontendactivitylogCreateArgs>(args: SelectSubset<T, frontendactivitylogCreateArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Frontendactivitylogs.
     * @param {frontendactivitylogCreateManyArgs} args - Arguments to create many Frontendactivitylogs.
     * @example
     * // Create many Frontendactivitylogs
     * const frontendactivitylog = await prisma.frontendactivitylog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends frontendactivitylogCreateManyArgs>(args?: SelectSubset<T, frontendactivitylogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Frontendactivitylog.
     * @param {frontendactivitylogDeleteArgs} args - Arguments to delete one Frontendactivitylog.
     * @example
     * // Delete one Frontendactivitylog
     * const Frontendactivitylog = await prisma.frontendactivitylog.delete({
     *   where: {
     *     // ... filter to delete one Frontendactivitylog
     *   }
     * })
     * 
     */
    delete<T extends frontendactivitylogDeleteArgs>(args: SelectSubset<T, frontendactivitylogDeleteArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Frontendactivitylog.
     * @param {frontendactivitylogUpdateArgs} args - Arguments to update one Frontendactivitylog.
     * @example
     * // Update one Frontendactivitylog
     * const frontendactivitylog = await prisma.frontendactivitylog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends frontendactivitylogUpdateArgs>(args: SelectSubset<T, frontendactivitylogUpdateArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Frontendactivitylogs.
     * @param {frontendactivitylogDeleteManyArgs} args - Arguments to filter Frontendactivitylogs to delete.
     * @example
     * // Delete a few Frontendactivitylogs
     * const { count } = await prisma.frontendactivitylog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends frontendactivitylogDeleteManyArgs>(args?: SelectSubset<T, frontendactivitylogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Frontendactivitylogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frontendactivitylogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Frontendactivitylogs
     * const frontendactivitylog = await prisma.frontendactivitylog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends frontendactivitylogUpdateManyArgs>(args: SelectSubset<T, frontendactivitylogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Frontendactivitylog.
     * @param {frontendactivitylogUpsertArgs} args - Arguments to update or create a Frontendactivitylog.
     * @example
     * // Update or create a Frontendactivitylog
     * const frontendactivitylog = await prisma.frontendactivitylog.upsert({
     *   create: {
     *     // ... data to create a Frontendactivitylog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Frontendactivitylog we want to update
     *   }
     * })
     */
    upsert<T extends frontendactivitylogUpsertArgs>(args: SelectSubset<T, frontendactivitylogUpsertArgs<ExtArgs>>): Prisma__frontendactivitylogClient<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Frontendactivitylogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frontendactivitylogCountArgs} args - Arguments to filter Frontendactivitylogs to count.
     * @example
     * // Count the number of Frontendactivitylogs
     * const count = await prisma.frontendactivitylog.count({
     *   where: {
     *     // ... the filter for the Frontendactivitylogs we want to count
     *   }
     * })
    **/
    count<T extends frontendactivitylogCountArgs>(
      args?: Subset<T, frontendactivitylogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FrontendactivitylogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Frontendactivitylog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FrontendactivitylogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FrontendactivitylogAggregateArgs>(args: Subset<T, FrontendactivitylogAggregateArgs>): Prisma.PrismaPromise<GetFrontendactivitylogAggregateType<T>>

    /**
     * Group by Frontendactivitylog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {frontendactivitylogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends frontendactivitylogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: frontendactivitylogGroupByArgs['orderBy'] }
        : { orderBy?: frontendactivitylogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, frontendactivitylogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFrontendactivitylogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the frontendactivitylog model
   */
  readonly fields: frontendactivitylogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for frontendactivitylog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__frontendactivitylogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends frontendactivitylog$userArgs<ExtArgs> = {}>(args?: Subset<T, frontendactivitylog$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the frontendactivitylog model
   */ 
  interface frontendactivitylogFieldRefs {
    readonly id: FieldRef<"frontendactivitylog", 'String'>
    readonly timestamp: FieldRef<"frontendactivitylog", 'DateTime'>
    readonly userId: FieldRef<"frontendactivitylog", 'String'>
    readonly description: FieldRef<"frontendactivitylog", 'String'>
    readonly type: FieldRef<"frontendactivitylog", 'String'>
    readonly itemId: FieldRef<"frontendactivitylog", 'String'>
    readonly itemType: FieldRef<"frontendactivitylog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * frontendactivitylog findUnique
   */
  export type frontendactivitylogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * Filter, which frontendactivitylog to fetch.
     */
    where: frontendactivitylogWhereUniqueInput
  }

  /**
   * frontendactivitylog findUniqueOrThrow
   */
  export type frontendactivitylogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * Filter, which frontendactivitylog to fetch.
     */
    where: frontendactivitylogWhereUniqueInput
  }

  /**
   * frontendactivitylog findFirst
   */
  export type frontendactivitylogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * Filter, which frontendactivitylog to fetch.
     */
    where?: frontendactivitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frontendactivitylogs to fetch.
     */
    orderBy?: frontendactivitylogOrderByWithRelationInput | frontendactivitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for frontendactivitylogs.
     */
    cursor?: frontendactivitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frontendactivitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frontendactivitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of frontendactivitylogs.
     */
    distinct?: FrontendactivitylogScalarFieldEnum | FrontendactivitylogScalarFieldEnum[]
  }

  /**
   * frontendactivitylog findFirstOrThrow
   */
  export type frontendactivitylogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * Filter, which frontendactivitylog to fetch.
     */
    where?: frontendactivitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frontendactivitylogs to fetch.
     */
    orderBy?: frontendactivitylogOrderByWithRelationInput | frontendactivitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for frontendactivitylogs.
     */
    cursor?: frontendactivitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frontendactivitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frontendactivitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of frontendactivitylogs.
     */
    distinct?: FrontendactivitylogScalarFieldEnum | FrontendactivitylogScalarFieldEnum[]
  }

  /**
   * frontendactivitylog findMany
   */
  export type frontendactivitylogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * Filter, which frontendactivitylogs to fetch.
     */
    where?: frontendactivitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of frontendactivitylogs to fetch.
     */
    orderBy?: frontendactivitylogOrderByWithRelationInput | frontendactivitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing frontendactivitylogs.
     */
    cursor?: frontendactivitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` frontendactivitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` frontendactivitylogs.
     */
    skip?: number
    distinct?: FrontendactivitylogScalarFieldEnum | FrontendactivitylogScalarFieldEnum[]
  }

  /**
   * frontendactivitylog create
   */
  export type frontendactivitylogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * The data needed to create a frontendactivitylog.
     */
    data: XOR<frontendactivitylogCreateInput, frontendactivitylogUncheckedCreateInput>
  }

  /**
   * frontendactivitylog createMany
   */
  export type frontendactivitylogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many frontendactivitylogs.
     */
    data: frontendactivitylogCreateManyInput | frontendactivitylogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * frontendactivitylog update
   */
  export type frontendactivitylogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * The data needed to update a frontendactivitylog.
     */
    data: XOR<frontendactivitylogUpdateInput, frontendactivitylogUncheckedUpdateInput>
    /**
     * Choose, which frontendactivitylog to update.
     */
    where: frontendactivitylogWhereUniqueInput
  }

  /**
   * frontendactivitylog updateMany
   */
  export type frontendactivitylogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update frontendactivitylogs.
     */
    data: XOR<frontendactivitylogUpdateManyMutationInput, frontendactivitylogUncheckedUpdateManyInput>
    /**
     * Filter which frontendactivitylogs to update
     */
    where?: frontendactivitylogWhereInput
  }

  /**
   * frontendactivitylog upsert
   */
  export type frontendactivitylogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * The filter to search for the frontendactivitylog to update in case it exists.
     */
    where: frontendactivitylogWhereUniqueInput
    /**
     * In case the frontendactivitylog found by the `where` argument doesn't exist, create a new frontendactivitylog with this data.
     */
    create: XOR<frontendactivitylogCreateInput, frontendactivitylogUncheckedCreateInput>
    /**
     * In case the frontendactivitylog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<frontendactivitylogUpdateInput, frontendactivitylogUncheckedUpdateInput>
  }

  /**
   * frontendactivitylog delete
   */
  export type frontendactivitylogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    /**
     * Filter which frontendactivitylog to delete.
     */
    where: frontendactivitylogWhereUniqueInput
  }

  /**
   * frontendactivitylog deleteMany
   */
  export type frontendactivitylogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which frontendactivitylogs to delete
     */
    where?: frontendactivitylogWhereInput
  }

  /**
   * frontendactivitylog.user
   */
  export type frontendactivitylog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * frontendactivitylog without action
   */
  export type frontendactivitylogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
  }


  /**
   * Model generatedscheduleitem
   */

  export type AggregateGeneratedscheduleitem = {
    _count: GeneratedscheduleitemCountAggregateOutputType | null
    _min: GeneratedscheduleitemMinAggregateOutputType | null
    _max: GeneratedscheduleitemMaxAggregateOutputType | null
  }

  export type GeneratedscheduleitemMinAggregateOutputType = {
    id: string | null
    basedOnRosterItemId: string | null
    rosterType: $Enums.generatedscheduleitem_rosterType | null
    groupNameOrEventTitle: string | null
    scheduledDate: Date | null
    timeSlot: string | null
    location: string | null
    contactNumber: string | null
    additionalNotesOrProgramDetails: string | null
    generatedAt: Date | null
    isPublishedAsEvent: boolean | null
    publishedEventId: string | null
    adminNotes: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeneratedscheduleitemMaxAggregateOutputType = {
    id: string | null
    basedOnRosterItemId: string | null
    rosterType: $Enums.generatedscheduleitem_rosterType | null
    groupNameOrEventTitle: string | null
    scheduledDate: Date | null
    timeSlot: string | null
    location: string | null
    contactNumber: string | null
    additionalNotesOrProgramDetails: string | null
    generatedAt: Date | null
    isPublishedAsEvent: boolean | null
    publishedEventId: string | null
    adminNotes: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GeneratedscheduleitemCountAggregateOutputType = {
    id: number
    basedOnRosterItemId: number
    rosterType: number
    groupNameOrEventTitle: number
    scheduledDate: number
    timeSlot: number
    location: number
    contactNumber: number
    additionalNotesOrProgramDetails: number
    generatedAt: number
    isPublishedAsEvent: number
    publishedEventId: number
    adminNotes: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GeneratedscheduleitemMinAggregateInputType = {
    id?: true
    basedOnRosterItemId?: true
    rosterType?: true
    groupNameOrEventTitle?: true
    scheduledDate?: true
    timeSlot?: true
    location?: true
    contactNumber?: true
    additionalNotesOrProgramDetails?: true
    generatedAt?: true
    isPublishedAsEvent?: true
    publishedEventId?: true
    adminNotes?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeneratedscheduleitemMaxAggregateInputType = {
    id?: true
    basedOnRosterItemId?: true
    rosterType?: true
    groupNameOrEventTitle?: true
    scheduledDate?: true
    timeSlot?: true
    location?: true
    contactNumber?: true
    additionalNotesOrProgramDetails?: true
    generatedAt?: true
    isPublishedAsEvent?: true
    publishedEventId?: true
    adminNotes?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GeneratedscheduleitemCountAggregateInputType = {
    id?: true
    basedOnRosterItemId?: true
    rosterType?: true
    groupNameOrEventTitle?: true
    scheduledDate?: true
    timeSlot?: true
    location?: true
    contactNumber?: true
    additionalNotesOrProgramDetails?: true
    generatedAt?: true
    isPublishedAsEvent?: true
    publishedEventId?: true
    adminNotes?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GeneratedscheduleitemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which generatedscheduleitem to aggregate.
     */
    where?: generatedscheduleitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generatedscheduleitems to fetch.
     */
    orderBy?: generatedscheduleitemOrderByWithRelationInput | generatedscheduleitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: generatedscheduleitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generatedscheduleitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generatedscheduleitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned generatedscheduleitems
    **/
    _count?: true | GeneratedscheduleitemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedscheduleitemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedscheduleitemMaxAggregateInputType
  }

  export type GetGeneratedscheduleitemAggregateType<T extends GeneratedscheduleitemAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedscheduleitem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedscheduleitem[P]>
      : GetScalarType<T[P], AggregateGeneratedscheduleitem[P]>
  }




  export type generatedscheduleitemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: generatedscheduleitemWhereInput
    orderBy?: generatedscheduleitemOrderByWithAggregationInput | generatedscheduleitemOrderByWithAggregationInput[]
    by: GeneratedscheduleitemScalarFieldEnum[] | GeneratedscheduleitemScalarFieldEnum
    having?: generatedscheduleitemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedscheduleitemCountAggregateInputType | true
    _min?: GeneratedscheduleitemMinAggregateInputType
    _max?: GeneratedscheduleitemMaxAggregateInputType
  }

  export type GeneratedscheduleitemGroupByOutputType = {
    id: string
    basedOnRosterItemId: string | null
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date
    timeSlot: string
    location: string | null
    contactNumber: string | null
    additionalNotesOrProgramDetails: string | null
    generatedAt: Date
    isPublishedAsEvent: boolean
    publishedEventId: string | null
    adminNotes: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    _count: GeneratedscheduleitemCountAggregateOutputType | null
    _min: GeneratedscheduleitemMinAggregateOutputType | null
    _max: GeneratedscheduleitemMaxAggregateOutputType | null
  }

  type GetGeneratedscheduleitemGroupByPayload<T extends generatedscheduleitemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedscheduleitemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedscheduleitemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedscheduleitemGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedscheduleitemGroupByOutputType[P]>
        }
      >
    >


  export type generatedscheduleitemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    basedOnRosterItemId?: boolean
    rosterType?: boolean
    groupNameOrEventTitle?: boolean
    scheduledDate?: boolean
    timeSlot?: boolean
    location?: boolean
    contactNumber?: boolean
    additionalNotesOrProgramDetails?: boolean
    generatedAt?: boolean
    isPublishedAsEvent?: boolean
    publishedEventId?: boolean
    adminNotes?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fellowshiprosteritem?: boolean | generatedscheduleitem$fellowshiprosteritemArgs<ExtArgs>
    responsibility?: boolean | generatedscheduleitem$responsibilityArgs<ExtArgs>
    _count?: boolean | GeneratedscheduleitemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedscheduleitem"]>


  export type generatedscheduleitemSelectScalar = {
    id?: boolean
    basedOnRosterItemId?: boolean
    rosterType?: boolean
    groupNameOrEventTitle?: boolean
    scheduledDate?: boolean
    timeSlot?: boolean
    location?: boolean
    contactNumber?: boolean
    additionalNotesOrProgramDetails?: boolean
    generatedAt?: boolean
    isPublishedAsEvent?: boolean
    publishedEventId?: boolean
    adminNotes?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type generatedscheduleitemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fellowshiprosteritem?: boolean | generatedscheduleitem$fellowshiprosteritemArgs<ExtArgs>
    responsibility?: boolean | generatedscheduleitem$responsibilityArgs<ExtArgs>
    _count?: boolean | GeneratedscheduleitemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $generatedscheduleitemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "generatedscheduleitem"
    objects: {
      fellowshiprosteritem: Prisma.$fellowshiprosteritemPayload<ExtArgs> | null
      responsibility: Prisma.$responsibilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      basedOnRosterItemId: string | null
      rosterType: $Enums.generatedscheduleitem_rosterType
      groupNameOrEventTitle: string
      scheduledDate: Date
      timeSlot: string
      location: string | null
      contactNumber: string | null
      additionalNotesOrProgramDetails: string | null
      generatedAt: Date
      isPublishedAsEvent: boolean
      publishedEventId: string | null
      adminNotes: string | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["generatedscheduleitem"]>
    composites: {}
  }

  type generatedscheduleitemGetPayload<S extends boolean | null | undefined | generatedscheduleitemDefaultArgs> = $Result.GetResult<Prisma.$generatedscheduleitemPayload, S>

  type generatedscheduleitemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<generatedscheduleitemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GeneratedscheduleitemCountAggregateInputType | true
    }

  export interface generatedscheduleitemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['generatedscheduleitem'], meta: { name: 'generatedscheduleitem' } }
    /**
     * Find zero or one Generatedscheduleitem that matches the filter.
     * @param {generatedscheduleitemFindUniqueArgs} args - Arguments to find a Generatedscheduleitem
     * @example
     * // Get one Generatedscheduleitem
     * const generatedscheduleitem = await prisma.generatedscheduleitem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends generatedscheduleitemFindUniqueArgs>(args: SelectSubset<T, generatedscheduleitemFindUniqueArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Generatedscheduleitem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {generatedscheduleitemFindUniqueOrThrowArgs} args - Arguments to find a Generatedscheduleitem
     * @example
     * // Get one Generatedscheduleitem
     * const generatedscheduleitem = await prisma.generatedscheduleitem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends generatedscheduleitemFindUniqueOrThrowArgs>(args: SelectSubset<T, generatedscheduleitemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Generatedscheduleitem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generatedscheduleitemFindFirstArgs} args - Arguments to find a Generatedscheduleitem
     * @example
     * // Get one Generatedscheduleitem
     * const generatedscheduleitem = await prisma.generatedscheduleitem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends generatedscheduleitemFindFirstArgs>(args?: SelectSubset<T, generatedscheduleitemFindFirstArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Generatedscheduleitem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generatedscheduleitemFindFirstOrThrowArgs} args - Arguments to find a Generatedscheduleitem
     * @example
     * // Get one Generatedscheduleitem
     * const generatedscheduleitem = await prisma.generatedscheduleitem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends generatedscheduleitemFindFirstOrThrowArgs>(args?: SelectSubset<T, generatedscheduleitemFindFirstOrThrowArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Generatedscheduleitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generatedscheduleitemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Generatedscheduleitems
     * const generatedscheduleitems = await prisma.generatedscheduleitem.findMany()
     * 
     * // Get first 10 Generatedscheduleitems
     * const generatedscheduleitems = await prisma.generatedscheduleitem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedscheduleitemWithIdOnly = await prisma.generatedscheduleitem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends generatedscheduleitemFindManyArgs>(args?: SelectSubset<T, generatedscheduleitemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Generatedscheduleitem.
     * @param {generatedscheduleitemCreateArgs} args - Arguments to create a Generatedscheduleitem.
     * @example
     * // Create one Generatedscheduleitem
     * const Generatedscheduleitem = await prisma.generatedscheduleitem.create({
     *   data: {
     *     // ... data to create a Generatedscheduleitem
     *   }
     * })
     * 
     */
    create<T extends generatedscheduleitemCreateArgs>(args: SelectSubset<T, generatedscheduleitemCreateArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Generatedscheduleitems.
     * @param {generatedscheduleitemCreateManyArgs} args - Arguments to create many Generatedscheduleitems.
     * @example
     * // Create many Generatedscheduleitems
     * const generatedscheduleitem = await prisma.generatedscheduleitem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends generatedscheduleitemCreateManyArgs>(args?: SelectSubset<T, generatedscheduleitemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Generatedscheduleitem.
     * @param {generatedscheduleitemDeleteArgs} args - Arguments to delete one Generatedscheduleitem.
     * @example
     * // Delete one Generatedscheduleitem
     * const Generatedscheduleitem = await prisma.generatedscheduleitem.delete({
     *   where: {
     *     // ... filter to delete one Generatedscheduleitem
     *   }
     * })
     * 
     */
    delete<T extends generatedscheduleitemDeleteArgs>(args: SelectSubset<T, generatedscheduleitemDeleteArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Generatedscheduleitem.
     * @param {generatedscheduleitemUpdateArgs} args - Arguments to update one Generatedscheduleitem.
     * @example
     * // Update one Generatedscheduleitem
     * const generatedscheduleitem = await prisma.generatedscheduleitem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends generatedscheduleitemUpdateArgs>(args: SelectSubset<T, generatedscheduleitemUpdateArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Generatedscheduleitems.
     * @param {generatedscheduleitemDeleteManyArgs} args - Arguments to filter Generatedscheduleitems to delete.
     * @example
     * // Delete a few Generatedscheduleitems
     * const { count } = await prisma.generatedscheduleitem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends generatedscheduleitemDeleteManyArgs>(args?: SelectSubset<T, generatedscheduleitemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generatedscheduleitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generatedscheduleitemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Generatedscheduleitems
     * const generatedscheduleitem = await prisma.generatedscheduleitem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends generatedscheduleitemUpdateManyArgs>(args: SelectSubset<T, generatedscheduleitemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Generatedscheduleitem.
     * @param {generatedscheduleitemUpsertArgs} args - Arguments to update or create a Generatedscheduleitem.
     * @example
     * // Update or create a Generatedscheduleitem
     * const generatedscheduleitem = await prisma.generatedscheduleitem.upsert({
     *   create: {
     *     // ... data to create a Generatedscheduleitem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Generatedscheduleitem we want to update
     *   }
     * })
     */
    upsert<T extends generatedscheduleitemUpsertArgs>(args: SelectSubset<T, generatedscheduleitemUpsertArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Generatedscheduleitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generatedscheduleitemCountArgs} args - Arguments to filter Generatedscheduleitems to count.
     * @example
     * // Count the number of Generatedscheduleitems
     * const count = await prisma.generatedscheduleitem.count({
     *   where: {
     *     // ... the filter for the Generatedscheduleitems we want to count
     *   }
     * })
    **/
    count<T extends generatedscheduleitemCountArgs>(
      args?: Subset<T, generatedscheduleitemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedscheduleitemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Generatedscheduleitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedscheduleitemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedscheduleitemAggregateArgs>(args: Subset<T, GeneratedscheduleitemAggregateArgs>): Prisma.PrismaPromise<GetGeneratedscheduleitemAggregateType<T>>

    /**
     * Group by Generatedscheduleitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {generatedscheduleitemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends generatedscheduleitemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: generatedscheduleitemGroupByArgs['orderBy'] }
        : { orderBy?: generatedscheduleitemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, generatedscheduleitemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedscheduleitemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the generatedscheduleitem model
   */
  readonly fields: generatedscheduleitemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for generatedscheduleitem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__generatedscheduleitemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fellowshiprosteritem<T extends generatedscheduleitem$fellowshiprosteritemArgs<ExtArgs> = {}>(args?: Subset<T, generatedscheduleitem$fellowshiprosteritemArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    responsibility<T extends generatedscheduleitem$responsibilityArgs<ExtArgs> = {}>(args?: Subset<T, generatedscheduleitem$responsibilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the generatedscheduleitem model
   */ 
  interface generatedscheduleitemFieldRefs {
    readonly id: FieldRef<"generatedscheduleitem", 'String'>
    readonly basedOnRosterItemId: FieldRef<"generatedscheduleitem", 'String'>
    readonly rosterType: FieldRef<"generatedscheduleitem", 'generatedscheduleitem_rosterType'>
    readonly groupNameOrEventTitle: FieldRef<"generatedscheduleitem", 'String'>
    readonly scheduledDate: FieldRef<"generatedscheduleitem", 'DateTime'>
    readonly timeSlot: FieldRef<"generatedscheduleitem", 'String'>
    readonly location: FieldRef<"generatedscheduleitem", 'String'>
    readonly contactNumber: FieldRef<"generatedscheduleitem", 'String'>
    readonly additionalNotesOrProgramDetails: FieldRef<"generatedscheduleitem", 'String'>
    readonly generatedAt: FieldRef<"generatedscheduleitem", 'DateTime'>
    readonly isPublishedAsEvent: FieldRef<"generatedscheduleitem", 'Boolean'>
    readonly publishedEventId: FieldRef<"generatedscheduleitem", 'String'>
    readonly adminNotes: FieldRef<"generatedscheduleitem", 'String'>
    readonly postedByOwnerId: FieldRef<"generatedscheduleitem", 'String'>
    readonly postedByOwnerName: FieldRef<"generatedscheduleitem", 'String'>
    readonly createdAt: FieldRef<"generatedscheduleitem", 'DateTime'>
    readonly updatedAt: FieldRef<"generatedscheduleitem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * generatedscheduleitem findUnique
   */
  export type generatedscheduleitemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * Filter, which generatedscheduleitem to fetch.
     */
    where: generatedscheduleitemWhereUniqueInput
  }

  /**
   * generatedscheduleitem findUniqueOrThrow
   */
  export type generatedscheduleitemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * Filter, which generatedscheduleitem to fetch.
     */
    where: generatedscheduleitemWhereUniqueInput
  }

  /**
   * generatedscheduleitem findFirst
   */
  export type generatedscheduleitemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * Filter, which generatedscheduleitem to fetch.
     */
    where?: generatedscheduleitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generatedscheduleitems to fetch.
     */
    orderBy?: generatedscheduleitemOrderByWithRelationInput | generatedscheduleitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generatedscheduleitems.
     */
    cursor?: generatedscheduleitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generatedscheduleitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generatedscheduleitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generatedscheduleitems.
     */
    distinct?: GeneratedscheduleitemScalarFieldEnum | GeneratedscheduleitemScalarFieldEnum[]
  }

  /**
   * generatedscheduleitem findFirstOrThrow
   */
  export type generatedscheduleitemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * Filter, which generatedscheduleitem to fetch.
     */
    where?: generatedscheduleitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generatedscheduleitems to fetch.
     */
    orderBy?: generatedscheduleitemOrderByWithRelationInput | generatedscheduleitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for generatedscheduleitems.
     */
    cursor?: generatedscheduleitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generatedscheduleitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generatedscheduleitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of generatedscheduleitems.
     */
    distinct?: GeneratedscheduleitemScalarFieldEnum | GeneratedscheduleitemScalarFieldEnum[]
  }

  /**
   * generatedscheduleitem findMany
   */
  export type generatedscheduleitemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * Filter, which generatedscheduleitems to fetch.
     */
    where?: generatedscheduleitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of generatedscheduleitems to fetch.
     */
    orderBy?: generatedscheduleitemOrderByWithRelationInput | generatedscheduleitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing generatedscheduleitems.
     */
    cursor?: generatedscheduleitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` generatedscheduleitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` generatedscheduleitems.
     */
    skip?: number
    distinct?: GeneratedscheduleitemScalarFieldEnum | GeneratedscheduleitemScalarFieldEnum[]
  }

  /**
   * generatedscheduleitem create
   */
  export type generatedscheduleitemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * The data needed to create a generatedscheduleitem.
     */
    data: XOR<generatedscheduleitemCreateInput, generatedscheduleitemUncheckedCreateInput>
  }

  /**
   * generatedscheduleitem createMany
   */
  export type generatedscheduleitemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many generatedscheduleitems.
     */
    data: generatedscheduleitemCreateManyInput | generatedscheduleitemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * generatedscheduleitem update
   */
  export type generatedscheduleitemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * The data needed to update a generatedscheduleitem.
     */
    data: XOR<generatedscheduleitemUpdateInput, generatedscheduleitemUncheckedUpdateInput>
    /**
     * Choose, which generatedscheduleitem to update.
     */
    where: generatedscheduleitemWhereUniqueInput
  }

  /**
   * generatedscheduleitem updateMany
   */
  export type generatedscheduleitemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update generatedscheduleitems.
     */
    data: XOR<generatedscheduleitemUpdateManyMutationInput, generatedscheduleitemUncheckedUpdateManyInput>
    /**
     * Filter which generatedscheduleitems to update
     */
    where?: generatedscheduleitemWhereInput
  }

  /**
   * generatedscheduleitem upsert
   */
  export type generatedscheduleitemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * The filter to search for the generatedscheduleitem to update in case it exists.
     */
    where: generatedscheduleitemWhereUniqueInput
    /**
     * In case the generatedscheduleitem found by the `where` argument doesn't exist, create a new generatedscheduleitem with this data.
     */
    create: XOR<generatedscheduleitemCreateInput, generatedscheduleitemUncheckedCreateInput>
    /**
     * In case the generatedscheduleitem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<generatedscheduleitemUpdateInput, generatedscheduleitemUncheckedUpdateInput>
  }

  /**
   * generatedscheduleitem delete
   */
  export type generatedscheduleitemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    /**
     * Filter which generatedscheduleitem to delete.
     */
    where: generatedscheduleitemWhereUniqueInput
  }

  /**
   * generatedscheduleitem deleteMany
   */
  export type generatedscheduleitemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which generatedscheduleitems to delete
     */
    where?: generatedscheduleitemWhereInput
  }

  /**
   * generatedscheduleitem.fellowshiprosteritem
   */
  export type generatedscheduleitem$fellowshiprosteritemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    where?: fellowshiprosteritemWhereInput
  }

  /**
   * generatedscheduleitem.responsibility
   */
  export type generatedscheduleitem$responsibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    where?: responsibilityWhereInput
    orderBy?: responsibilityOrderByWithRelationInput | responsibilityOrderByWithRelationInput[]
    cursor?: responsibilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponsibilityScalarFieldEnum | ResponsibilityScalarFieldEnum[]
  }

  /**
   * generatedscheduleitem without action
   */
  export type generatedscheduleitemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
  }


  /**
   * Model group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    creatorId: string | null
    groupImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    editSettings: $Enums.group_editSettings | null
    sendMessage: $Enums.group_sendMessage | null
    addMembers: $Enums.group_addMembers | null
    approveMembers: $Enums.group_approveMembers | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    creatorId: string | null
    groupImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    editSettings: $Enums.group_editSettings | null
    sendMessage: $Enums.group_sendMessage | null
    addMembers: $Enums.group_addMembers | null
    approveMembers: $Enums.group_approveMembers | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    creatorId: number
    groupImageUrl: number
    createdAt: number
    updatedAt: number
    editSettings: number
    sendMessage: number
    addMembers: number
    approveMembers: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    creatorId?: true
    groupImageUrl?: true
    createdAt?: true
    updatedAt?: true
    editSettings?: true
    sendMessage?: true
    addMembers?: true
    approveMembers?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    creatorId?: true
    groupImageUrl?: true
    createdAt?: true
    updatedAt?: true
    editSettings?: true
    sendMessage?: true
    addMembers?: true
    approveMembers?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    creatorId?: true
    groupImageUrl?: true
    createdAt?: true
    updatedAt?: true
    editSettings?: true
    sendMessage?: true
    addMembers?: true
    approveMembers?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which group to aggregate.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type groupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupWhereInput
    orderBy?: groupOrderByWithAggregationInput | groupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    creatorId: string
    groupImageUrl: string | null
    createdAt: Date
    updatedAt: Date
    editSettings: $Enums.group_editSettings
    sendMessage: $Enums.group_sendMessage
    addMembers: $Enums.group_addMembers
    approveMembers: $Enums.group_approveMembers
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type groupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatorId?: boolean
    groupImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    editSettings?: boolean
    sendMessage?: boolean
    addMembers?: boolean
    approveMembers?: boolean
    groupmember?: boolean | group$groupmemberArgs<ExtArgs>
    groupmessage?: boolean | group$groupmessageArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>


  export type groupSelectScalar = {
    id?: boolean
    name?: boolean
    creatorId?: boolean
    groupImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    editSettings?: boolean
    sendMessage?: boolean
    addMembers?: boolean
    approveMembers?: boolean
  }

  export type groupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupmember?: boolean | group$groupmemberArgs<ExtArgs>
    groupmessage?: boolean | group$groupmessageArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $groupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "group"
    objects: {
      groupmember: Prisma.$groupmemberPayload<ExtArgs>[]
      groupmessage: Prisma.$groupmessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      creatorId: string
      groupImageUrl: string | null
      createdAt: Date
      updatedAt: Date
      editSettings: $Enums.group_editSettings
      sendMessage: $Enums.group_sendMessage
      addMembers: $Enums.group_addMembers
      approveMembers: $Enums.group_approveMembers
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type groupGetPayload<S extends boolean | null | undefined | groupDefaultArgs> = $Result.GetResult<Prisma.$groupPayload, S>

  type groupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface groupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group'], meta: { name: 'group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {groupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupFindUniqueArgs>(args: SelectSubset<T, groupFindUniqueArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {groupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupFindUniqueOrThrowArgs>(args: SelectSubset<T, groupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupFindFirstArgs>(args?: SelectSubset<T, groupFindFirstArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupFindFirstOrThrowArgs>(args?: SelectSubset<T, groupFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupFindManyArgs>(args?: SelectSubset<T, groupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group.
     * @param {groupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends groupCreateArgs>(args: SelectSubset<T, groupCreateArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {groupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupCreateManyArgs>(args?: SelectSubset<T, groupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {groupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends groupDeleteArgs>(args: SelectSubset<T, groupDeleteArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group.
     * @param {groupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupUpdateArgs>(args: SelectSubset<T, groupUpdateArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {groupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupDeleteManyArgs>(args?: SelectSubset<T, groupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupUpdateManyArgs>(args: SelectSubset<T, groupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {groupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends groupUpsertArgs>(args: SelectSubset<T, groupUpsertArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends groupCountArgs>(
      args?: Subset<T, groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupGroupByArgs['orderBy'] }
        : { orderBy?: groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group model
   */
  readonly fields: groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupmember<T extends group$groupmemberArgs<ExtArgs> = {}>(args?: Subset<T, group$groupmemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "findMany"> | Null>
    groupmessage<T extends group$groupmessageArgs<ExtArgs> = {}>(args?: Subset<T, group$groupmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the group model
   */ 
  interface groupFieldRefs {
    readonly id: FieldRef<"group", 'String'>
    readonly name: FieldRef<"group", 'String'>
    readonly creatorId: FieldRef<"group", 'String'>
    readonly groupImageUrl: FieldRef<"group", 'String'>
    readonly createdAt: FieldRef<"group", 'DateTime'>
    readonly updatedAt: FieldRef<"group", 'DateTime'>
    readonly editSettings: FieldRef<"group", 'group_editSettings'>
    readonly sendMessage: FieldRef<"group", 'group_sendMessage'>
    readonly addMembers: FieldRef<"group", 'group_addMembers'>
    readonly approveMembers: FieldRef<"group", 'group_approveMembers'>
  }
    

  // Custom InputTypes
  /**
   * group findUnique
   */
  export type groupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group findUniqueOrThrow
   */
  export type groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group findFirst
   */
  export type groupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group findFirstOrThrow
   */
  export type groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group findMany
   */
  export type groupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * group create
   */
  export type groupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to create a group.
     */
    data: XOR<groupCreateInput, groupUncheckedCreateInput>
  }

  /**
   * group createMany
   */
  export type groupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups.
     */
    data: groupCreateManyInput | groupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * group update
   */
  export type groupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to update a group.
     */
    data: XOR<groupUpdateInput, groupUncheckedUpdateInput>
    /**
     * Choose, which group to update.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group updateMany
   */
  export type groupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups.
     */
    data: XOR<groupUpdateManyMutationInput, groupUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupWhereInput
  }

  /**
   * group upsert
   */
  export type groupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The filter to search for the group to update in case it exists.
     */
    where: groupWhereUniqueInput
    /**
     * In case the group found by the `where` argument doesn't exist, create a new group with this data.
     */
    create: XOR<groupCreateInput, groupUncheckedCreateInput>
    /**
     * In case the group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupUpdateInput, groupUncheckedUpdateInput>
  }

  /**
   * group delete
   */
  export type groupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter which group to delete.
     */
    where: groupWhereUniqueInput
  }

  /**
   * group deleteMany
   */
  export type groupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to delete
     */
    where?: groupWhereInput
  }

  /**
   * group.groupmember
   */
  export type group$groupmemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    where?: groupmemberWhereInput
    orderBy?: groupmemberOrderByWithRelationInput | groupmemberOrderByWithRelationInput[]
    cursor?: groupmemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupmemberScalarFieldEnum | GroupmemberScalarFieldEnum[]
  }

  /**
   * group.groupmessage
   */
  export type group$groupmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    where?: groupmessageWhereInput
    orderBy?: groupmessageOrderByWithRelationInput | groupmessageOrderByWithRelationInput[]
    cursor?: groupmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupmessageScalarFieldEnum | GroupmessageScalarFieldEnum[]
  }

  /**
   * group without action
   */
  export type groupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupInclude<ExtArgs> | null
  }


  /**
   * Model groupmember
   */

  export type AggregateGroupmember = {
    _count: GroupmemberCountAggregateOutputType | null
    _min: GroupmemberMinAggregateOutputType | null
    _max: GroupmemberMaxAggregateOutputType | null
  }

  export type GroupmemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.groupmember_role | null
    addedAt: Date | null
  }

  export type GroupmemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.groupmember_role | null
    addedAt: Date | null
  }

  export type GroupmemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    role: number
    addedAt: number
    _all: number
  }


  export type GroupmemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    addedAt?: true
  }

  export type GroupmemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    addedAt?: true
  }

  export type GroupmemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    addedAt?: true
    _all?: true
  }

  export type GroupmemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupmember to aggregate.
     */
    where?: groupmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmemberOrderByWithRelationInput | groupmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groupmembers
    **/
    _count?: true | GroupmemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupmemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupmemberMaxAggregateInputType
  }

  export type GetGroupmemberAggregateType<T extends GroupmemberAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupmember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupmember[P]>
      : GetScalarType<T[P], AggregateGroupmember[P]>
  }




  export type groupmemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmemberWhereInput
    orderBy?: groupmemberOrderByWithAggregationInput | groupmemberOrderByWithAggregationInput[]
    by: GroupmemberScalarFieldEnum[] | GroupmemberScalarFieldEnum
    having?: groupmemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupmemberCountAggregateInputType | true
    _min?: GroupmemberMinAggregateInputType
    _max?: GroupmemberMaxAggregateInputType
  }

  export type GroupmemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    role: $Enums.groupmember_role
    addedAt: Date
    _count: GroupmemberCountAggregateOutputType | null
    _min: GroupmemberMinAggregateOutputType | null
    _max: GroupmemberMaxAggregateOutputType | null
  }

  type GetGroupmemberGroupByPayload<T extends groupmemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupmemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupmemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupmemberGroupByOutputType[P]>
            : GetScalarType<T[P], GroupmemberGroupByOutputType[P]>
        }
      >
    >


  export type groupmemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    addedAt?: boolean
    group?: boolean | groupDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupmember"]>


  export type groupmemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    addedAt?: boolean
  }

  export type groupmemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | groupDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $groupmemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groupmember"
    objects: {
      group: Prisma.$groupPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      role: $Enums.groupmember_role
      addedAt: Date
    }, ExtArgs["result"]["groupmember"]>
    composites: {}
  }

  type groupmemberGetPayload<S extends boolean | null | undefined | groupmemberDefaultArgs> = $Result.GetResult<Prisma.$groupmemberPayload, S>

  type groupmemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groupmemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupmemberCountAggregateInputType | true
    }

  export interface groupmemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groupmember'], meta: { name: 'groupmember' } }
    /**
     * Find zero or one Groupmember that matches the filter.
     * @param {groupmemberFindUniqueArgs} args - Arguments to find a Groupmember
     * @example
     * // Get one Groupmember
     * const groupmember = await prisma.groupmember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupmemberFindUniqueArgs>(args: SelectSubset<T, groupmemberFindUniqueArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Groupmember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {groupmemberFindUniqueOrThrowArgs} args - Arguments to find a Groupmember
     * @example
     * // Get one Groupmember
     * const groupmember = await prisma.groupmember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupmemberFindUniqueOrThrowArgs>(args: SelectSubset<T, groupmemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Groupmember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmemberFindFirstArgs} args - Arguments to find a Groupmember
     * @example
     * // Get one Groupmember
     * const groupmember = await prisma.groupmember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupmemberFindFirstArgs>(args?: SelectSubset<T, groupmemberFindFirstArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Groupmember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmemberFindFirstOrThrowArgs} args - Arguments to find a Groupmember
     * @example
     * // Get one Groupmember
     * const groupmember = await prisma.groupmember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupmemberFindFirstOrThrowArgs>(args?: SelectSubset<T, groupmemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groupmembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groupmembers
     * const groupmembers = await prisma.groupmember.findMany()
     * 
     * // Get first 10 Groupmembers
     * const groupmembers = await prisma.groupmember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupmemberWithIdOnly = await prisma.groupmember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupmemberFindManyArgs>(args?: SelectSubset<T, groupmemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Groupmember.
     * @param {groupmemberCreateArgs} args - Arguments to create a Groupmember.
     * @example
     * // Create one Groupmember
     * const Groupmember = await prisma.groupmember.create({
     *   data: {
     *     // ... data to create a Groupmember
     *   }
     * })
     * 
     */
    create<T extends groupmemberCreateArgs>(args: SelectSubset<T, groupmemberCreateArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groupmembers.
     * @param {groupmemberCreateManyArgs} args - Arguments to create many Groupmembers.
     * @example
     * // Create many Groupmembers
     * const groupmember = await prisma.groupmember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupmemberCreateManyArgs>(args?: SelectSubset<T, groupmemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groupmember.
     * @param {groupmemberDeleteArgs} args - Arguments to delete one Groupmember.
     * @example
     * // Delete one Groupmember
     * const Groupmember = await prisma.groupmember.delete({
     *   where: {
     *     // ... filter to delete one Groupmember
     *   }
     * })
     * 
     */
    delete<T extends groupmemberDeleteArgs>(args: SelectSubset<T, groupmemberDeleteArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Groupmember.
     * @param {groupmemberUpdateArgs} args - Arguments to update one Groupmember.
     * @example
     * // Update one Groupmember
     * const groupmember = await prisma.groupmember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupmemberUpdateArgs>(args: SelectSubset<T, groupmemberUpdateArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groupmembers.
     * @param {groupmemberDeleteManyArgs} args - Arguments to filter Groupmembers to delete.
     * @example
     * // Delete a few Groupmembers
     * const { count } = await prisma.groupmember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupmemberDeleteManyArgs>(args?: SelectSubset<T, groupmemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groupmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groupmembers
     * const groupmember = await prisma.groupmember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupmemberUpdateManyArgs>(args: SelectSubset<T, groupmemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groupmember.
     * @param {groupmemberUpsertArgs} args - Arguments to update or create a Groupmember.
     * @example
     * // Update or create a Groupmember
     * const groupmember = await prisma.groupmember.upsert({
     *   create: {
     *     // ... data to create a Groupmember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groupmember we want to update
     *   }
     * })
     */
    upsert<T extends groupmemberUpsertArgs>(args: SelectSubset<T, groupmemberUpsertArgs<ExtArgs>>): Prisma__groupmemberClient<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groupmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmemberCountArgs} args - Arguments to filter Groupmembers to count.
     * @example
     * // Count the number of Groupmembers
     * const count = await prisma.groupmember.count({
     *   where: {
     *     // ... the filter for the Groupmembers we want to count
     *   }
     * })
    **/
    count<T extends groupmemberCountArgs>(
      args?: Subset<T, groupmemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupmemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groupmember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupmemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupmemberAggregateArgs>(args: Subset<T, GroupmemberAggregateArgs>): Prisma.PrismaPromise<GetGroupmemberAggregateType<T>>

    /**
     * Group by Groupmember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupmemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupmemberGroupByArgs['orderBy'] }
        : { orderBy?: groupmemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupmemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupmemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groupmember model
   */
  readonly fields: groupmemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groupmember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupmemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupDefaultArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the groupmember model
   */ 
  interface groupmemberFieldRefs {
    readonly id: FieldRef<"groupmember", 'String'>
    readonly groupId: FieldRef<"groupmember", 'String'>
    readonly userId: FieldRef<"groupmember", 'String'>
    readonly role: FieldRef<"groupmember", 'groupmember_role'>
    readonly addedAt: FieldRef<"groupmember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * groupmember findUnique
   */
  export type groupmemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * Filter, which groupmember to fetch.
     */
    where: groupmemberWhereUniqueInput
  }

  /**
   * groupmember findUniqueOrThrow
   */
  export type groupmemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * Filter, which groupmember to fetch.
     */
    where: groupmemberWhereUniqueInput
  }

  /**
   * groupmember findFirst
   */
  export type groupmemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * Filter, which groupmember to fetch.
     */
    where?: groupmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmemberOrderByWithRelationInput | groupmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupmembers.
     */
    cursor?: groupmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupmembers.
     */
    distinct?: GroupmemberScalarFieldEnum | GroupmemberScalarFieldEnum[]
  }

  /**
   * groupmember findFirstOrThrow
   */
  export type groupmemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * Filter, which groupmember to fetch.
     */
    where?: groupmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmemberOrderByWithRelationInput | groupmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupmembers.
     */
    cursor?: groupmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupmembers.
     */
    distinct?: GroupmemberScalarFieldEnum | GroupmemberScalarFieldEnum[]
  }

  /**
   * groupmember findMany
   */
  export type groupmemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * Filter, which groupmembers to fetch.
     */
    where?: groupmemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmemberOrderByWithRelationInput | groupmemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groupmembers.
     */
    cursor?: groupmemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    distinct?: GroupmemberScalarFieldEnum | GroupmemberScalarFieldEnum[]
  }

  /**
   * groupmember create
   */
  export type groupmemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * The data needed to create a groupmember.
     */
    data: XOR<groupmemberCreateInput, groupmemberUncheckedCreateInput>
  }

  /**
   * groupmember createMany
   */
  export type groupmemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groupmembers.
     */
    data: groupmemberCreateManyInput | groupmemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * groupmember update
   */
  export type groupmemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * The data needed to update a groupmember.
     */
    data: XOR<groupmemberUpdateInput, groupmemberUncheckedUpdateInput>
    /**
     * Choose, which groupmember to update.
     */
    where: groupmemberWhereUniqueInput
  }

  /**
   * groupmember updateMany
   */
  export type groupmemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groupmembers.
     */
    data: XOR<groupmemberUpdateManyMutationInput, groupmemberUncheckedUpdateManyInput>
    /**
     * Filter which groupmembers to update
     */
    where?: groupmemberWhereInput
  }

  /**
   * groupmember upsert
   */
  export type groupmemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * The filter to search for the groupmember to update in case it exists.
     */
    where: groupmemberWhereUniqueInput
    /**
     * In case the groupmember found by the `where` argument doesn't exist, create a new groupmember with this data.
     */
    create: XOR<groupmemberCreateInput, groupmemberUncheckedCreateInput>
    /**
     * In case the groupmember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupmemberUpdateInput, groupmemberUncheckedUpdateInput>
  }

  /**
   * groupmember delete
   */
  export type groupmemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    /**
     * Filter which groupmember to delete.
     */
    where: groupmemberWhereUniqueInput
  }

  /**
   * groupmember deleteMany
   */
  export type groupmemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupmembers to delete
     */
    where?: groupmemberWhereInput
  }

  /**
   * groupmember without action
   */
  export type groupmemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
  }


  /**
   * Model groupmessage
   */

  export type AggregateGroupmessage = {
    _count: GroupmessageCountAggregateOutputType | null
    _min: GroupmessageMinAggregateOutputType | null
    _max: GroupmessageMaxAggregateOutputType | null
  }

  export type GroupmessageMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    senderId: string | null
    senderName: string | null
    senderProfileImageUrl: string | null
    text: string | null
    mediaUrl: string | null
    mediaType: $Enums.groupmessage_mediaType | null
    timestamp: Date | null
  }

  export type GroupmessageMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    senderId: string | null
    senderName: string | null
    senderProfileImageUrl: string | null
    text: string | null
    mediaUrl: string | null
    mediaType: $Enums.groupmessage_mediaType | null
    timestamp: Date | null
  }

  export type GroupmessageCountAggregateOutputType = {
    id: number
    groupId: number
    senderId: number
    senderName: number
    senderProfileImageUrl: number
    text: number
    mediaUrl: number
    mediaType: number
    timestamp: number
    _all: number
  }


  export type GroupmessageMinAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    senderName?: true
    senderProfileImageUrl?: true
    text?: true
    mediaUrl?: true
    mediaType?: true
    timestamp?: true
  }

  export type GroupmessageMaxAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    senderName?: true
    senderProfileImageUrl?: true
    text?: true
    mediaUrl?: true
    mediaType?: true
    timestamp?: true
  }

  export type GroupmessageCountAggregateInputType = {
    id?: true
    groupId?: true
    senderId?: true
    senderName?: true
    senderProfileImageUrl?: true
    text?: true
    mediaUrl?: true
    mediaType?: true
    timestamp?: true
    _all?: true
  }

  export type GroupmessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupmessage to aggregate.
     */
    where?: groupmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmessages to fetch.
     */
    orderBy?: groupmessageOrderByWithRelationInput | groupmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groupmessages
    **/
    _count?: true | GroupmessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupmessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupmessageMaxAggregateInputType
  }

  export type GetGroupmessageAggregateType<T extends GroupmessageAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupmessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupmessage[P]>
      : GetScalarType<T[P], AggregateGroupmessage[P]>
  }




  export type groupmessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmessageWhereInput
    orderBy?: groupmessageOrderByWithAggregationInput | groupmessageOrderByWithAggregationInput[]
    by: GroupmessageScalarFieldEnum[] | GroupmessageScalarFieldEnum
    having?: groupmessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupmessageCountAggregateInputType | true
    _min?: GroupmessageMinAggregateInputType
    _max?: GroupmessageMaxAggregateInputType
  }

  export type GroupmessageGroupByOutputType = {
    id: string
    groupId: string
    senderId: string
    senderName: string
    senderProfileImageUrl: string | null
    text: string | null
    mediaUrl: string | null
    mediaType: $Enums.groupmessage_mediaType | null
    timestamp: Date
    _count: GroupmessageCountAggregateOutputType | null
    _min: GroupmessageMinAggregateOutputType | null
    _max: GroupmessageMaxAggregateOutputType | null
  }

  type GetGroupmessageGroupByPayload<T extends groupmessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupmessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupmessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupmessageGroupByOutputType[P]>
            : GetScalarType<T[P], GroupmessageGroupByOutputType[P]>
        }
      >
    >


  export type groupmessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    senderName?: boolean
    senderProfileImageUrl?: boolean
    text?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    timestamp?: boolean
    group?: boolean | groupDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupmessage"]>


  export type groupmessageSelectScalar = {
    id?: boolean
    groupId?: boolean
    senderId?: boolean
    senderName?: boolean
    senderProfileImageUrl?: boolean
    text?: boolean
    mediaUrl?: boolean
    mediaType?: boolean
    timestamp?: boolean
  }

  export type groupmessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | groupDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $groupmessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groupmessage"
    objects: {
      group: Prisma.$groupPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      senderId: string
      senderName: string
      senderProfileImageUrl: string | null
      text: string | null
      mediaUrl: string | null
      mediaType: $Enums.groupmessage_mediaType | null
      timestamp: Date
    }, ExtArgs["result"]["groupmessage"]>
    composites: {}
  }

  type groupmessageGetPayload<S extends boolean | null | undefined | groupmessageDefaultArgs> = $Result.GetResult<Prisma.$groupmessagePayload, S>

  type groupmessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groupmessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupmessageCountAggregateInputType | true
    }

  export interface groupmessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groupmessage'], meta: { name: 'groupmessage' } }
    /**
     * Find zero or one Groupmessage that matches the filter.
     * @param {groupmessageFindUniqueArgs} args - Arguments to find a Groupmessage
     * @example
     * // Get one Groupmessage
     * const groupmessage = await prisma.groupmessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupmessageFindUniqueArgs>(args: SelectSubset<T, groupmessageFindUniqueArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Groupmessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {groupmessageFindUniqueOrThrowArgs} args - Arguments to find a Groupmessage
     * @example
     * // Get one Groupmessage
     * const groupmessage = await prisma.groupmessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupmessageFindUniqueOrThrowArgs>(args: SelectSubset<T, groupmessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Groupmessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmessageFindFirstArgs} args - Arguments to find a Groupmessage
     * @example
     * // Get one Groupmessage
     * const groupmessage = await prisma.groupmessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupmessageFindFirstArgs>(args?: SelectSubset<T, groupmessageFindFirstArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Groupmessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmessageFindFirstOrThrowArgs} args - Arguments to find a Groupmessage
     * @example
     * // Get one Groupmessage
     * const groupmessage = await prisma.groupmessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupmessageFindFirstOrThrowArgs>(args?: SelectSubset<T, groupmessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groupmessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groupmessages
     * const groupmessages = await prisma.groupmessage.findMany()
     * 
     * // Get first 10 Groupmessages
     * const groupmessages = await prisma.groupmessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupmessageWithIdOnly = await prisma.groupmessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupmessageFindManyArgs>(args?: SelectSubset<T, groupmessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Groupmessage.
     * @param {groupmessageCreateArgs} args - Arguments to create a Groupmessage.
     * @example
     * // Create one Groupmessage
     * const Groupmessage = await prisma.groupmessage.create({
     *   data: {
     *     // ... data to create a Groupmessage
     *   }
     * })
     * 
     */
    create<T extends groupmessageCreateArgs>(args: SelectSubset<T, groupmessageCreateArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groupmessages.
     * @param {groupmessageCreateManyArgs} args - Arguments to create many Groupmessages.
     * @example
     * // Create many Groupmessages
     * const groupmessage = await prisma.groupmessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupmessageCreateManyArgs>(args?: SelectSubset<T, groupmessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groupmessage.
     * @param {groupmessageDeleteArgs} args - Arguments to delete one Groupmessage.
     * @example
     * // Delete one Groupmessage
     * const Groupmessage = await prisma.groupmessage.delete({
     *   where: {
     *     // ... filter to delete one Groupmessage
     *   }
     * })
     * 
     */
    delete<T extends groupmessageDeleteArgs>(args: SelectSubset<T, groupmessageDeleteArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Groupmessage.
     * @param {groupmessageUpdateArgs} args - Arguments to update one Groupmessage.
     * @example
     * // Update one Groupmessage
     * const groupmessage = await prisma.groupmessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupmessageUpdateArgs>(args: SelectSubset<T, groupmessageUpdateArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groupmessages.
     * @param {groupmessageDeleteManyArgs} args - Arguments to filter Groupmessages to delete.
     * @example
     * // Delete a few Groupmessages
     * const { count } = await prisma.groupmessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupmessageDeleteManyArgs>(args?: SelectSubset<T, groupmessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groupmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groupmessages
     * const groupmessage = await prisma.groupmessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupmessageUpdateManyArgs>(args: SelectSubset<T, groupmessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groupmessage.
     * @param {groupmessageUpsertArgs} args - Arguments to update or create a Groupmessage.
     * @example
     * // Update or create a Groupmessage
     * const groupmessage = await prisma.groupmessage.upsert({
     *   create: {
     *     // ... data to create a Groupmessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groupmessage we want to update
     *   }
     * })
     */
    upsert<T extends groupmessageUpsertArgs>(args: SelectSubset<T, groupmessageUpsertArgs<ExtArgs>>): Prisma__groupmessageClient<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groupmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmessageCountArgs} args - Arguments to filter Groupmessages to count.
     * @example
     * // Count the number of Groupmessages
     * const count = await prisma.groupmessage.count({
     *   where: {
     *     // ... the filter for the Groupmessages we want to count
     *   }
     * })
    **/
    count<T extends groupmessageCountArgs>(
      args?: Subset<T, groupmessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupmessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groupmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupmessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupmessageAggregateArgs>(args: Subset<T, GroupmessageAggregateArgs>): Prisma.PrismaPromise<GetGroupmessageAggregateType<T>>

    /**
     * Group by Groupmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupmessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupmessageGroupByArgs['orderBy'] }
        : { orderBy?: groupmessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupmessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupmessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groupmessage model
   */
  readonly fields: groupmessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groupmessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupmessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends groupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupDefaultArgs<ExtArgs>>): Prisma__groupClient<$Result.GetResult<Prisma.$groupPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the groupmessage model
   */ 
  interface groupmessageFieldRefs {
    readonly id: FieldRef<"groupmessage", 'String'>
    readonly groupId: FieldRef<"groupmessage", 'String'>
    readonly senderId: FieldRef<"groupmessage", 'String'>
    readonly senderName: FieldRef<"groupmessage", 'String'>
    readonly senderProfileImageUrl: FieldRef<"groupmessage", 'String'>
    readonly text: FieldRef<"groupmessage", 'String'>
    readonly mediaUrl: FieldRef<"groupmessage", 'String'>
    readonly mediaType: FieldRef<"groupmessage", 'groupmessage_mediaType'>
    readonly timestamp: FieldRef<"groupmessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * groupmessage findUnique
   */
  export type groupmessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * Filter, which groupmessage to fetch.
     */
    where: groupmessageWhereUniqueInput
  }

  /**
   * groupmessage findUniqueOrThrow
   */
  export type groupmessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * Filter, which groupmessage to fetch.
     */
    where: groupmessageWhereUniqueInput
  }

  /**
   * groupmessage findFirst
   */
  export type groupmessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * Filter, which groupmessage to fetch.
     */
    where?: groupmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmessages to fetch.
     */
    orderBy?: groupmessageOrderByWithRelationInput | groupmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupmessages.
     */
    cursor?: groupmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupmessages.
     */
    distinct?: GroupmessageScalarFieldEnum | GroupmessageScalarFieldEnum[]
  }

  /**
   * groupmessage findFirstOrThrow
   */
  export type groupmessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * Filter, which groupmessage to fetch.
     */
    where?: groupmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmessages to fetch.
     */
    orderBy?: groupmessageOrderByWithRelationInput | groupmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupmessages.
     */
    cursor?: groupmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupmessages.
     */
    distinct?: GroupmessageScalarFieldEnum | GroupmessageScalarFieldEnum[]
  }

  /**
   * groupmessage findMany
   */
  export type groupmessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * Filter, which groupmessages to fetch.
     */
    where?: groupmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmessages to fetch.
     */
    orderBy?: groupmessageOrderByWithRelationInput | groupmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groupmessages.
     */
    cursor?: groupmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmessages.
     */
    skip?: number
    distinct?: GroupmessageScalarFieldEnum | GroupmessageScalarFieldEnum[]
  }

  /**
   * groupmessage create
   */
  export type groupmessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * The data needed to create a groupmessage.
     */
    data: XOR<groupmessageCreateInput, groupmessageUncheckedCreateInput>
  }

  /**
   * groupmessage createMany
   */
  export type groupmessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groupmessages.
     */
    data: groupmessageCreateManyInput | groupmessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * groupmessage update
   */
  export type groupmessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * The data needed to update a groupmessage.
     */
    data: XOR<groupmessageUpdateInput, groupmessageUncheckedUpdateInput>
    /**
     * Choose, which groupmessage to update.
     */
    where: groupmessageWhereUniqueInput
  }

  /**
   * groupmessage updateMany
   */
  export type groupmessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groupmessages.
     */
    data: XOR<groupmessageUpdateManyMutationInput, groupmessageUncheckedUpdateManyInput>
    /**
     * Filter which groupmessages to update
     */
    where?: groupmessageWhereInput
  }

  /**
   * groupmessage upsert
   */
  export type groupmessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * The filter to search for the groupmessage to update in case it exists.
     */
    where: groupmessageWhereUniqueInput
    /**
     * In case the groupmessage found by the `where` argument doesn't exist, create a new groupmessage with this data.
     */
    create: XOR<groupmessageCreateInput, groupmessageUncheckedCreateInput>
    /**
     * In case the groupmessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupmessageUpdateInput, groupmessageUncheckedUpdateInput>
  }

  /**
   * groupmessage delete
   */
  export type groupmessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    /**
     * Filter which groupmessage to delete.
     */
    where: groupmessageWhereUniqueInput
  }

  /**
   * groupmessage deleteMany
   */
  export type groupmessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupmessages to delete
     */
    where?: groupmessageWhereInput
  }

  /**
   * groupmessage without action
   */
  export type groupmessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
  }


  /**
   * Model historychapter
   */

  export type AggregateHistorychapter = {
    _count: HistorychapterCountAggregateOutputType | null
    _avg: HistorychapterAvgAggregateOutputType | null
    _sum: HistorychapterSumAggregateOutputType | null
    _min: HistorychapterMinAggregateOutputType | null
    _max: HistorychapterMaxAggregateOutputType | null
  }

  export type HistorychapterAvgAggregateOutputType = {
    chapterNumber: number | null
    likes: number | null
  }

  export type HistorychapterSumAggregateOutputType = {
    chapterNumber: number | null
    likes: number | null
  }

  export type HistorychapterMinAggregateOutputType = {
    id: string | null
    chapterNumber: number | null
    title: string | null
    content: string | null
    status: $Enums.historychapter_status | null
    imageUrl: string | null
    summary: string | null
    authorId: string | null
    authorName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastPublishedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    likes: number | null
  }

  export type HistorychapterMaxAggregateOutputType = {
    id: string | null
    chapterNumber: number | null
    title: string | null
    content: string | null
    status: $Enums.historychapter_status | null
    imageUrl: string | null
    summary: string | null
    authorId: string | null
    authorName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastPublishedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    likes: number | null
  }

  export type HistorychapterCountAggregateOutputType = {
    id: number
    chapterNumber: number
    title: number
    content: number
    status: number
    imageUrl: number
    summary: number
    authorId: number
    authorName: number
    createdAt: number
    updatedAt: number
    lastPublishedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    likes: number
    _all: number
  }


  export type HistorychapterAvgAggregateInputType = {
    chapterNumber?: true
    likes?: true
  }

  export type HistorychapterSumAggregateInputType = {
    chapterNumber?: true
    likes?: true
  }

  export type HistorychapterMinAggregateInputType = {
    id?: true
    chapterNumber?: true
    title?: true
    content?: true
    status?: true
    imageUrl?: true
    summary?: true
    authorId?: true
    authorName?: true
    createdAt?: true
    updatedAt?: true
    lastPublishedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    likes?: true
  }

  export type HistorychapterMaxAggregateInputType = {
    id?: true
    chapterNumber?: true
    title?: true
    content?: true
    status?: true
    imageUrl?: true
    summary?: true
    authorId?: true
    authorName?: true
    createdAt?: true
    updatedAt?: true
    lastPublishedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    likes?: true
  }

  export type HistorychapterCountAggregateInputType = {
    id?: true
    chapterNumber?: true
    title?: true
    content?: true
    status?: true
    imageUrl?: true
    summary?: true
    authorId?: true
    authorName?: true
    createdAt?: true
    updatedAt?: true
    lastPublishedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    likes?: true
    _all?: true
  }

  export type HistorychapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historychapter to aggregate.
     */
    where?: historychapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historychapters to fetch.
     */
    orderBy?: historychapterOrderByWithRelationInput | historychapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historychapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historychapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historychapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historychapters
    **/
    _count?: true | HistorychapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorychapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorychapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorychapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorychapterMaxAggregateInputType
  }

  export type GetHistorychapterAggregateType<T extends HistorychapterAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorychapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorychapter[P]>
      : GetScalarType<T[P], AggregateHistorychapter[P]>
  }




  export type historychapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historychapterWhereInput
    orderBy?: historychapterOrderByWithAggregationInput | historychapterOrderByWithAggregationInput[]
    by: HistorychapterScalarFieldEnum[] | HistorychapterScalarFieldEnum
    having?: historychapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorychapterCountAggregateInputType | true
    _avg?: HistorychapterAvgAggregateInputType
    _sum?: HistorychapterSumAggregateInputType
    _min?: HistorychapterMinAggregateInputType
    _max?: HistorychapterMaxAggregateInputType
  }

  export type HistorychapterGroupByOutputType = {
    id: string
    chapterNumber: number
    title: string
    content: string
    status: $Enums.historychapter_status
    imageUrl: string | null
    summary: string | null
    authorId: string | null
    authorName: string | null
    createdAt: Date
    updatedAt: Date
    lastPublishedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    likes: number
    _count: HistorychapterCountAggregateOutputType | null
    _avg: HistorychapterAvgAggregateOutputType | null
    _sum: HistorychapterSumAggregateOutputType | null
    _min: HistorychapterMinAggregateOutputType | null
    _max: HistorychapterMaxAggregateOutputType | null
  }

  type GetHistorychapterGroupByPayload<T extends historychapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorychapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorychapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorychapterGroupByOutputType[P]>
            : GetScalarType<T[P], HistorychapterGroupByOutputType[P]>
        }
      >
    >


  export type historychapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterNumber?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    imageUrl?: boolean
    summary?: boolean
    authorId?: boolean
    authorName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPublishedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    likes?: boolean
    comment?: boolean | historychapter$commentArgs<ExtArgs>
    _count?: boolean | HistorychapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historychapter"]>


  export type historychapterSelectScalar = {
    id?: boolean
    chapterNumber?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    imageUrl?: boolean
    summary?: boolean
    authorId?: boolean
    authorName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastPublishedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    likes?: boolean
  }

  export type historychapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | historychapter$commentArgs<ExtArgs>
    _count?: boolean | HistorychapterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $historychapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "historychapter"
    objects: {
      comment: Prisma.$commentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chapterNumber: number
      title: string
      content: string
      status: $Enums.historychapter_status
      imageUrl: string | null
      summary: string | null
      authorId: string | null
      authorName: string | null
      createdAt: Date
      updatedAt: Date
      lastPublishedAt: Date | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      likes: number
    }, ExtArgs["result"]["historychapter"]>
    composites: {}
  }

  type historychapterGetPayload<S extends boolean | null | undefined | historychapterDefaultArgs> = $Result.GetResult<Prisma.$historychapterPayload, S>

  type historychapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<historychapterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorychapterCountAggregateInputType | true
    }

  export interface historychapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historychapter'], meta: { name: 'historychapter' } }
    /**
     * Find zero or one Historychapter that matches the filter.
     * @param {historychapterFindUniqueArgs} args - Arguments to find a Historychapter
     * @example
     * // Get one Historychapter
     * const historychapter = await prisma.historychapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historychapterFindUniqueArgs>(args: SelectSubset<T, historychapterFindUniqueArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Historychapter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {historychapterFindUniqueOrThrowArgs} args - Arguments to find a Historychapter
     * @example
     * // Get one Historychapter
     * const historychapter = await prisma.historychapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historychapterFindUniqueOrThrowArgs>(args: SelectSubset<T, historychapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Historychapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historychapterFindFirstArgs} args - Arguments to find a Historychapter
     * @example
     * // Get one Historychapter
     * const historychapter = await prisma.historychapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historychapterFindFirstArgs>(args?: SelectSubset<T, historychapterFindFirstArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Historychapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historychapterFindFirstOrThrowArgs} args - Arguments to find a Historychapter
     * @example
     * // Get one Historychapter
     * const historychapter = await prisma.historychapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historychapterFindFirstOrThrowArgs>(args?: SelectSubset<T, historychapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Historychapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historychapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historychapters
     * const historychapters = await prisma.historychapter.findMany()
     * 
     * // Get first 10 Historychapters
     * const historychapters = await prisma.historychapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historychapterWithIdOnly = await prisma.historychapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historychapterFindManyArgs>(args?: SelectSubset<T, historychapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Historychapter.
     * @param {historychapterCreateArgs} args - Arguments to create a Historychapter.
     * @example
     * // Create one Historychapter
     * const Historychapter = await prisma.historychapter.create({
     *   data: {
     *     // ... data to create a Historychapter
     *   }
     * })
     * 
     */
    create<T extends historychapterCreateArgs>(args: SelectSubset<T, historychapterCreateArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Historychapters.
     * @param {historychapterCreateManyArgs} args - Arguments to create many Historychapters.
     * @example
     * // Create many Historychapters
     * const historychapter = await prisma.historychapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historychapterCreateManyArgs>(args?: SelectSubset<T, historychapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historychapter.
     * @param {historychapterDeleteArgs} args - Arguments to delete one Historychapter.
     * @example
     * // Delete one Historychapter
     * const Historychapter = await prisma.historychapter.delete({
     *   where: {
     *     // ... filter to delete one Historychapter
     *   }
     * })
     * 
     */
    delete<T extends historychapterDeleteArgs>(args: SelectSubset<T, historychapterDeleteArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Historychapter.
     * @param {historychapterUpdateArgs} args - Arguments to update one Historychapter.
     * @example
     * // Update one Historychapter
     * const historychapter = await prisma.historychapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historychapterUpdateArgs>(args: SelectSubset<T, historychapterUpdateArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Historychapters.
     * @param {historychapterDeleteManyArgs} args - Arguments to filter Historychapters to delete.
     * @example
     * // Delete a few Historychapters
     * const { count } = await prisma.historychapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historychapterDeleteManyArgs>(args?: SelectSubset<T, historychapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historychapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historychapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historychapters
     * const historychapter = await prisma.historychapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historychapterUpdateManyArgs>(args: SelectSubset<T, historychapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historychapter.
     * @param {historychapterUpsertArgs} args - Arguments to update or create a Historychapter.
     * @example
     * // Update or create a Historychapter
     * const historychapter = await prisma.historychapter.upsert({
     *   create: {
     *     // ... data to create a Historychapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historychapter we want to update
     *   }
     * })
     */
    upsert<T extends historychapterUpsertArgs>(args: SelectSubset<T, historychapterUpsertArgs<ExtArgs>>): Prisma__historychapterClient<$Result.GetResult<Prisma.$historychapterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Historychapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historychapterCountArgs} args - Arguments to filter Historychapters to count.
     * @example
     * // Count the number of Historychapters
     * const count = await prisma.historychapter.count({
     *   where: {
     *     // ... the filter for the Historychapters we want to count
     *   }
     * })
    **/
    count<T extends historychapterCountArgs>(
      args?: Subset<T, historychapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorychapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historychapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorychapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorychapterAggregateArgs>(args: Subset<T, HistorychapterAggregateArgs>): Prisma.PrismaPromise<GetHistorychapterAggregateType<T>>

    /**
     * Group by Historychapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historychapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historychapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historychapterGroupByArgs['orderBy'] }
        : { orderBy?: historychapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historychapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorychapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the historychapter model
   */
  readonly fields: historychapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for historychapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historychapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends historychapter$commentArgs<ExtArgs> = {}>(args?: Subset<T, historychapter$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the historychapter model
   */ 
  interface historychapterFieldRefs {
    readonly id: FieldRef<"historychapter", 'String'>
    readonly chapterNumber: FieldRef<"historychapter", 'Int'>
    readonly title: FieldRef<"historychapter", 'String'>
    readonly content: FieldRef<"historychapter", 'String'>
    readonly status: FieldRef<"historychapter", 'historychapter_status'>
    readonly imageUrl: FieldRef<"historychapter", 'String'>
    readonly summary: FieldRef<"historychapter", 'String'>
    readonly authorId: FieldRef<"historychapter", 'String'>
    readonly authorName: FieldRef<"historychapter", 'String'>
    readonly createdAt: FieldRef<"historychapter", 'DateTime'>
    readonly updatedAt: FieldRef<"historychapter", 'DateTime'>
    readonly lastPublishedAt: FieldRef<"historychapter", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"historychapter", 'String'>
    readonly postedByOwnerName: FieldRef<"historychapter", 'String'>
    readonly likes: FieldRef<"historychapter", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * historychapter findUnique
   */
  export type historychapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * Filter, which historychapter to fetch.
     */
    where: historychapterWhereUniqueInput
  }

  /**
   * historychapter findUniqueOrThrow
   */
  export type historychapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * Filter, which historychapter to fetch.
     */
    where: historychapterWhereUniqueInput
  }

  /**
   * historychapter findFirst
   */
  export type historychapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * Filter, which historychapter to fetch.
     */
    where?: historychapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historychapters to fetch.
     */
    orderBy?: historychapterOrderByWithRelationInput | historychapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historychapters.
     */
    cursor?: historychapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historychapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historychapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historychapters.
     */
    distinct?: HistorychapterScalarFieldEnum | HistorychapterScalarFieldEnum[]
  }

  /**
   * historychapter findFirstOrThrow
   */
  export type historychapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * Filter, which historychapter to fetch.
     */
    where?: historychapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historychapters to fetch.
     */
    orderBy?: historychapterOrderByWithRelationInput | historychapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historychapters.
     */
    cursor?: historychapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historychapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historychapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historychapters.
     */
    distinct?: HistorychapterScalarFieldEnum | HistorychapterScalarFieldEnum[]
  }

  /**
   * historychapter findMany
   */
  export type historychapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * Filter, which historychapters to fetch.
     */
    where?: historychapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historychapters to fetch.
     */
    orderBy?: historychapterOrderByWithRelationInput | historychapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historychapters.
     */
    cursor?: historychapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historychapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historychapters.
     */
    skip?: number
    distinct?: HistorychapterScalarFieldEnum | HistorychapterScalarFieldEnum[]
  }

  /**
   * historychapter create
   */
  export type historychapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * The data needed to create a historychapter.
     */
    data: XOR<historychapterCreateInput, historychapterUncheckedCreateInput>
  }

  /**
   * historychapter createMany
   */
  export type historychapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historychapters.
     */
    data: historychapterCreateManyInput | historychapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historychapter update
   */
  export type historychapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * The data needed to update a historychapter.
     */
    data: XOR<historychapterUpdateInput, historychapterUncheckedUpdateInput>
    /**
     * Choose, which historychapter to update.
     */
    where: historychapterWhereUniqueInput
  }

  /**
   * historychapter updateMany
   */
  export type historychapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historychapters.
     */
    data: XOR<historychapterUpdateManyMutationInput, historychapterUncheckedUpdateManyInput>
    /**
     * Filter which historychapters to update
     */
    where?: historychapterWhereInput
  }

  /**
   * historychapter upsert
   */
  export type historychapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * The filter to search for the historychapter to update in case it exists.
     */
    where: historychapterWhereUniqueInput
    /**
     * In case the historychapter found by the `where` argument doesn't exist, create a new historychapter with this data.
     */
    create: XOR<historychapterCreateInput, historychapterUncheckedCreateInput>
    /**
     * In case the historychapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historychapterUpdateInput, historychapterUncheckedUpdateInput>
  }

  /**
   * historychapter delete
   */
  export type historychapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
    /**
     * Filter which historychapter to delete.
     */
    where: historychapterWhereUniqueInput
  }

  /**
   * historychapter deleteMany
   */
  export type historychapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historychapters to delete
     */
    where?: historychapterWhereInput
  }

  /**
   * historychapter.comment
   */
  export type historychapter$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * historychapter without action
   */
  export type historychapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historychapter
     */
    select?: historychapterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historychapterInclude<ExtArgs> | null
  }


  /**
   * Model historymilestone
   */

  export type AggregateHistorymilestone = {
    _count: HistorymilestoneCountAggregateOutputType | null
    _min: HistorymilestoneMinAggregateOutputType | null
    _max: HistorymilestoneMaxAggregateOutputType | null
  }

  export type HistorymilestoneMinAggregateOutputType = {
    id: string | null
    year: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type HistorymilestoneMaxAggregateOutputType = {
    id: string | null
    year: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type HistorymilestoneCountAggregateOutputType = {
    id: number
    year: number
    title: number
    description: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    _all: number
  }


  export type HistorymilestoneMinAggregateInputType = {
    id?: true
    year?: true
    title?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type HistorymilestoneMaxAggregateInputType = {
    id?: true
    year?: true
    title?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type HistorymilestoneCountAggregateInputType = {
    id?: true
    year?: true
    title?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    _all?: true
  }

  export type HistorymilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historymilestone to aggregate.
     */
    where?: historymilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historymilestones to fetch.
     */
    orderBy?: historymilestoneOrderByWithRelationInput | historymilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historymilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historymilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historymilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned historymilestones
    **/
    _count?: true | HistorymilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorymilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorymilestoneMaxAggregateInputType
  }

  export type GetHistorymilestoneAggregateType<T extends HistorymilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorymilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorymilestone[P]>
      : GetScalarType<T[P], AggregateHistorymilestone[P]>
  }




  export type historymilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historymilestoneWhereInput
    orderBy?: historymilestoneOrderByWithAggregationInput | historymilestoneOrderByWithAggregationInput[]
    by: HistorymilestoneScalarFieldEnum[] | HistorymilestoneScalarFieldEnum
    having?: historymilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorymilestoneCountAggregateInputType | true
    _min?: HistorymilestoneMinAggregateInputType
    _max?: HistorymilestoneMaxAggregateInputType
  }

  export type HistorymilestoneGroupByOutputType = {
    id: string
    year: string
    title: string
    description: string
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    _count: HistorymilestoneCountAggregateOutputType | null
    _min: HistorymilestoneMinAggregateOutputType | null
    _max: HistorymilestoneMaxAggregateOutputType | null
  }

  type GetHistorymilestoneGroupByPayload<T extends historymilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorymilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorymilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorymilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], HistorymilestoneGroupByOutputType[P]>
        }
      >
    >


  export type historymilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }, ExtArgs["result"]["historymilestone"]>


  export type historymilestoneSelectScalar = {
    id?: boolean
    year?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }


  export type $historymilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "historymilestone"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: string
      title: string
      description: string
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
    }, ExtArgs["result"]["historymilestone"]>
    composites: {}
  }

  type historymilestoneGetPayload<S extends boolean | null | undefined | historymilestoneDefaultArgs> = $Result.GetResult<Prisma.$historymilestonePayload, S>

  type historymilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<historymilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorymilestoneCountAggregateInputType | true
    }

  export interface historymilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['historymilestone'], meta: { name: 'historymilestone' } }
    /**
     * Find zero or one Historymilestone that matches the filter.
     * @param {historymilestoneFindUniqueArgs} args - Arguments to find a Historymilestone
     * @example
     * // Get one Historymilestone
     * const historymilestone = await prisma.historymilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historymilestoneFindUniqueArgs>(args: SelectSubset<T, historymilestoneFindUniqueArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Historymilestone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {historymilestoneFindUniqueOrThrowArgs} args - Arguments to find a Historymilestone
     * @example
     * // Get one Historymilestone
     * const historymilestone = await prisma.historymilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historymilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, historymilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Historymilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historymilestoneFindFirstArgs} args - Arguments to find a Historymilestone
     * @example
     * // Get one Historymilestone
     * const historymilestone = await prisma.historymilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historymilestoneFindFirstArgs>(args?: SelectSubset<T, historymilestoneFindFirstArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Historymilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historymilestoneFindFirstOrThrowArgs} args - Arguments to find a Historymilestone
     * @example
     * // Get one Historymilestone
     * const historymilestone = await prisma.historymilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historymilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, historymilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Historymilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historymilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historymilestones
     * const historymilestones = await prisma.historymilestone.findMany()
     * 
     * // Get first 10 Historymilestones
     * const historymilestones = await prisma.historymilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historymilestoneWithIdOnly = await prisma.historymilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historymilestoneFindManyArgs>(args?: SelectSubset<T, historymilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Historymilestone.
     * @param {historymilestoneCreateArgs} args - Arguments to create a Historymilestone.
     * @example
     * // Create one Historymilestone
     * const Historymilestone = await prisma.historymilestone.create({
     *   data: {
     *     // ... data to create a Historymilestone
     *   }
     * })
     * 
     */
    create<T extends historymilestoneCreateArgs>(args: SelectSubset<T, historymilestoneCreateArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Historymilestones.
     * @param {historymilestoneCreateManyArgs} args - Arguments to create many Historymilestones.
     * @example
     * // Create many Historymilestones
     * const historymilestone = await prisma.historymilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historymilestoneCreateManyArgs>(args?: SelectSubset<T, historymilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historymilestone.
     * @param {historymilestoneDeleteArgs} args - Arguments to delete one Historymilestone.
     * @example
     * // Delete one Historymilestone
     * const Historymilestone = await prisma.historymilestone.delete({
     *   where: {
     *     // ... filter to delete one Historymilestone
     *   }
     * })
     * 
     */
    delete<T extends historymilestoneDeleteArgs>(args: SelectSubset<T, historymilestoneDeleteArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Historymilestone.
     * @param {historymilestoneUpdateArgs} args - Arguments to update one Historymilestone.
     * @example
     * // Update one Historymilestone
     * const historymilestone = await prisma.historymilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historymilestoneUpdateArgs>(args: SelectSubset<T, historymilestoneUpdateArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Historymilestones.
     * @param {historymilestoneDeleteManyArgs} args - Arguments to filter Historymilestones to delete.
     * @example
     * // Delete a few Historymilestones
     * const { count } = await prisma.historymilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historymilestoneDeleteManyArgs>(args?: SelectSubset<T, historymilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historymilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historymilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historymilestones
     * const historymilestone = await prisma.historymilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historymilestoneUpdateManyArgs>(args: SelectSubset<T, historymilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historymilestone.
     * @param {historymilestoneUpsertArgs} args - Arguments to update or create a Historymilestone.
     * @example
     * // Update or create a Historymilestone
     * const historymilestone = await prisma.historymilestone.upsert({
     *   create: {
     *     // ... data to create a Historymilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historymilestone we want to update
     *   }
     * })
     */
    upsert<T extends historymilestoneUpsertArgs>(args: SelectSubset<T, historymilestoneUpsertArgs<ExtArgs>>): Prisma__historymilestoneClient<$Result.GetResult<Prisma.$historymilestonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Historymilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historymilestoneCountArgs} args - Arguments to filter Historymilestones to count.
     * @example
     * // Count the number of Historymilestones
     * const count = await prisma.historymilestone.count({
     *   where: {
     *     // ... the filter for the Historymilestones we want to count
     *   }
     * })
    **/
    count<T extends historymilestoneCountArgs>(
      args?: Subset<T, historymilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorymilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historymilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorymilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorymilestoneAggregateArgs>(args: Subset<T, HistorymilestoneAggregateArgs>): Prisma.PrismaPromise<GetHistorymilestoneAggregateType<T>>

    /**
     * Group by Historymilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historymilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historymilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historymilestoneGroupByArgs['orderBy'] }
        : { orderBy?: historymilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historymilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorymilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the historymilestone model
   */
  readonly fields: historymilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for historymilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historymilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the historymilestone model
   */ 
  interface historymilestoneFieldRefs {
    readonly id: FieldRef<"historymilestone", 'String'>
    readonly year: FieldRef<"historymilestone", 'String'>
    readonly title: FieldRef<"historymilestone", 'String'>
    readonly description: FieldRef<"historymilestone", 'String'>
    readonly imageUrl: FieldRef<"historymilestone", 'String'>
    readonly createdAt: FieldRef<"historymilestone", 'DateTime'>
    readonly updatedAt: FieldRef<"historymilestone", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"historymilestone", 'String'>
    readonly postedByOwnerName: FieldRef<"historymilestone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * historymilestone findUnique
   */
  export type historymilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * Filter, which historymilestone to fetch.
     */
    where: historymilestoneWhereUniqueInput
  }

  /**
   * historymilestone findUniqueOrThrow
   */
  export type historymilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * Filter, which historymilestone to fetch.
     */
    where: historymilestoneWhereUniqueInput
  }

  /**
   * historymilestone findFirst
   */
  export type historymilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * Filter, which historymilestone to fetch.
     */
    where?: historymilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historymilestones to fetch.
     */
    orderBy?: historymilestoneOrderByWithRelationInput | historymilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historymilestones.
     */
    cursor?: historymilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historymilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historymilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historymilestones.
     */
    distinct?: HistorymilestoneScalarFieldEnum | HistorymilestoneScalarFieldEnum[]
  }

  /**
   * historymilestone findFirstOrThrow
   */
  export type historymilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * Filter, which historymilestone to fetch.
     */
    where?: historymilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historymilestones to fetch.
     */
    orderBy?: historymilestoneOrderByWithRelationInput | historymilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for historymilestones.
     */
    cursor?: historymilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historymilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historymilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of historymilestones.
     */
    distinct?: HistorymilestoneScalarFieldEnum | HistorymilestoneScalarFieldEnum[]
  }

  /**
   * historymilestone findMany
   */
  export type historymilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * Filter, which historymilestones to fetch.
     */
    where?: historymilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of historymilestones to fetch.
     */
    orderBy?: historymilestoneOrderByWithRelationInput | historymilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing historymilestones.
     */
    cursor?: historymilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` historymilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` historymilestones.
     */
    skip?: number
    distinct?: HistorymilestoneScalarFieldEnum | HistorymilestoneScalarFieldEnum[]
  }

  /**
   * historymilestone create
   */
  export type historymilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * The data needed to create a historymilestone.
     */
    data: XOR<historymilestoneCreateInput, historymilestoneUncheckedCreateInput>
  }

  /**
   * historymilestone createMany
   */
  export type historymilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many historymilestones.
     */
    data: historymilestoneCreateManyInput | historymilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * historymilestone update
   */
  export type historymilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * The data needed to update a historymilestone.
     */
    data: XOR<historymilestoneUpdateInput, historymilestoneUncheckedUpdateInput>
    /**
     * Choose, which historymilestone to update.
     */
    where: historymilestoneWhereUniqueInput
  }

  /**
   * historymilestone updateMany
   */
  export type historymilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update historymilestones.
     */
    data: XOR<historymilestoneUpdateManyMutationInput, historymilestoneUncheckedUpdateManyInput>
    /**
     * Filter which historymilestones to update
     */
    where?: historymilestoneWhereInput
  }

  /**
   * historymilestone upsert
   */
  export type historymilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * The filter to search for the historymilestone to update in case it exists.
     */
    where: historymilestoneWhereUniqueInput
    /**
     * In case the historymilestone found by the `where` argument doesn't exist, create a new historymilestone with this data.
     */
    create: XOR<historymilestoneCreateInput, historymilestoneUncheckedCreateInput>
    /**
     * In case the historymilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historymilestoneUpdateInput, historymilestoneUncheckedUpdateInput>
  }

  /**
   * historymilestone delete
   */
  export type historymilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
    /**
     * Filter which historymilestone to delete.
     */
    where: historymilestoneWhereUniqueInput
  }

  /**
   * historymilestone deleteMany
   */
  export type historymilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which historymilestones to delete
     */
    where?: historymilestoneWhereInput
  }

  /**
   * historymilestone without action
   */
  export type historymilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the historymilestone
     */
    select?: historymilestoneSelect<ExtArgs> | null
  }


  /**
   * Model homeslide
   */

  export type AggregateHomeslide = {
    _count: HomeslideCountAggregateOutputType | null
    _avg: HomeslideAvgAggregateOutputType | null
    _sum: HomeslideSumAggregateOutputType | null
    _min: HomeslideMinAggregateOutputType | null
    _max: HomeslideMaxAggregateOutputType | null
  }

  export type HomeslideAvgAggregateOutputType = {
    order: number | null
  }

  export type HomeslideSumAggregateOutputType = {
    order: number | null
  }

  export type HomeslideMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    ctaText: string | null
    linkPath: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type HomeslideMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    ctaText: string | null
    linkPath: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type HomeslideCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    ctaText: number
    linkPath: number
    order: number
    isActive: number
    createdAt: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    _all: number
  }


  export type HomeslideAvgAggregateInputType = {
    order?: true
  }

  export type HomeslideSumAggregateInputType = {
    order?: true
  }

  export type HomeslideMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    ctaText?: true
    linkPath?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type HomeslideMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    ctaText?: true
    linkPath?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type HomeslideCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    ctaText?: true
    linkPath?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    _all?: true
  }

  export type HomeslideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which homeslide to aggregate.
     */
    where?: homeslideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeslides to fetch.
     */
    orderBy?: homeslideOrderByWithRelationInput | homeslideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: homeslideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeslides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeslides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned homeslides
    **/
    _count?: true | HomeslideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HomeslideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HomeslideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeslideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeslideMaxAggregateInputType
  }

  export type GetHomeslideAggregateType<T extends HomeslideAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeslide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeslide[P]>
      : GetScalarType<T[P], AggregateHomeslide[P]>
  }




  export type homeslideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: homeslideWhereInput
    orderBy?: homeslideOrderByWithAggregationInput | homeslideOrderByWithAggregationInput[]
    by: HomeslideScalarFieldEnum[] | HomeslideScalarFieldEnum
    having?: homeslideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeslideCountAggregateInputType | true
    _avg?: HomeslideAvgAggregateInputType
    _sum?: HomeslideSumAggregateInputType
    _min?: HomeslideMinAggregateInputType
    _max?: HomeslideMaxAggregateInputType
  }

  export type HomeslideGroupByOutputType = {
    id: string
    title: string
    description: string
    imageUrl: string
    ctaText: string
    linkPath: string
    order: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    _count: HomeslideCountAggregateOutputType | null
    _avg: HomeslideAvgAggregateOutputType | null
    _sum: HomeslideSumAggregateOutputType | null
    _min: HomeslideMinAggregateOutputType | null
    _max: HomeslideMaxAggregateOutputType | null
  }

  type GetHomeslideGroupByPayload<T extends homeslideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeslideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeslideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeslideGroupByOutputType[P]>
            : GetScalarType<T[P], HomeslideGroupByOutputType[P]>
        }
      >
    >


  export type homeslideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    ctaText?: boolean
    linkPath?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }, ExtArgs["result"]["homeslide"]>


  export type homeslideSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    ctaText?: boolean
    linkPath?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }


  export type $homeslidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "homeslide"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      imageUrl: string
      ctaText: string
      linkPath: string
      order: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
    }, ExtArgs["result"]["homeslide"]>
    composites: {}
  }

  type homeslideGetPayload<S extends boolean | null | undefined | homeslideDefaultArgs> = $Result.GetResult<Prisma.$homeslidePayload, S>

  type homeslideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<homeslideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HomeslideCountAggregateInputType | true
    }

  export interface homeslideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['homeslide'], meta: { name: 'homeslide' } }
    /**
     * Find zero or one Homeslide that matches the filter.
     * @param {homeslideFindUniqueArgs} args - Arguments to find a Homeslide
     * @example
     * // Get one Homeslide
     * const homeslide = await prisma.homeslide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends homeslideFindUniqueArgs>(args: SelectSubset<T, homeslideFindUniqueArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Homeslide that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {homeslideFindUniqueOrThrowArgs} args - Arguments to find a Homeslide
     * @example
     * // Get one Homeslide
     * const homeslide = await prisma.homeslide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends homeslideFindUniqueOrThrowArgs>(args: SelectSubset<T, homeslideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Homeslide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeslideFindFirstArgs} args - Arguments to find a Homeslide
     * @example
     * // Get one Homeslide
     * const homeslide = await prisma.homeslide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends homeslideFindFirstArgs>(args?: SelectSubset<T, homeslideFindFirstArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Homeslide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeslideFindFirstOrThrowArgs} args - Arguments to find a Homeslide
     * @example
     * // Get one Homeslide
     * const homeslide = await prisma.homeslide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends homeslideFindFirstOrThrowArgs>(args?: SelectSubset<T, homeslideFindFirstOrThrowArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Homeslides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeslideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Homeslides
     * const homeslides = await prisma.homeslide.findMany()
     * 
     * // Get first 10 Homeslides
     * const homeslides = await prisma.homeslide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeslideWithIdOnly = await prisma.homeslide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends homeslideFindManyArgs>(args?: SelectSubset<T, homeslideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Homeslide.
     * @param {homeslideCreateArgs} args - Arguments to create a Homeslide.
     * @example
     * // Create one Homeslide
     * const Homeslide = await prisma.homeslide.create({
     *   data: {
     *     // ... data to create a Homeslide
     *   }
     * })
     * 
     */
    create<T extends homeslideCreateArgs>(args: SelectSubset<T, homeslideCreateArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Homeslides.
     * @param {homeslideCreateManyArgs} args - Arguments to create many Homeslides.
     * @example
     * // Create many Homeslides
     * const homeslide = await prisma.homeslide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends homeslideCreateManyArgs>(args?: SelectSubset<T, homeslideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Homeslide.
     * @param {homeslideDeleteArgs} args - Arguments to delete one Homeslide.
     * @example
     * // Delete one Homeslide
     * const Homeslide = await prisma.homeslide.delete({
     *   where: {
     *     // ... filter to delete one Homeslide
     *   }
     * })
     * 
     */
    delete<T extends homeslideDeleteArgs>(args: SelectSubset<T, homeslideDeleteArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Homeslide.
     * @param {homeslideUpdateArgs} args - Arguments to update one Homeslide.
     * @example
     * // Update one Homeslide
     * const homeslide = await prisma.homeslide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends homeslideUpdateArgs>(args: SelectSubset<T, homeslideUpdateArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Homeslides.
     * @param {homeslideDeleteManyArgs} args - Arguments to filter Homeslides to delete.
     * @example
     * // Delete a few Homeslides
     * const { count } = await prisma.homeslide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends homeslideDeleteManyArgs>(args?: SelectSubset<T, homeslideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Homeslides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeslideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Homeslides
     * const homeslide = await prisma.homeslide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends homeslideUpdateManyArgs>(args: SelectSubset<T, homeslideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Homeslide.
     * @param {homeslideUpsertArgs} args - Arguments to update or create a Homeslide.
     * @example
     * // Update or create a Homeslide
     * const homeslide = await prisma.homeslide.upsert({
     *   create: {
     *     // ... data to create a Homeslide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Homeslide we want to update
     *   }
     * })
     */
    upsert<T extends homeslideUpsertArgs>(args: SelectSubset<T, homeslideUpsertArgs<ExtArgs>>): Prisma__homeslideClient<$Result.GetResult<Prisma.$homeslidePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Homeslides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeslideCountArgs} args - Arguments to filter Homeslides to count.
     * @example
     * // Count the number of Homeslides
     * const count = await prisma.homeslide.count({
     *   where: {
     *     // ... the filter for the Homeslides we want to count
     *   }
     * })
    **/
    count<T extends homeslideCountArgs>(
      args?: Subset<T, homeslideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeslideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Homeslide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeslideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeslideAggregateArgs>(args: Subset<T, HomeslideAggregateArgs>): Prisma.PrismaPromise<GetHomeslideAggregateType<T>>

    /**
     * Group by Homeslide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {homeslideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends homeslideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: homeslideGroupByArgs['orderBy'] }
        : { orderBy?: homeslideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, homeslideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeslideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the homeslide model
   */
  readonly fields: homeslideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for homeslide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__homeslideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the homeslide model
   */ 
  interface homeslideFieldRefs {
    readonly id: FieldRef<"homeslide", 'String'>
    readonly title: FieldRef<"homeslide", 'String'>
    readonly description: FieldRef<"homeslide", 'String'>
    readonly imageUrl: FieldRef<"homeslide", 'String'>
    readonly ctaText: FieldRef<"homeslide", 'String'>
    readonly linkPath: FieldRef<"homeslide", 'String'>
    readonly order: FieldRef<"homeslide", 'Int'>
    readonly isActive: FieldRef<"homeslide", 'Boolean'>
    readonly createdAt: FieldRef<"homeslide", 'DateTime'>
    readonly updatedAt: FieldRef<"homeslide", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"homeslide", 'String'>
    readonly postedByOwnerName: FieldRef<"homeslide", 'String'>
  }
    

  // Custom InputTypes
  /**
   * homeslide findUnique
   */
  export type homeslideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * Filter, which homeslide to fetch.
     */
    where: homeslideWhereUniqueInput
  }

  /**
   * homeslide findUniqueOrThrow
   */
  export type homeslideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * Filter, which homeslide to fetch.
     */
    where: homeslideWhereUniqueInput
  }

  /**
   * homeslide findFirst
   */
  export type homeslideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * Filter, which homeslide to fetch.
     */
    where?: homeslideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeslides to fetch.
     */
    orderBy?: homeslideOrderByWithRelationInput | homeslideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for homeslides.
     */
    cursor?: homeslideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeslides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeslides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of homeslides.
     */
    distinct?: HomeslideScalarFieldEnum | HomeslideScalarFieldEnum[]
  }

  /**
   * homeslide findFirstOrThrow
   */
  export type homeslideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * Filter, which homeslide to fetch.
     */
    where?: homeslideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeslides to fetch.
     */
    orderBy?: homeslideOrderByWithRelationInput | homeslideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for homeslides.
     */
    cursor?: homeslideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeslides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeslides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of homeslides.
     */
    distinct?: HomeslideScalarFieldEnum | HomeslideScalarFieldEnum[]
  }

  /**
   * homeslide findMany
   */
  export type homeslideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * Filter, which homeslides to fetch.
     */
    where?: homeslideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of homeslides to fetch.
     */
    orderBy?: homeslideOrderByWithRelationInput | homeslideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing homeslides.
     */
    cursor?: homeslideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` homeslides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` homeslides.
     */
    skip?: number
    distinct?: HomeslideScalarFieldEnum | HomeslideScalarFieldEnum[]
  }

  /**
   * homeslide create
   */
  export type homeslideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * The data needed to create a homeslide.
     */
    data: XOR<homeslideCreateInput, homeslideUncheckedCreateInput>
  }

  /**
   * homeslide createMany
   */
  export type homeslideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many homeslides.
     */
    data: homeslideCreateManyInput | homeslideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * homeslide update
   */
  export type homeslideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * The data needed to update a homeslide.
     */
    data: XOR<homeslideUpdateInput, homeslideUncheckedUpdateInput>
    /**
     * Choose, which homeslide to update.
     */
    where: homeslideWhereUniqueInput
  }

  /**
   * homeslide updateMany
   */
  export type homeslideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update homeslides.
     */
    data: XOR<homeslideUpdateManyMutationInput, homeslideUncheckedUpdateManyInput>
    /**
     * Filter which homeslides to update
     */
    where?: homeslideWhereInput
  }

  /**
   * homeslide upsert
   */
  export type homeslideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * The filter to search for the homeslide to update in case it exists.
     */
    where: homeslideWhereUniqueInput
    /**
     * In case the homeslide found by the `where` argument doesn't exist, create a new homeslide with this data.
     */
    create: XOR<homeslideCreateInput, homeslideUncheckedCreateInput>
    /**
     * In case the homeslide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<homeslideUpdateInput, homeslideUncheckedUpdateInput>
  }

  /**
   * homeslide delete
   */
  export type homeslideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
    /**
     * Filter which homeslide to delete.
     */
    where: homeslideWhereUniqueInput
  }

  /**
   * homeslide deleteMany
   */
  export type homeslideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which homeslides to delete
     */
    where?: homeslideWhereInput
  }

  /**
   * homeslide without action
   */
  export type homeslideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the homeslide
     */
    select?: homeslideSelect<ExtArgs> | null
  }


  /**
   * Model keyperson
   */

  export type AggregateKeyperson = {
    _count: KeypersonCountAggregateOutputType | null
    _min: KeypersonMinAggregateOutputType | null
    _max: KeypersonMaxAggregateOutputType | null
  }

  export type KeypersonMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type KeypersonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    imageUrl: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type KeypersonCountAggregateOutputType = {
    id: number
    name: number
    role: number
    imageUrl: number
    bio: number
    createdAt: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    _all: number
  }


  export type KeypersonMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type KeypersonMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type KeypersonCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    imageUrl?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    _all?: true
  }

  export type KeypersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keyperson to aggregate.
     */
    where?: keypersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keypeople to fetch.
     */
    orderBy?: keypersonOrderByWithRelationInput | keypersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: keypersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keypeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keypeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned keypeople
    **/
    _count?: true | KeypersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeypersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeypersonMaxAggregateInputType
  }

  export type GetKeypersonAggregateType<T extends KeypersonAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyperson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyperson[P]>
      : GetScalarType<T[P], AggregateKeyperson[P]>
  }




  export type keypersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: keypersonWhereInput
    orderBy?: keypersonOrderByWithAggregationInput | keypersonOrderByWithAggregationInput[]
    by: KeypersonScalarFieldEnum[] | KeypersonScalarFieldEnum
    having?: keypersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeypersonCountAggregateInputType | true
    _min?: KeypersonMinAggregateInputType
    _max?: KeypersonMaxAggregateInputType
  }

  export type KeypersonGroupByOutputType = {
    id: string
    name: string
    role: string
    imageUrl: string | null
    bio: string
    createdAt: Date
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    _count: KeypersonCountAggregateOutputType | null
    _min: KeypersonMinAggregateOutputType | null
    _max: KeypersonMaxAggregateOutputType | null
  }

  type GetKeypersonGroupByPayload<T extends keypersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeypersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeypersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeypersonGroupByOutputType[P]>
            : GetScalarType<T[P], KeypersonGroupByOutputType[P]>
        }
      >
    >


  export type keypersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    imageUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }, ExtArgs["result"]["keyperson"]>


  export type keypersonSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    imageUrl?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }


  export type $keypersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "keyperson"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      imageUrl: string | null
      bio: string
      createdAt: Date
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
    }, ExtArgs["result"]["keyperson"]>
    composites: {}
  }

  type keypersonGetPayload<S extends boolean | null | undefined | keypersonDefaultArgs> = $Result.GetResult<Prisma.$keypersonPayload, S>

  type keypersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<keypersonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KeypersonCountAggregateInputType | true
    }

  export interface keypersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['keyperson'], meta: { name: 'keyperson' } }
    /**
     * Find zero or one Keyperson that matches the filter.
     * @param {keypersonFindUniqueArgs} args - Arguments to find a Keyperson
     * @example
     * // Get one Keyperson
     * const keyperson = await prisma.keyperson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends keypersonFindUniqueArgs>(args: SelectSubset<T, keypersonFindUniqueArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Keyperson that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {keypersonFindUniqueOrThrowArgs} args - Arguments to find a Keyperson
     * @example
     * // Get one Keyperson
     * const keyperson = await prisma.keyperson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends keypersonFindUniqueOrThrowArgs>(args: SelectSubset<T, keypersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Keyperson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keypersonFindFirstArgs} args - Arguments to find a Keyperson
     * @example
     * // Get one Keyperson
     * const keyperson = await prisma.keyperson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends keypersonFindFirstArgs>(args?: SelectSubset<T, keypersonFindFirstArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Keyperson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keypersonFindFirstOrThrowArgs} args - Arguments to find a Keyperson
     * @example
     * // Get one Keyperson
     * const keyperson = await prisma.keyperson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends keypersonFindFirstOrThrowArgs>(args?: SelectSubset<T, keypersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Keypeople that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keypersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keypeople
     * const keypeople = await prisma.keyperson.findMany()
     * 
     * // Get first 10 Keypeople
     * const keypeople = await prisma.keyperson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keypersonWithIdOnly = await prisma.keyperson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends keypersonFindManyArgs>(args?: SelectSubset<T, keypersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Keyperson.
     * @param {keypersonCreateArgs} args - Arguments to create a Keyperson.
     * @example
     * // Create one Keyperson
     * const Keyperson = await prisma.keyperson.create({
     *   data: {
     *     // ... data to create a Keyperson
     *   }
     * })
     * 
     */
    create<T extends keypersonCreateArgs>(args: SelectSubset<T, keypersonCreateArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Keypeople.
     * @param {keypersonCreateManyArgs} args - Arguments to create many Keypeople.
     * @example
     * // Create many Keypeople
     * const keyperson = await prisma.keyperson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends keypersonCreateManyArgs>(args?: SelectSubset<T, keypersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Keyperson.
     * @param {keypersonDeleteArgs} args - Arguments to delete one Keyperson.
     * @example
     * // Delete one Keyperson
     * const Keyperson = await prisma.keyperson.delete({
     *   where: {
     *     // ... filter to delete one Keyperson
     *   }
     * })
     * 
     */
    delete<T extends keypersonDeleteArgs>(args: SelectSubset<T, keypersonDeleteArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Keyperson.
     * @param {keypersonUpdateArgs} args - Arguments to update one Keyperson.
     * @example
     * // Update one Keyperson
     * const keyperson = await prisma.keyperson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends keypersonUpdateArgs>(args: SelectSubset<T, keypersonUpdateArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Keypeople.
     * @param {keypersonDeleteManyArgs} args - Arguments to filter Keypeople to delete.
     * @example
     * // Delete a few Keypeople
     * const { count } = await prisma.keyperson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends keypersonDeleteManyArgs>(args?: SelectSubset<T, keypersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keypeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keypersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keypeople
     * const keyperson = await prisma.keyperson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends keypersonUpdateManyArgs>(args: SelectSubset<T, keypersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Keyperson.
     * @param {keypersonUpsertArgs} args - Arguments to update or create a Keyperson.
     * @example
     * // Update or create a Keyperson
     * const keyperson = await prisma.keyperson.upsert({
     *   create: {
     *     // ... data to create a Keyperson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keyperson we want to update
     *   }
     * })
     */
    upsert<T extends keypersonUpsertArgs>(args: SelectSubset<T, keypersonUpsertArgs<ExtArgs>>): Prisma__keypersonClient<$Result.GetResult<Prisma.$keypersonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Keypeople.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keypersonCountArgs} args - Arguments to filter Keypeople to count.
     * @example
     * // Count the number of Keypeople
     * const count = await prisma.keyperson.count({
     *   where: {
     *     // ... the filter for the Keypeople we want to count
     *   }
     * })
    **/
    count<T extends keypersonCountArgs>(
      args?: Subset<T, keypersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeypersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keyperson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeypersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeypersonAggregateArgs>(args: Subset<T, KeypersonAggregateArgs>): Prisma.PrismaPromise<GetKeypersonAggregateType<T>>

    /**
     * Group by Keyperson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keypersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends keypersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: keypersonGroupByArgs['orderBy'] }
        : { orderBy?: keypersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, keypersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeypersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the keyperson model
   */
  readonly fields: keypersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for keyperson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__keypersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the keyperson model
   */ 
  interface keypersonFieldRefs {
    readonly id: FieldRef<"keyperson", 'String'>
    readonly name: FieldRef<"keyperson", 'String'>
    readonly role: FieldRef<"keyperson", 'String'>
    readonly imageUrl: FieldRef<"keyperson", 'String'>
    readonly bio: FieldRef<"keyperson", 'String'>
    readonly createdAt: FieldRef<"keyperson", 'DateTime'>
    readonly updatedAt: FieldRef<"keyperson", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"keyperson", 'String'>
    readonly postedByOwnerName: FieldRef<"keyperson", 'String'>
  }
    

  // Custom InputTypes
  /**
   * keyperson findUnique
   */
  export type keypersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * Filter, which keyperson to fetch.
     */
    where: keypersonWhereUniqueInput
  }

  /**
   * keyperson findUniqueOrThrow
   */
  export type keypersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * Filter, which keyperson to fetch.
     */
    where: keypersonWhereUniqueInput
  }

  /**
   * keyperson findFirst
   */
  export type keypersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * Filter, which keyperson to fetch.
     */
    where?: keypersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keypeople to fetch.
     */
    orderBy?: keypersonOrderByWithRelationInput | keypersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keypeople.
     */
    cursor?: keypersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keypeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keypeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keypeople.
     */
    distinct?: KeypersonScalarFieldEnum | KeypersonScalarFieldEnum[]
  }

  /**
   * keyperson findFirstOrThrow
   */
  export type keypersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * Filter, which keyperson to fetch.
     */
    where?: keypersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keypeople to fetch.
     */
    orderBy?: keypersonOrderByWithRelationInput | keypersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keypeople.
     */
    cursor?: keypersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keypeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keypeople.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keypeople.
     */
    distinct?: KeypersonScalarFieldEnum | KeypersonScalarFieldEnum[]
  }

  /**
   * keyperson findMany
   */
  export type keypersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * Filter, which keypeople to fetch.
     */
    where?: keypersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keypeople to fetch.
     */
    orderBy?: keypersonOrderByWithRelationInput | keypersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing keypeople.
     */
    cursor?: keypersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keypeople from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keypeople.
     */
    skip?: number
    distinct?: KeypersonScalarFieldEnum | KeypersonScalarFieldEnum[]
  }

  /**
   * keyperson create
   */
  export type keypersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * The data needed to create a keyperson.
     */
    data: XOR<keypersonCreateInput, keypersonUncheckedCreateInput>
  }

  /**
   * keyperson createMany
   */
  export type keypersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many keypeople.
     */
    data: keypersonCreateManyInput | keypersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * keyperson update
   */
  export type keypersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * The data needed to update a keyperson.
     */
    data: XOR<keypersonUpdateInput, keypersonUncheckedUpdateInput>
    /**
     * Choose, which keyperson to update.
     */
    where: keypersonWhereUniqueInput
  }

  /**
   * keyperson updateMany
   */
  export type keypersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update keypeople.
     */
    data: XOR<keypersonUpdateManyMutationInput, keypersonUncheckedUpdateManyInput>
    /**
     * Filter which keypeople to update
     */
    where?: keypersonWhereInput
  }

  /**
   * keyperson upsert
   */
  export type keypersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * The filter to search for the keyperson to update in case it exists.
     */
    where: keypersonWhereUniqueInput
    /**
     * In case the keyperson found by the `where` argument doesn't exist, create a new keyperson with this data.
     */
    create: XOR<keypersonCreateInput, keypersonUncheckedCreateInput>
    /**
     * In case the keyperson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<keypersonUpdateInput, keypersonUncheckedUpdateInput>
  }

  /**
   * keyperson delete
   */
  export type keypersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
    /**
     * Filter which keyperson to delete.
     */
    where: keypersonWhereUniqueInput
  }

  /**
   * keyperson deleteMany
   */
  export type keypersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keypeople to delete
     */
    where?: keypersonWhereInput
  }

  /**
   * keyperson without action
   */
  export type keypersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keyperson
     */
    select?: keypersonSelect<ExtArgs> | null
  }


  /**
   * Model meetingdecisionpoint
   */

  export type AggregateMeetingdecisionpoint = {
    _count: MeetingdecisionpointCountAggregateOutputType | null
    _min: MeetingdecisionpointMinAggregateOutputType | null
    _max: MeetingdecisionpointMaxAggregateOutputType | null
  }

  export type MeetingdecisionpointMinAggregateOutputType = {
    id: string | null
    description: string | null
    proposedBy: string | null
    status: $Enums.meetingdecisionpoint_status | null
    followUpNotes: string | null
    resolutionDate: Date | null
    meetingLogId: string | null
  }

  export type MeetingdecisionpointMaxAggregateOutputType = {
    id: string | null
    description: string | null
    proposedBy: string | null
    status: $Enums.meetingdecisionpoint_status | null
    followUpNotes: string | null
    resolutionDate: Date | null
    meetingLogId: string | null
  }

  export type MeetingdecisionpointCountAggregateOutputType = {
    id: number
    description: number
    proposedBy: number
    status: number
    followUpNotes: number
    resolutionDate: number
    meetingLogId: number
    _all: number
  }


  export type MeetingdecisionpointMinAggregateInputType = {
    id?: true
    description?: true
    proposedBy?: true
    status?: true
    followUpNotes?: true
    resolutionDate?: true
    meetingLogId?: true
  }

  export type MeetingdecisionpointMaxAggregateInputType = {
    id?: true
    description?: true
    proposedBy?: true
    status?: true
    followUpNotes?: true
    resolutionDate?: true
    meetingLogId?: true
  }

  export type MeetingdecisionpointCountAggregateInputType = {
    id?: true
    description?: true
    proposedBy?: true
    status?: true
    followUpNotes?: true
    resolutionDate?: true
    meetingLogId?: true
    _all?: true
  }

  export type MeetingdecisionpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meetingdecisionpoint to aggregate.
     */
    where?: meetingdecisionpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetingdecisionpoints to fetch.
     */
    orderBy?: meetingdecisionpointOrderByWithRelationInput | meetingdecisionpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meetingdecisionpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetingdecisionpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetingdecisionpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meetingdecisionpoints
    **/
    _count?: true | MeetingdecisionpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingdecisionpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingdecisionpointMaxAggregateInputType
  }

  export type GetMeetingdecisionpointAggregateType<T extends MeetingdecisionpointAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingdecisionpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingdecisionpoint[P]>
      : GetScalarType<T[P], AggregateMeetingdecisionpoint[P]>
  }




  export type meetingdecisionpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meetingdecisionpointWhereInput
    orderBy?: meetingdecisionpointOrderByWithAggregationInput | meetingdecisionpointOrderByWithAggregationInput[]
    by: MeetingdecisionpointScalarFieldEnum[] | MeetingdecisionpointScalarFieldEnum
    having?: meetingdecisionpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingdecisionpointCountAggregateInputType | true
    _min?: MeetingdecisionpointMinAggregateInputType
    _max?: MeetingdecisionpointMaxAggregateInputType
  }

  export type MeetingdecisionpointGroupByOutputType = {
    id: string
    description: string
    proposedBy: string | null
    status: $Enums.meetingdecisionpoint_status
    followUpNotes: string | null
    resolutionDate: Date | null
    meetingLogId: string
    _count: MeetingdecisionpointCountAggregateOutputType | null
    _min: MeetingdecisionpointMinAggregateOutputType | null
    _max: MeetingdecisionpointMaxAggregateOutputType | null
  }

  type GetMeetingdecisionpointGroupByPayload<T extends meetingdecisionpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingdecisionpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingdecisionpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingdecisionpointGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingdecisionpointGroupByOutputType[P]>
        }
      >
    >


  export type meetingdecisionpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    proposedBy?: boolean
    status?: boolean
    followUpNotes?: boolean
    resolutionDate?: boolean
    meetingLogId?: boolean
    meetinglog?: boolean | meetinglogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingdecisionpoint"]>


  export type meetingdecisionpointSelectScalar = {
    id?: boolean
    description?: boolean
    proposedBy?: boolean
    status?: boolean
    followUpNotes?: boolean
    resolutionDate?: boolean
    meetingLogId?: boolean
  }

  export type meetingdecisionpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meetinglog?: boolean | meetinglogDefaultArgs<ExtArgs>
  }

  export type $meetingdecisionpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meetingdecisionpoint"
    objects: {
      meetinglog: Prisma.$meetinglogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      proposedBy: string | null
      status: $Enums.meetingdecisionpoint_status
      followUpNotes: string | null
      resolutionDate: Date | null
      meetingLogId: string
    }, ExtArgs["result"]["meetingdecisionpoint"]>
    composites: {}
  }

  type meetingdecisionpointGetPayload<S extends boolean | null | undefined | meetingdecisionpointDefaultArgs> = $Result.GetResult<Prisma.$meetingdecisionpointPayload, S>

  type meetingdecisionpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<meetingdecisionpointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingdecisionpointCountAggregateInputType | true
    }

  export interface meetingdecisionpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meetingdecisionpoint'], meta: { name: 'meetingdecisionpoint' } }
    /**
     * Find zero or one Meetingdecisionpoint that matches the filter.
     * @param {meetingdecisionpointFindUniqueArgs} args - Arguments to find a Meetingdecisionpoint
     * @example
     * // Get one Meetingdecisionpoint
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meetingdecisionpointFindUniqueArgs>(args: SelectSubset<T, meetingdecisionpointFindUniqueArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meetingdecisionpoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {meetingdecisionpointFindUniqueOrThrowArgs} args - Arguments to find a Meetingdecisionpoint
     * @example
     * // Get one Meetingdecisionpoint
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meetingdecisionpointFindUniqueOrThrowArgs>(args: SelectSubset<T, meetingdecisionpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meetingdecisionpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingdecisionpointFindFirstArgs} args - Arguments to find a Meetingdecisionpoint
     * @example
     * // Get one Meetingdecisionpoint
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meetingdecisionpointFindFirstArgs>(args?: SelectSubset<T, meetingdecisionpointFindFirstArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meetingdecisionpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingdecisionpointFindFirstOrThrowArgs} args - Arguments to find a Meetingdecisionpoint
     * @example
     * // Get one Meetingdecisionpoint
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meetingdecisionpointFindFirstOrThrowArgs>(args?: SelectSubset<T, meetingdecisionpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meetingdecisionpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingdecisionpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetingdecisionpoints
     * const meetingdecisionpoints = await prisma.meetingdecisionpoint.findMany()
     * 
     * // Get first 10 Meetingdecisionpoints
     * const meetingdecisionpoints = await prisma.meetingdecisionpoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingdecisionpointWithIdOnly = await prisma.meetingdecisionpoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends meetingdecisionpointFindManyArgs>(args?: SelectSubset<T, meetingdecisionpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meetingdecisionpoint.
     * @param {meetingdecisionpointCreateArgs} args - Arguments to create a Meetingdecisionpoint.
     * @example
     * // Create one Meetingdecisionpoint
     * const Meetingdecisionpoint = await prisma.meetingdecisionpoint.create({
     *   data: {
     *     // ... data to create a Meetingdecisionpoint
     *   }
     * })
     * 
     */
    create<T extends meetingdecisionpointCreateArgs>(args: SelectSubset<T, meetingdecisionpointCreateArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meetingdecisionpoints.
     * @param {meetingdecisionpointCreateManyArgs} args - Arguments to create many Meetingdecisionpoints.
     * @example
     * // Create many Meetingdecisionpoints
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meetingdecisionpointCreateManyArgs>(args?: SelectSubset<T, meetingdecisionpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meetingdecisionpoint.
     * @param {meetingdecisionpointDeleteArgs} args - Arguments to delete one Meetingdecisionpoint.
     * @example
     * // Delete one Meetingdecisionpoint
     * const Meetingdecisionpoint = await prisma.meetingdecisionpoint.delete({
     *   where: {
     *     // ... filter to delete one Meetingdecisionpoint
     *   }
     * })
     * 
     */
    delete<T extends meetingdecisionpointDeleteArgs>(args: SelectSubset<T, meetingdecisionpointDeleteArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meetingdecisionpoint.
     * @param {meetingdecisionpointUpdateArgs} args - Arguments to update one Meetingdecisionpoint.
     * @example
     * // Update one Meetingdecisionpoint
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meetingdecisionpointUpdateArgs>(args: SelectSubset<T, meetingdecisionpointUpdateArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meetingdecisionpoints.
     * @param {meetingdecisionpointDeleteManyArgs} args - Arguments to filter Meetingdecisionpoints to delete.
     * @example
     * // Delete a few Meetingdecisionpoints
     * const { count } = await prisma.meetingdecisionpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meetingdecisionpointDeleteManyArgs>(args?: SelectSubset<T, meetingdecisionpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetingdecisionpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingdecisionpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetingdecisionpoints
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meetingdecisionpointUpdateManyArgs>(args: SelectSubset<T, meetingdecisionpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meetingdecisionpoint.
     * @param {meetingdecisionpointUpsertArgs} args - Arguments to update or create a Meetingdecisionpoint.
     * @example
     * // Update or create a Meetingdecisionpoint
     * const meetingdecisionpoint = await prisma.meetingdecisionpoint.upsert({
     *   create: {
     *     // ... data to create a Meetingdecisionpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meetingdecisionpoint we want to update
     *   }
     * })
     */
    upsert<T extends meetingdecisionpointUpsertArgs>(args: SelectSubset<T, meetingdecisionpointUpsertArgs<ExtArgs>>): Prisma__meetingdecisionpointClient<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meetingdecisionpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingdecisionpointCountArgs} args - Arguments to filter Meetingdecisionpoints to count.
     * @example
     * // Count the number of Meetingdecisionpoints
     * const count = await prisma.meetingdecisionpoint.count({
     *   where: {
     *     // ... the filter for the Meetingdecisionpoints we want to count
     *   }
     * })
    **/
    count<T extends meetingdecisionpointCountArgs>(
      args?: Subset<T, meetingdecisionpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingdecisionpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meetingdecisionpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingdecisionpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingdecisionpointAggregateArgs>(args: Subset<T, MeetingdecisionpointAggregateArgs>): Prisma.PrismaPromise<GetMeetingdecisionpointAggregateType<T>>

    /**
     * Group by Meetingdecisionpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingdecisionpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meetingdecisionpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meetingdecisionpointGroupByArgs['orderBy'] }
        : { orderBy?: meetingdecisionpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meetingdecisionpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingdecisionpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meetingdecisionpoint model
   */
  readonly fields: meetingdecisionpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meetingdecisionpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meetingdecisionpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meetinglog<T extends meetinglogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, meetinglogDefaultArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meetingdecisionpoint model
   */ 
  interface meetingdecisionpointFieldRefs {
    readonly id: FieldRef<"meetingdecisionpoint", 'String'>
    readonly description: FieldRef<"meetingdecisionpoint", 'String'>
    readonly proposedBy: FieldRef<"meetingdecisionpoint", 'String'>
    readonly status: FieldRef<"meetingdecisionpoint", 'meetingdecisionpoint_status'>
    readonly followUpNotes: FieldRef<"meetingdecisionpoint", 'String'>
    readonly resolutionDate: FieldRef<"meetingdecisionpoint", 'DateTime'>
    readonly meetingLogId: FieldRef<"meetingdecisionpoint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * meetingdecisionpoint findUnique
   */
  export type meetingdecisionpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * Filter, which meetingdecisionpoint to fetch.
     */
    where: meetingdecisionpointWhereUniqueInput
  }

  /**
   * meetingdecisionpoint findUniqueOrThrow
   */
  export type meetingdecisionpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * Filter, which meetingdecisionpoint to fetch.
     */
    where: meetingdecisionpointWhereUniqueInput
  }

  /**
   * meetingdecisionpoint findFirst
   */
  export type meetingdecisionpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * Filter, which meetingdecisionpoint to fetch.
     */
    where?: meetingdecisionpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetingdecisionpoints to fetch.
     */
    orderBy?: meetingdecisionpointOrderByWithRelationInput | meetingdecisionpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meetingdecisionpoints.
     */
    cursor?: meetingdecisionpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetingdecisionpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetingdecisionpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meetingdecisionpoints.
     */
    distinct?: MeetingdecisionpointScalarFieldEnum | MeetingdecisionpointScalarFieldEnum[]
  }

  /**
   * meetingdecisionpoint findFirstOrThrow
   */
  export type meetingdecisionpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * Filter, which meetingdecisionpoint to fetch.
     */
    where?: meetingdecisionpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetingdecisionpoints to fetch.
     */
    orderBy?: meetingdecisionpointOrderByWithRelationInput | meetingdecisionpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meetingdecisionpoints.
     */
    cursor?: meetingdecisionpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetingdecisionpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetingdecisionpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meetingdecisionpoints.
     */
    distinct?: MeetingdecisionpointScalarFieldEnum | MeetingdecisionpointScalarFieldEnum[]
  }

  /**
   * meetingdecisionpoint findMany
   */
  export type meetingdecisionpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * Filter, which meetingdecisionpoints to fetch.
     */
    where?: meetingdecisionpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetingdecisionpoints to fetch.
     */
    orderBy?: meetingdecisionpointOrderByWithRelationInput | meetingdecisionpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meetingdecisionpoints.
     */
    cursor?: meetingdecisionpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetingdecisionpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetingdecisionpoints.
     */
    skip?: number
    distinct?: MeetingdecisionpointScalarFieldEnum | MeetingdecisionpointScalarFieldEnum[]
  }

  /**
   * meetingdecisionpoint create
   */
  export type meetingdecisionpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * The data needed to create a meetingdecisionpoint.
     */
    data: XOR<meetingdecisionpointCreateInput, meetingdecisionpointUncheckedCreateInput>
  }

  /**
   * meetingdecisionpoint createMany
   */
  export type meetingdecisionpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meetingdecisionpoints.
     */
    data: meetingdecisionpointCreateManyInput | meetingdecisionpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meetingdecisionpoint update
   */
  export type meetingdecisionpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * The data needed to update a meetingdecisionpoint.
     */
    data: XOR<meetingdecisionpointUpdateInput, meetingdecisionpointUncheckedUpdateInput>
    /**
     * Choose, which meetingdecisionpoint to update.
     */
    where: meetingdecisionpointWhereUniqueInput
  }

  /**
   * meetingdecisionpoint updateMany
   */
  export type meetingdecisionpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meetingdecisionpoints.
     */
    data: XOR<meetingdecisionpointUpdateManyMutationInput, meetingdecisionpointUncheckedUpdateManyInput>
    /**
     * Filter which meetingdecisionpoints to update
     */
    where?: meetingdecisionpointWhereInput
  }

  /**
   * meetingdecisionpoint upsert
   */
  export type meetingdecisionpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * The filter to search for the meetingdecisionpoint to update in case it exists.
     */
    where: meetingdecisionpointWhereUniqueInput
    /**
     * In case the meetingdecisionpoint found by the `where` argument doesn't exist, create a new meetingdecisionpoint with this data.
     */
    create: XOR<meetingdecisionpointCreateInput, meetingdecisionpointUncheckedCreateInput>
    /**
     * In case the meetingdecisionpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meetingdecisionpointUpdateInput, meetingdecisionpointUncheckedUpdateInput>
  }

  /**
   * meetingdecisionpoint delete
   */
  export type meetingdecisionpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    /**
     * Filter which meetingdecisionpoint to delete.
     */
    where: meetingdecisionpointWhereUniqueInput
  }

  /**
   * meetingdecisionpoint deleteMany
   */
  export type meetingdecisionpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meetingdecisionpoints to delete
     */
    where?: meetingdecisionpointWhereInput
  }

  /**
   * meetingdecisionpoint without action
   */
  export type meetingdecisionpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
  }


  /**
   * Model meetinglog
   */

  export type AggregateMeetinglog = {
    _count: MeetinglogCountAggregateOutputType | null
    _min: MeetinglogMinAggregateOutputType | null
    _max: MeetinglogMaxAggregateOutputType | null
  }

  export type MeetinglogMinAggregateOutputType = {
    id: string | null
    meetingDate: Date | null
    title: string | null
    meetingType: $Enums.meetinglog_meetingType | null
    attendees: string | null
    agenda: string | null
    minutes: string | null
    actionItems: string | null
    status: $Enums.meetinglog_status | null
    imageUrl: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetinglogMaxAggregateOutputType = {
    id: string | null
    meetingDate: Date | null
    title: string | null
    meetingType: $Enums.meetinglog_meetingType | null
    attendees: string | null
    agenda: string | null
    minutes: string | null
    actionItems: string | null
    status: $Enums.meetinglog_status | null
    imageUrl: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetinglogCountAggregateOutputType = {
    id: number
    meetingDate: number
    title: number
    meetingType: number
    attendees: number
    agenda: number
    minutes: number
    actionItems: number
    status: number
    imageUrl: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetinglogMinAggregateInputType = {
    id?: true
    meetingDate?: true
    title?: true
    meetingType?: true
    attendees?: true
    agenda?: true
    minutes?: true
    actionItems?: true
    status?: true
    imageUrl?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetinglogMaxAggregateInputType = {
    id?: true
    meetingDate?: true
    title?: true
    meetingType?: true
    attendees?: true
    agenda?: true
    minutes?: true
    actionItems?: true
    status?: true
    imageUrl?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetinglogCountAggregateInputType = {
    id?: true
    meetingDate?: true
    title?: true
    meetingType?: true
    attendees?: true
    agenda?: true
    minutes?: true
    actionItems?: true
    status?: true
    imageUrl?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetinglogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meetinglog to aggregate.
     */
    where?: meetinglogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetinglogs to fetch.
     */
    orderBy?: meetinglogOrderByWithRelationInput | meetinglogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meetinglogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetinglogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetinglogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meetinglogs
    **/
    _count?: true | MeetinglogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetinglogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetinglogMaxAggregateInputType
  }

  export type GetMeetinglogAggregateType<T extends MeetinglogAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetinglog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetinglog[P]>
      : GetScalarType<T[P], AggregateMeetinglog[P]>
  }




  export type meetinglogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meetinglogWhereInput
    orderBy?: meetinglogOrderByWithAggregationInput | meetinglogOrderByWithAggregationInput[]
    by: MeetinglogScalarFieldEnum[] | MeetinglogScalarFieldEnum
    having?: meetinglogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetinglogCountAggregateInputType | true
    _min?: MeetinglogMinAggregateInputType
    _max?: MeetinglogMaxAggregateInputType
  }

  export type MeetinglogGroupByOutputType = {
    id: string
    meetingDate: Date
    title: string
    meetingType: $Enums.meetinglog_meetingType | null
    attendees: string
    agenda: string
    minutes: string
    actionItems: string | null
    status: $Enums.meetinglog_status | null
    imageUrl: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    _count: MeetinglogCountAggregateOutputType | null
    _min: MeetinglogMinAggregateOutputType | null
    _max: MeetinglogMaxAggregateOutputType | null
  }

  type GetMeetinglogGroupByPayload<T extends meetinglogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetinglogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetinglogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetinglogGroupByOutputType[P]>
            : GetScalarType<T[P], MeetinglogGroupByOutputType[P]>
        }
      >
    >


  export type meetinglogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingDate?: boolean
    title?: boolean
    meetingType?: boolean
    attendees?: boolean
    agenda?: boolean
    minutes?: boolean
    actionItems?: boolean
    status?: boolean
    imageUrl?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meetingdecisionpoint?: boolean | meetinglog$meetingdecisionpointArgs<ExtArgs>
    _count?: boolean | MeetinglogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetinglog"]>


  export type meetinglogSelectScalar = {
    id?: boolean
    meetingDate?: boolean
    title?: boolean
    meetingType?: boolean
    attendees?: boolean
    agenda?: boolean
    minutes?: boolean
    actionItems?: boolean
    status?: boolean
    imageUrl?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type meetinglogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meetingdecisionpoint?: boolean | meetinglog$meetingdecisionpointArgs<ExtArgs>
    _count?: boolean | MeetinglogCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $meetinglogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meetinglog"
    objects: {
      meetingdecisionpoint: Prisma.$meetingdecisionpointPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingDate: Date
      title: string
      meetingType: $Enums.meetinglog_meetingType | null
      attendees: string
      agenda: string
      minutes: string
      actionItems: string | null
      status: $Enums.meetinglog_status | null
      imageUrl: string | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meetinglog"]>
    composites: {}
  }

  type meetinglogGetPayload<S extends boolean | null | undefined | meetinglogDefaultArgs> = $Result.GetResult<Prisma.$meetinglogPayload, S>

  type meetinglogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<meetinglogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetinglogCountAggregateInputType | true
    }

  export interface meetinglogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meetinglog'], meta: { name: 'meetinglog' } }
    /**
     * Find zero or one Meetinglog that matches the filter.
     * @param {meetinglogFindUniqueArgs} args - Arguments to find a Meetinglog
     * @example
     * // Get one Meetinglog
     * const meetinglog = await prisma.meetinglog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meetinglogFindUniqueArgs>(args: SelectSubset<T, meetinglogFindUniqueArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meetinglog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {meetinglogFindUniqueOrThrowArgs} args - Arguments to find a Meetinglog
     * @example
     * // Get one Meetinglog
     * const meetinglog = await prisma.meetinglog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meetinglogFindUniqueOrThrowArgs>(args: SelectSubset<T, meetinglogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meetinglog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetinglogFindFirstArgs} args - Arguments to find a Meetinglog
     * @example
     * // Get one Meetinglog
     * const meetinglog = await prisma.meetinglog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meetinglogFindFirstArgs>(args?: SelectSubset<T, meetinglogFindFirstArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meetinglog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetinglogFindFirstOrThrowArgs} args - Arguments to find a Meetinglog
     * @example
     * // Get one Meetinglog
     * const meetinglog = await prisma.meetinglog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meetinglogFindFirstOrThrowArgs>(args?: SelectSubset<T, meetinglogFindFirstOrThrowArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meetinglogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetinglogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetinglogs
     * const meetinglogs = await prisma.meetinglog.findMany()
     * 
     * // Get first 10 Meetinglogs
     * const meetinglogs = await prisma.meetinglog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetinglogWithIdOnly = await prisma.meetinglog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends meetinglogFindManyArgs>(args?: SelectSubset<T, meetinglogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meetinglog.
     * @param {meetinglogCreateArgs} args - Arguments to create a Meetinglog.
     * @example
     * // Create one Meetinglog
     * const Meetinglog = await prisma.meetinglog.create({
     *   data: {
     *     // ... data to create a Meetinglog
     *   }
     * })
     * 
     */
    create<T extends meetinglogCreateArgs>(args: SelectSubset<T, meetinglogCreateArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meetinglogs.
     * @param {meetinglogCreateManyArgs} args - Arguments to create many Meetinglogs.
     * @example
     * // Create many Meetinglogs
     * const meetinglog = await prisma.meetinglog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meetinglogCreateManyArgs>(args?: SelectSubset<T, meetinglogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meetinglog.
     * @param {meetinglogDeleteArgs} args - Arguments to delete one Meetinglog.
     * @example
     * // Delete one Meetinglog
     * const Meetinglog = await prisma.meetinglog.delete({
     *   where: {
     *     // ... filter to delete one Meetinglog
     *   }
     * })
     * 
     */
    delete<T extends meetinglogDeleteArgs>(args: SelectSubset<T, meetinglogDeleteArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meetinglog.
     * @param {meetinglogUpdateArgs} args - Arguments to update one Meetinglog.
     * @example
     * // Update one Meetinglog
     * const meetinglog = await prisma.meetinglog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meetinglogUpdateArgs>(args: SelectSubset<T, meetinglogUpdateArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meetinglogs.
     * @param {meetinglogDeleteManyArgs} args - Arguments to filter Meetinglogs to delete.
     * @example
     * // Delete a few Meetinglogs
     * const { count } = await prisma.meetinglog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meetinglogDeleteManyArgs>(args?: SelectSubset<T, meetinglogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetinglogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetinglogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetinglogs
     * const meetinglog = await prisma.meetinglog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meetinglogUpdateManyArgs>(args: SelectSubset<T, meetinglogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meetinglog.
     * @param {meetinglogUpsertArgs} args - Arguments to update or create a Meetinglog.
     * @example
     * // Update or create a Meetinglog
     * const meetinglog = await prisma.meetinglog.upsert({
     *   create: {
     *     // ... data to create a Meetinglog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meetinglog we want to update
     *   }
     * })
     */
    upsert<T extends meetinglogUpsertArgs>(args: SelectSubset<T, meetinglogUpsertArgs<ExtArgs>>): Prisma__meetinglogClient<$Result.GetResult<Prisma.$meetinglogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meetinglogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetinglogCountArgs} args - Arguments to filter Meetinglogs to count.
     * @example
     * // Count the number of Meetinglogs
     * const count = await prisma.meetinglog.count({
     *   where: {
     *     // ... the filter for the Meetinglogs we want to count
     *   }
     * })
    **/
    count<T extends meetinglogCountArgs>(
      args?: Subset<T, meetinglogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetinglogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meetinglog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetinglogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetinglogAggregateArgs>(args: Subset<T, MeetinglogAggregateArgs>): Prisma.PrismaPromise<GetMeetinglogAggregateType<T>>

    /**
     * Group by Meetinglog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetinglogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meetinglogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meetinglogGroupByArgs['orderBy'] }
        : { orderBy?: meetinglogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meetinglogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetinglogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meetinglog model
   */
  readonly fields: meetinglogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meetinglog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meetinglogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meetingdecisionpoint<T extends meetinglog$meetingdecisionpointArgs<ExtArgs> = {}>(args?: Subset<T, meetinglog$meetingdecisionpointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meetingdecisionpointPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meetinglog model
   */ 
  interface meetinglogFieldRefs {
    readonly id: FieldRef<"meetinglog", 'String'>
    readonly meetingDate: FieldRef<"meetinglog", 'DateTime'>
    readonly title: FieldRef<"meetinglog", 'String'>
    readonly meetingType: FieldRef<"meetinglog", 'meetinglog_meetingType'>
    readonly attendees: FieldRef<"meetinglog", 'String'>
    readonly agenda: FieldRef<"meetinglog", 'String'>
    readonly minutes: FieldRef<"meetinglog", 'String'>
    readonly actionItems: FieldRef<"meetinglog", 'String'>
    readonly status: FieldRef<"meetinglog", 'meetinglog_status'>
    readonly imageUrl: FieldRef<"meetinglog", 'String'>
    readonly postedByOwnerId: FieldRef<"meetinglog", 'String'>
    readonly postedByOwnerName: FieldRef<"meetinglog", 'String'>
    readonly createdAt: FieldRef<"meetinglog", 'DateTime'>
    readonly updatedAt: FieldRef<"meetinglog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meetinglog findUnique
   */
  export type meetinglogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * Filter, which meetinglog to fetch.
     */
    where: meetinglogWhereUniqueInput
  }

  /**
   * meetinglog findUniqueOrThrow
   */
  export type meetinglogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * Filter, which meetinglog to fetch.
     */
    where: meetinglogWhereUniqueInput
  }

  /**
   * meetinglog findFirst
   */
  export type meetinglogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * Filter, which meetinglog to fetch.
     */
    where?: meetinglogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetinglogs to fetch.
     */
    orderBy?: meetinglogOrderByWithRelationInput | meetinglogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meetinglogs.
     */
    cursor?: meetinglogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetinglogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetinglogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meetinglogs.
     */
    distinct?: MeetinglogScalarFieldEnum | MeetinglogScalarFieldEnum[]
  }

  /**
   * meetinglog findFirstOrThrow
   */
  export type meetinglogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * Filter, which meetinglog to fetch.
     */
    where?: meetinglogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetinglogs to fetch.
     */
    orderBy?: meetinglogOrderByWithRelationInput | meetinglogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meetinglogs.
     */
    cursor?: meetinglogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetinglogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetinglogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meetinglogs.
     */
    distinct?: MeetinglogScalarFieldEnum | MeetinglogScalarFieldEnum[]
  }

  /**
   * meetinglog findMany
   */
  export type meetinglogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * Filter, which meetinglogs to fetch.
     */
    where?: meetinglogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetinglogs to fetch.
     */
    orderBy?: meetinglogOrderByWithRelationInput | meetinglogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meetinglogs.
     */
    cursor?: meetinglogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetinglogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetinglogs.
     */
    skip?: number
    distinct?: MeetinglogScalarFieldEnum | MeetinglogScalarFieldEnum[]
  }

  /**
   * meetinglog create
   */
  export type meetinglogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * The data needed to create a meetinglog.
     */
    data: XOR<meetinglogCreateInput, meetinglogUncheckedCreateInput>
  }

  /**
   * meetinglog createMany
   */
  export type meetinglogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meetinglogs.
     */
    data: meetinglogCreateManyInput | meetinglogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meetinglog update
   */
  export type meetinglogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * The data needed to update a meetinglog.
     */
    data: XOR<meetinglogUpdateInput, meetinglogUncheckedUpdateInput>
    /**
     * Choose, which meetinglog to update.
     */
    where: meetinglogWhereUniqueInput
  }

  /**
   * meetinglog updateMany
   */
  export type meetinglogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meetinglogs.
     */
    data: XOR<meetinglogUpdateManyMutationInput, meetinglogUncheckedUpdateManyInput>
    /**
     * Filter which meetinglogs to update
     */
    where?: meetinglogWhereInput
  }

  /**
   * meetinglog upsert
   */
  export type meetinglogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * The filter to search for the meetinglog to update in case it exists.
     */
    where: meetinglogWhereUniqueInput
    /**
     * In case the meetinglog found by the `where` argument doesn't exist, create a new meetinglog with this data.
     */
    create: XOR<meetinglogCreateInput, meetinglogUncheckedCreateInput>
    /**
     * In case the meetinglog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meetinglogUpdateInput, meetinglogUncheckedUpdateInput>
  }

  /**
   * meetinglog delete
   */
  export type meetinglogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
    /**
     * Filter which meetinglog to delete.
     */
    where: meetinglogWhereUniqueInput
  }

  /**
   * meetinglog deleteMany
   */
  export type meetinglogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meetinglogs to delete
     */
    where?: meetinglogWhereInput
  }

  /**
   * meetinglog.meetingdecisionpoint
   */
  export type meetinglog$meetingdecisionpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetingdecisionpoint
     */
    select?: meetingdecisionpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingdecisionpointInclude<ExtArgs> | null
    where?: meetingdecisionpointWhereInput
    orderBy?: meetingdecisionpointOrderByWithRelationInput | meetingdecisionpointOrderByWithRelationInput[]
    cursor?: meetingdecisionpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingdecisionpointScalarFieldEnum | MeetingdecisionpointScalarFieldEnum[]
  }

  /**
   * meetinglog without action
   */
  export type meetinglogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meetinglog
     */
    select?: meetinglogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetinglogInclude<ExtArgs> | null
  }


  /**
   * Model ministry
   */

  export type AggregateMinistry = {
    _count: MinistryCountAggregateOutputType | null
    _min: MinistryMinAggregateOutputType | null
    _max: MinistryMaxAggregateOutputType | null
  }

  export type MinistryMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.ministry_category | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    leader: string | null
    meetingTime: string | null
  }

  export type MinistryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.ministry_category | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    leader: string | null
    meetingTime: string | null
  }

  export type MinistryCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    linkPath: number
    category: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    leader: number
    meetingTime: number
    _all: number
  }


  export type MinistryMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    leader?: true
    meetingTime?: true
  }

  export type MinistryMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    leader?: true
    meetingTime?: true
  }

  export type MinistryCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    leader?: true
    meetingTime?: true
    _all?: true
  }

  export type MinistryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ministry to aggregate.
     */
    where?: ministryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministries to fetch.
     */
    orderBy?: ministryOrderByWithRelationInput | ministryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ministryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ministries
    **/
    _count?: true | MinistryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinistryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinistryMaxAggregateInputType
  }

  export type GetMinistryAggregateType<T extends MinistryAggregateArgs> = {
        [P in keyof T & keyof AggregateMinistry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinistry[P]>
      : GetScalarType<T[P], AggregateMinistry[P]>
  }




  export type ministryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ministryWhereInput
    orderBy?: ministryOrderByWithAggregationInput | ministryOrderByWithAggregationInput[]
    by: MinistryScalarFieldEnum[] | MinistryScalarFieldEnum
    having?: ministryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinistryCountAggregateInputType | true
    _min?: MinistryMinAggregateInputType
    _max?: MinistryMaxAggregateInputType
  }

  export type MinistryGroupByOutputType = {
    id: string
    title: string
    description: string
    imageUrl: string | null
    linkPath: string
    category: $Enums.ministry_category | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    leader: string | null
    meetingTime: string | null
    _count: MinistryCountAggregateOutputType | null
    _min: MinistryMinAggregateOutputType | null
    _max: MinistryMaxAggregateOutputType | null
  }

  type GetMinistryGroupByPayload<T extends ministryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinistryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinistryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinistryGroupByOutputType[P]>
            : GetScalarType<T[P], MinistryGroupByOutputType[P]>
        }
      >
    >


  export type ministrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leader?: boolean
    meetingTime?: boolean
    ministryjoinrequest?: boolean | ministry$ministryjoinrequestArgs<ExtArgs>
    _count?: boolean | MinistryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ministry"]>


  export type ministrySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    leader?: boolean
    meetingTime?: boolean
  }

  export type ministryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ministryjoinrequest?: boolean | ministry$ministryjoinrequestArgs<ExtArgs>
    _count?: boolean | MinistryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ministryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ministry"
    objects: {
      ministryjoinrequest: Prisma.$ministryjoinrequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      imageUrl: string | null
      linkPath: string
      category: $Enums.ministry_category | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      leader: string | null
      meetingTime: string | null
    }, ExtArgs["result"]["ministry"]>
    composites: {}
  }

  type ministryGetPayload<S extends boolean | null | undefined | ministryDefaultArgs> = $Result.GetResult<Prisma.$ministryPayload, S>

  type ministryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ministryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MinistryCountAggregateInputType | true
    }

  export interface ministryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ministry'], meta: { name: 'ministry' } }
    /**
     * Find zero or one Ministry that matches the filter.
     * @param {ministryFindUniqueArgs} args - Arguments to find a Ministry
     * @example
     * // Get one Ministry
     * const ministry = await prisma.ministry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ministryFindUniqueArgs>(args: SelectSubset<T, ministryFindUniqueArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ministry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ministryFindUniqueOrThrowArgs} args - Arguments to find a Ministry
     * @example
     * // Get one Ministry
     * const ministry = await prisma.ministry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ministryFindUniqueOrThrowArgs>(args: SelectSubset<T, ministryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ministry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryFindFirstArgs} args - Arguments to find a Ministry
     * @example
     * // Get one Ministry
     * const ministry = await prisma.ministry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ministryFindFirstArgs>(args?: SelectSubset<T, ministryFindFirstArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ministry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryFindFirstOrThrowArgs} args - Arguments to find a Ministry
     * @example
     * // Get one Ministry
     * const ministry = await prisma.ministry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ministryFindFirstOrThrowArgs>(args?: SelectSubset<T, ministryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ministries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ministries
     * const ministries = await prisma.ministry.findMany()
     * 
     * // Get first 10 Ministries
     * const ministries = await prisma.ministry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ministryWithIdOnly = await prisma.ministry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ministryFindManyArgs>(args?: SelectSubset<T, ministryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ministry.
     * @param {ministryCreateArgs} args - Arguments to create a Ministry.
     * @example
     * // Create one Ministry
     * const Ministry = await prisma.ministry.create({
     *   data: {
     *     // ... data to create a Ministry
     *   }
     * })
     * 
     */
    create<T extends ministryCreateArgs>(args: SelectSubset<T, ministryCreateArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ministries.
     * @param {ministryCreateManyArgs} args - Arguments to create many Ministries.
     * @example
     * // Create many Ministries
     * const ministry = await prisma.ministry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ministryCreateManyArgs>(args?: SelectSubset<T, ministryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ministry.
     * @param {ministryDeleteArgs} args - Arguments to delete one Ministry.
     * @example
     * // Delete one Ministry
     * const Ministry = await prisma.ministry.delete({
     *   where: {
     *     // ... filter to delete one Ministry
     *   }
     * })
     * 
     */
    delete<T extends ministryDeleteArgs>(args: SelectSubset<T, ministryDeleteArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ministry.
     * @param {ministryUpdateArgs} args - Arguments to update one Ministry.
     * @example
     * // Update one Ministry
     * const ministry = await prisma.ministry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ministryUpdateArgs>(args: SelectSubset<T, ministryUpdateArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ministries.
     * @param {ministryDeleteManyArgs} args - Arguments to filter Ministries to delete.
     * @example
     * // Delete a few Ministries
     * const { count } = await prisma.ministry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ministryDeleteManyArgs>(args?: SelectSubset<T, ministryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ministries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ministries
     * const ministry = await prisma.ministry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ministryUpdateManyArgs>(args: SelectSubset<T, ministryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ministry.
     * @param {ministryUpsertArgs} args - Arguments to update or create a Ministry.
     * @example
     * // Update or create a Ministry
     * const ministry = await prisma.ministry.upsert({
     *   create: {
     *     // ... data to create a Ministry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ministry we want to update
     *   }
     * })
     */
    upsert<T extends ministryUpsertArgs>(args: SelectSubset<T, ministryUpsertArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ministries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryCountArgs} args - Arguments to filter Ministries to count.
     * @example
     * // Count the number of Ministries
     * const count = await prisma.ministry.count({
     *   where: {
     *     // ... the filter for the Ministries we want to count
     *   }
     * })
    **/
    count<T extends ministryCountArgs>(
      args?: Subset<T, ministryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinistryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ministry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinistryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinistryAggregateArgs>(args: Subset<T, MinistryAggregateArgs>): Prisma.PrismaPromise<GetMinistryAggregateType<T>>

    /**
     * Group by Ministry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ministryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ministryGroupByArgs['orderBy'] }
        : { orderBy?: ministryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ministryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinistryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ministry model
   */
  readonly fields: ministryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ministry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ministryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ministryjoinrequest<T extends ministry$ministryjoinrequestArgs<ExtArgs> = {}>(args?: Subset<T, ministry$ministryjoinrequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ministry model
   */ 
  interface ministryFieldRefs {
    readonly id: FieldRef<"ministry", 'String'>
    readonly title: FieldRef<"ministry", 'String'>
    readonly description: FieldRef<"ministry", 'String'>
    readonly imageUrl: FieldRef<"ministry", 'String'>
    readonly linkPath: FieldRef<"ministry", 'String'>
    readonly category: FieldRef<"ministry", 'ministry_category'>
    readonly postedByOwnerId: FieldRef<"ministry", 'String'>
    readonly postedByOwnerName: FieldRef<"ministry", 'String'>
    readonly createdAt: FieldRef<"ministry", 'DateTime'>
    readonly updatedAt: FieldRef<"ministry", 'DateTime'>
    readonly leader: FieldRef<"ministry", 'String'>
    readonly meetingTime: FieldRef<"ministry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ministry findUnique
   */
  export type ministryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * Filter, which ministry to fetch.
     */
    where: ministryWhereUniqueInput
  }

  /**
   * ministry findUniqueOrThrow
   */
  export type ministryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * Filter, which ministry to fetch.
     */
    where: ministryWhereUniqueInput
  }

  /**
   * ministry findFirst
   */
  export type ministryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * Filter, which ministry to fetch.
     */
    where?: ministryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministries to fetch.
     */
    orderBy?: ministryOrderByWithRelationInput | ministryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ministries.
     */
    cursor?: ministryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ministries.
     */
    distinct?: MinistryScalarFieldEnum | MinistryScalarFieldEnum[]
  }

  /**
   * ministry findFirstOrThrow
   */
  export type ministryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * Filter, which ministry to fetch.
     */
    where?: ministryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministries to fetch.
     */
    orderBy?: ministryOrderByWithRelationInput | ministryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ministries.
     */
    cursor?: ministryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ministries.
     */
    distinct?: MinistryScalarFieldEnum | MinistryScalarFieldEnum[]
  }

  /**
   * ministry findMany
   */
  export type ministryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * Filter, which ministries to fetch.
     */
    where?: ministryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministries to fetch.
     */
    orderBy?: ministryOrderByWithRelationInput | ministryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ministries.
     */
    cursor?: ministryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministries.
     */
    skip?: number
    distinct?: MinistryScalarFieldEnum | MinistryScalarFieldEnum[]
  }

  /**
   * ministry create
   */
  export type ministryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * The data needed to create a ministry.
     */
    data: XOR<ministryCreateInput, ministryUncheckedCreateInput>
  }

  /**
   * ministry createMany
   */
  export type ministryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ministries.
     */
    data: ministryCreateManyInput | ministryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ministry update
   */
  export type ministryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * The data needed to update a ministry.
     */
    data: XOR<ministryUpdateInput, ministryUncheckedUpdateInput>
    /**
     * Choose, which ministry to update.
     */
    where: ministryWhereUniqueInput
  }

  /**
   * ministry updateMany
   */
  export type ministryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ministries.
     */
    data: XOR<ministryUpdateManyMutationInput, ministryUncheckedUpdateManyInput>
    /**
     * Filter which ministries to update
     */
    where?: ministryWhereInput
  }

  /**
   * ministry upsert
   */
  export type ministryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * The filter to search for the ministry to update in case it exists.
     */
    where: ministryWhereUniqueInput
    /**
     * In case the ministry found by the `where` argument doesn't exist, create a new ministry with this data.
     */
    create: XOR<ministryCreateInput, ministryUncheckedCreateInput>
    /**
     * In case the ministry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ministryUpdateInput, ministryUncheckedUpdateInput>
  }

  /**
   * ministry delete
   */
  export type ministryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
    /**
     * Filter which ministry to delete.
     */
    where: ministryWhereUniqueInput
  }

  /**
   * ministry deleteMany
   */
  export type ministryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ministries to delete
     */
    where?: ministryWhereInput
  }

  /**
   * ministry.ministryjoinrequest
   */
  export type ministry$ministryjoinrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    where?: ministryjoinrequestWhereInput
    orderBy?: ministryjoinrequestOrderByWithRelationInput | ministryjoinrequestOrderByWithRelationInput[]
    cursor?: ministryjoinrequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinistryjoinrequestScalarFieldEnum | MinistryjoinrequestScalarFieldEnum[]
  }

  /**
   * ministry without action
   */
  export type ministryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministry
     */
    select?: ministrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryInclude<ExtArgs> | null
  }


  /**
   * Model ministryjoinrequest
   */

  export type AggregateMinistryjoinrequest = {
    _count: MinistryjoinrequestCountAggregateOutputType | null
    _min: MinistryjoinrequestMinAggregateOutputType | null
    _max: MinistryjoinrequestMaxAggregateOutputType | null
  }

  export type MinistryjoinrequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    ministryId: string | null
    ministryName: string | null
    ministryGuidelines: string | null
    requestDate: Date | null
    message: string | null
    status: $Enums.ministryjoinrequest_status | null
    processedDate: Date | null
    adminNotes: string | null
  }

  export type MinistryjoinrequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userEmail: string | null
    ministryId: string | null
    ministryName: string | null
    ministryGuidelines: string | null
    requestDate: Date | null
    message: string | null
    status: $Enums.ministryjoinrequest_status | null
    processedDate: Date | null
    adminNotes: string | null
  }

  export type MinistryjoinrequestCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    userEmail: number
    ministryId: number
    ministryName: number
    ministryGuidelines: number
    requestDate: number
    message: number
    status: number
    processedDate: number
    adminNotes: number
    _all: number
  }


  export type MinistryjoinrequestMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    ministryId?: true
    ministryName?: true
    ministryGuidelines?: true
    requestDate?: true
    message?: true
    status?: true
    processedDate?: true
    adminNotes?: true
  }

  export type MinistryjoinrequestMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    ministryId?: true
    ministryName?: true
    ministryGuidelines?: true
    requestDate?: true
    message?: true
    status?: true
    processedDate?: true
    adminNotes?: true
  }

  export type MinistryjoinrequestCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userEmail?: true
    ministryId?: true
    ministryName?: true
    ministryGuidelines?: true
    requestDate?: true
    message?: true
    status?: true
    processedDate?: true
    adminNotes?: true
    _all?: true
  }

  export type MinistryjoinrequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ministryjoinrequest to aggregate.
     */
    where?: ministryjoinrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministryjoinrequests to fetch.
     */
    orderBy?: ministryjoinrequestOrderByWithRelationInput | ministryjoinrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ministryjoinrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministryjoinrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministryjoinrequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ministryjoinrequests
    **/
    _count?: true | MinistryjoinrequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinistryjoinrequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinistryjoinrequestMaxAggregateInputType
  }

  export type GetMinistryjoinrequestAggregateType<T extends MinistryjoinrequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMinistryjoinrequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinistryjoinrequest[P]>
      : GetScalarType<T[P], AggregateMinistryjoinrequest[P]>
  }




  export type ministryjoinrequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ministryjoinrequestWhereInput
    orderBy?: ministryjoinrequestOrderByWithAggregationInput | ministryjoinrequestOrderByWithAggregationInput[]
    by: MinistryjoinrequestScalarFieldEnum[] | MinistryjoinrequestScalarFieldEnum
    having?: ministryjoinrequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinistryjoinrequestCountAggregateInputType | true
    _min?: MinistryjoinrequestMinAggregateInputType
    _max?: MinistryjoinrequestMaxAggregateInputType
  }

  export type MinistryjoinrequestGroupByOutputType = {
    id: string
    userId: string
    userName: string
    userEmail: string
    ministryId: string
    ministryName: string
    ministryGuidelines: string
    requestDate: Date
    message: string
    status: $Enums.ministryjoinrequest_status
    processedDate: Date | null
    adminNotes: string | null
    _count: MinistryjoinrequestCountAggregateOutputType | null
    _min: MinistryjoinrequestMinAggregateOutputType | null
    _max: MinistryjoinrequestMaxAggregateOutputType | null
  }

  type GetMinistryjoinrequestGroupByPayload<T extends ministryjoinrequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinistryjoinrequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinistryjoinrequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinistryjoinrequestGroupByOutputType[P]>
            : GetScalarType<T[P], MinistryjoinrequestGroupByOutputType[P]>
        }
      >
    >


  export type ministryjoinrequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    ministryId?: boolean
    ministryName?: boolean
    ministryGuidelines?: boolean
    requestDate?: boolean
    message?: boolean
    status?: boolean
    processedDate?: boolean
    adminNotes?: boolean
    ministry?: boolean | ministryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ministryjoinrequest"]>


  export type ministryjoinrequestSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    userEmail?: boolean
    ministryId?: boolean
    ministryName?: boolean
    ministryGuidelines?: boolean
    requestDate?: boolean
    message?: boolean
    status?: boolean
    processedDate?: boolean
    adminNotes?: boolean
  }

  export type ministryjoinrequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ministry?: boolean | ministryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $ministryjoinrequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ministryjoinrequest"
    objects: {
      ministry: Prisma.$ministryPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string
      userEmail: string
      ministryId: string
      ministryName: string
      ministryGuidelines: string
      requestDate: Date
      message: string
      status: $Enums.ministryjoinrequest_status
      processedDate: Date | null
      adminNotes: string | null
    }, ExtArgs["result"]["ministryjoinrequest"]>
    composites: {}
  }

  type ministryjoinrequestGetPayload<S extends boolean | null | undefined | ministryjoinrequestDefaultArgs> = $Result.GetResult<Prisma.$ministryjoinrequestPayload, S>

  type ministryjoinrequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ministryjoinrequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MinistryjoinrequestCountAggregateInputType | true
    }

  export interface ministryjoinrequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ministryjoinrequest'], meta: { name: 'ministryjoinrequest' } }
    /**
     * Find zero or one Ministryjoinrequest that matches the filter.
     * @param {ministryjoinrequestFindUniqueArgs} args - Arguments to find a Ministryjoinrequest
     * @example
     * // Get one Ministryjoinrequest
     * const ministryjoinrequest = await prisma.ministryjoinrequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ministryjoinrequestFindUniqueArgs>(args: SelectSubset<T, ministryjoinrequestFindUniqueArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ministryjoinrequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ministryjoinrequestFindUniqueOrThrowArgs} args - Arguments to find a Ministryjoinrequest
     * @example
     * // Get one Ministryjoinrequest
     * const ministryjoinrequest = await prisma.ministryjoinrequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ministryjoinrequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ministryjoinrequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ministryjoinrequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryjoinrequestFindFirstArgs} args - Arguments to find a Ministryjoinrequest
     * @example
     * // Get one Ministryjoinrequest
     * const ministryjoinrequest = await prisma.ministryjoinrequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ministryjoinrequestFindFirstArgs>(args?: SelectSubset<T, ministryjoinrequestFindFirstArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ministryjoinrequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryjoinrequestFindFirstOrThrowArgs} args - Arguments to find a Ministryjoinrequest
     * @example
     * // Get one Ministryjoinrequest
     * const ministryjoinrequest = await prisma.ministryjoinrequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ministryjoinrequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ministryjoinrequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ministryjoinrequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryjoinrequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ministryjoinrequests
     * const ministryjoinrequests = await prisma.ministryjoinrequest.findMany()
     * 
     * // Get first 10 Ministryjoinrequests
     * const ministryjoinrequests = await prisma.ministryjoinrequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ministryjoinrequestWithIdOnly = await prisma.ministryjoinrequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ministryjoinrequestFindManyArgs>(args?: SelectSubset<T, ministryjoinrequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ministryjoinrequest.
     * @param {ministryjoinrequestCreateArgs} args - Arguments to create a Ministryjoinrequest.
     * @example
     * // Create one Ministryjoinrequest
     * const Ministryjoinrequest = await prisma.ministryjoinrequest.create({
     *   data: {
     *     // ... data to create a Ministryjoinrequest
     *   }
     * })
     * 
     */
    create<T extends ministryjoinrequestCreateArgs>(args: SelectSubset<T, ministryjoinrequestCreateArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ministryjoinrequests.
     * @param {ministryjoinrequestCreateManyArgs} args - Arguments to create many Ministryjoinrequests.
     * @example
     * // Create many Ministryjoinrequests
     * const ministryjoinrequest = await prisma.ministryjoinrequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ministryjoinrequestCreateManyArgs>(args?: SelectSubset<T, ministryjoinrequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ministryjoinrequest.
     * @param {ministryjoinrequestDeleteArgs} args - Arguments to delete one Ministryjoinrequest.
     * @example
     * // Delete one Ministryjoinrequest
     * const Ministryjoinrequest = await prisma.ministryjoinrequest.delete({
     *   where: {
     *     // ... filter to delete one Ministryjoinrequest
     *   }
     * })
     * 
     */
    delete<T extends ministryjoinrequestDeleteArgs>(args: SelectSubset<T, ministryjoinrequestDeleteArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ministryjoinrequest.
     * @param {ministryjoinrequestUpdateArgs} args - Arguments to update one Ministryjoinrequest.
     * @example
     * // Update one Ministryjoinrequest
     * const ministryjoinrequest = await prisma.ministryjoinrequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ministryjoinrequestUpdateArgs>(args: SelectSubset<T, ministryjoinrequestUpdateArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ministryjoinrequests.
     * @param {ministryjoinrequestDeleteManyArgs} args - Arguments to filter Ministryjoinrequests to delete.
     * @example
     * // Delete a few Ministryjoinrequests
     * const { count } = await prisma.ministryjoinrequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ministryjoinrequestDeleteManyArgs>(args?: SelectSubset<T, ministryjoinrequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ministryjoinrequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryjoinrequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ministryjoinrequests
     * const ministryjoinrequest = await prisma.ministryjoinrequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ministryjoinrequestUpdateManyArgs>(args: SelectSubset<T, ministryjoinrequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ministryjoinrequest.
     * @param {ministryjoinrequestUpsertArgs} args - Arguments to update or create a Ministryjoinrequest.
     * @example
     * // Update or create a Ministryjoinrequest
     * const ministryjoinrequest = await prisma.ministryjoinrequest.upsert({
     *   create: {
     *     // ... data to create a Ministryjoinrequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ministryjoinrequest we want to update
     *   }
     * })
     */
    upsert<T extends ministryjoinrequestUpsertArgs>(args: SelectSubset<T, ministryjoinrequestUpsertArgs<ExtArgs>>): Prisma__ministryjoinrequestClient<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ministryjoinrequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryjoinrequestCountArgs} args - Arguments to filter Ministryjoinrequests to count.
     * @example
     * // Count the number of Ministryjoinrequests
     * const count = await prisma.ministryjoinrequest.count({
     *   where: {
     *     // ... the filter for the Ministryjoinrequests we want to count
     *   }
     * })
    **/
    count<T extends ministryjoinrequestCountArgs>(
      args?: Subset<T, ministryjoinrequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinistryjoinrequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ministryjoinrequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinistryjoinrequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinistryjoinrequestAggregateArgs>(args: Subset<T, MinistryjoinrequestAggregateArgs>): Prisma.PrismaPromise<GetMinistryjoinrequestAggregateType<T>>

    /**
     * Group by Ministryjoinrequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ministryjoinrequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ministryjoinrequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ministryjoinrequestGroupByArgs['orderBy'] }
        : { orderBy?: ministryjoinrequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ministryjoinrequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinistryjoinrequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ministryjoinrequest model
   */
  readonly fields: ministryjoinrequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ministryjoinrequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ministryjoinrequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ministry<T extends ministryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ministryDefaultArgs<ExtArgs>>): Prisma__ministryClient<$Result.GetResult<Prisma.$ministryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ministryjoinrequest model
   */ 
  interface ministryjoinrequestFieldRefs {
    readonly id: FieldRef<"ministryjoinrequest", 'String'>
    readonly userId: FieldRef<"ministryjoinrequest", 'String'>
    readonly userName: FieldRef<"ministryjoinrequest", 'String'>
    readonly userEmail: FieldRef<"ministryjoinrequest", 'String'>
    readonly ministryId: FieldRef<"ministryjoinrequest", 'String'>
    readonly ministryName: FieldRef<"ministryjoinrequest", 'String'>
    readonly ministryGuidelines: FieldRef<"ministryjoinrequest", 'String'>
    readonly requestDate: FieldRef<"ministryjoinrequest", 'DateTime'>
    readonly message: FieldRef<"ministryjoinrequest", 'String'>
    readonly status: FieldRef<"ministryjoinrequest", 'ministryjoinrequest_status'>
    readonly processedDate: FieldRef<"ministryjoinrequest", 'DateTime'>
    readonly adminNotes: FieldRef<"ministryjoinrequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ministryjoinrequest findUnique
   */
  export type ministryjoinrequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * Filter, which ministryjoinrequest to fetch.
     */
    where: ministryjoinrequestWhereUniqueInput
  }

  /**
   * ministryjoinrequest findUniqueOrThrow
   */
  export type ministryjoinrequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * Filter, which ministryjoinrequest to fetch.
     */
    where: ministryjoinrequestWhereUniqueInput
  }

  /**
   * ministryjoinrequest findFirst
   */
  export type ministryjoinrequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * Filter, which ministryjoinrequest to fetch.
     */
    where?: ministryjoinrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministryjoinrequests to fetch.
     */
    orderBy?: ministryjoinrequestOrderByWithRelationInput | ministryjoinrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ministryjoinrequests.
     */
    cursor?: ministryjoinrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministryjoinrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministryjoinrequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ministryjoinrequests.
     */
    distinct?: MinistryjoinrequestScalarFieldEnum | MinistryjoinrequestScalarFieldEnum[]
  }

  /**
   * ministryjoinrequest findFirstOrThrow
   */
  export type ministryjoinrequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * Filter, which ministryjoinrequest to fetch.
     */
    where?: ministryjoinrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministryjoinrequests to fetch.
     */
    orderBy?: ministryjoinrequestOrderByWithRelationInput | ministryjoinrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ministryjoinrequests.
     */
    cursor?: ministryjoinrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministryjoinrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministryjoinrequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ministryjoinrequests.
     */
    distinct?: MinistryjoinrequestScalarFieldEnum | MinistryjoinrequestScalarFieldEnum[]
  }

  /**
   * ministryjoinrequest findMany
   */
  export type ministryjoinrequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * Filter, which ministryjoinrequests to fetch.
     */
    where?: ministryjoinrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ministryjoinrequests to fetch.
     */
    orderBy?: ministryjoinrequestOrderByWithRelationInput | ministryjoinrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ministryjoinrequests.
     */
    cursor?: ministryjoinrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ministryjoinrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ministryjoinrequests.
     */
    skip?: number
    distinct?: MinistryjoinrequestScalarFieldEnum | MinistryjoinrequestScalarFieldEnum[]
  }

  /**
   * ministryjoinrequest create
   */
  export type ministryjoinrequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ministryjoinrequest.
     */
    data: XOR<ministryjoinrequestCreateInput, ministryjoinrequestUncheckedCreateInput>
  }

  /**
   * ministryjoinrequest createMany
   */
  export type ministryjoinrequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ministryjoinrequests.
     */
    data: ministryjoinrequestCreateManyInput | ministryjoinrequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ministryjoinrequest update
   */
  export type ministryjoinrequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ministryjoinrequest.
     */
    data: XOR<ministryjoinrequestUpdateInput, ministryjoinrequestUncheckedUpdateInput>
    /**
     * Choose, which ministryjoinrequest to update.
     */
    where: ministryjoinrequestWhereUniqueInput
  }

  /**
   * ministryjoinrequest updateMany
   */
  export type ministryjoinrequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ministryjoinrequests.
     */
    data: XOR<ministryjoinrequestUpdateManyMutationInput, ministryjoinrequestUncheckedUpdateManyInput>
    /**
     * Filter which ministryjoinrequests to update
     */
    where?: ministryjoinrequestWhereInput
  }

  /**
   * ministryjoinrequest upsert
   */
  export type ministryjoinrequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ministryjoinrequest to update in case it exists.
     */
    where: ministryjoinrequestWhereUniqueInput
    /**
     * In case the ministryjoinrequest found by the `where` argument doesn't exist, create a new ministryjoinrequest with this data.
     */
    create: XOR<ministryjoinrequestCreateInput, ministryjoinrequestUncheckedCreateInput>
    /**
     * In case the ministryjoinrequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ministryjoinrequestUpdateInput, ministryjoinrequestUncheckedUpdateInput>
  }

  /**
   * ministryjoinrequest delete
   */
  export type ministryjoinrequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    /**
     * Filter which ministryjoinrequest to delete.
     */
    where: ministryjoinrequestWhereUniqueInput
  }

  /**
   * ministryjoinrequest deleteMany
   */
  export type ministryjoinrequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ministryjoinrequests to delete
     */
    where?: ministryjoinrequestWhereInput
  }

  /**
   * ministryjoinrequest without action
   */
  export type ministryjoinrequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
  }


  /**
   * Model monthlythemeimage
   */

  export type AggregateMonthlythemeimage = {
    _count: MonthlythemeimageCountAggregateOutputType | null
    _avg: MonthlythemeimageAvgAggregateOutputType | null
    _sum: MonthlythemeimageSumAggregateOutputType | null
    _min: MonthlythemeimageMinAggregateOutputType | null
    _max: MonthlythemeimageMaxAggregateOutputType | null
  }

  export type MonthlythemeimageAvgAggregateOutputType = {
    year: number | null
    month: number | null
  }

  export type MonthlythemeimageSumAggregateOutputType = {
    year: number | null
    month: number | null
  }

  export type MonthlythemeimageMinAggregateOutputType = {
    id: string | null
    year: number | null
    month: number | null
    quoteOrCaption: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type MonthlythemeimageMaxAggregateOutputType = {
    id: string | null
    year: number | null
    month: number | null
    quoteOrCaption: string | null
    createdAt: Date | null
    updatedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
  }

  export type MonthlythemeimageCountAggregateOutputType = {
    id: number
    year: number
    month: number
    imageUrls: number
    quoteOrCaption: number
    createdAt: number
    updatedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    _all: number
  }


  export type MonthlythemeimageAvgAggregateInputType = {
    year?: true
    month?: true
  }

  export type MonthlythemeimageSumAggregateInputType = {
    year?: true
    month?: true
  }

  export type MonthlythemeimageMinAggregateInputType = {
    id?: true
    year?: true
    month?: true
    quoteOrCaption?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type MonthlythemeimageMaxAggregateInputType = {
    id?: true
    year?: true
    month?: true
    quoteOrCaption?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
  }

  export type MonthlythemeimageCountAggregateInputType = {
    id?: true
    year?: true
    month?: true
    imageUrls?: true
    quoteOrCaption?: true
    createdAt?: true
    updatedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    _all?: true
  }

  export type MonthlythemeimageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monthlythemeimage to aggregate.
     */
    where?: monthlythemeimageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthlythemeimages to fetch.
     */
    orderBy?: monthlythemeimageOrderByWithRelationInput | monthlythemeimageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: monthlythemeimageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthlythemeimages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthlythemeimages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned monthlythemeimages
    **/
    _count?: true | MonthlythemeimageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthlythemeimageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthlythemeimageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthlythemeimageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthlythemeimageMaxAggregateInputType
  }

  export type GetMonthlythemeimageAggregateType<T extends MonthlythemeimageAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthlythemeimage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthlythemeimage[P]>
      : GetScalarType<T[P], AggregateMonthlythemeimage[P]>
  }




  export type monthlythemeimageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: monthlythemeimageWhereInput
    orderBy?: monthlythemeimageOrderByWithAggregationInput | monthlythemeimageOrderByWithAggregationInput[]
    by: MonthlythemeimageScalarFieldEnum[] | MonthlythemeimageScalarFieldEnum
    having?: monthlythemeimageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthlythemeimageCountAggregateInputType | true
    _avg?: MonthlythemeimageAvgAggregateInputType
    _sum?: MonthlythemeimageSumAggregateInputType
    _min?: MonthlythemeimageMinAggregateInputType
    _max?: MonthlythemeimageMaxAggregateInputType
  }

  export type MonthlythemeimageGroupByOutputType = {
    id: string
    year: number
    month: number
    imageUrls: JsonValue
    quoteOrCaption: string | null
    createdAt: Date
    updatedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    _count: MonthlythemeimageCountAggregateOutputType | null
    _avg: MonthlythemeimageAvgAggregateOutputType | null
    _sum: MonthlythemeimageSumAggregateOutputType | null
    _min: MonthlythemeimageMinAggregateOutputType | null
    _max: MonthlythemeimageMaxAggregateOutputType | null
  }

  type GetMonthlythemeimageGroupByPayload<T extends monthlythemeimageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthlythemeimageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthlythemeimageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthlythemeimageGroupByOutputType[P]>
            : GetScalarType<T[P], MonthlythemeimageGroupByOutputType[P]>
        }
      >
    >


  export type monthlythemeimageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    month?: boolean
    imageUrls?: boolean
    quoteOrCaption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }, ExtArgs["result"]["monthlythemeimage"]>


  export type monthlythemeimageSelectScalar = {
    id?: boolean
    year?: boolean
    month?: boolean
    imageUrls?: boolean
    quoteOrCaption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
  }


  export type $monthlythemeimagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "monthlythemeimage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      month: number
      imageUrls: Prisma.JsonValue
      quoteOrCaption: string | null
      createdAt: Date
      updatedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
    }, ExtArgs["result"]["monthlythemeimage"]>
    composites: {}
  }

  type monthlythemeimageGetPayload<S extends boolean | null | undefined | monthlythemeimageDefaultArgs> = $Result.GetResult<Prisma.$monthlythemeimagePayload, S>

  type monthlythemeimageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<monthlythemeimageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonthlythemeimageCountAggregateInputType | true
    }

  export interface monthlythemeimageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['monthlythemeimage'], meta: { name: 'monthlythemeimage' } }
    /**
     * Find zero or one Monthlythemeimage that matches the filter.
     * @param {monthlythemeimageFindUniqueArgs} args - Arguments to find a Monthlythemeimage
     * @example
     * // Get one Monthlythemeimage
     * const monthlythemeimage = await prisma.monthlythemeimage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends monthlythemeimageFindUniqueArgs>(args: SelectSubset<T, monthlythemeimageFindUniqueArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monthlythemeimage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {monthlythemeimageFindUniqueOrThrowArgs} args - Arguments to find a Monthlythemeimage
     * @example
     * // Get one Monthlythemeimage
     * const monthlythemeimage = await prisma.monthlythemeimage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends monthlythemeimageFindUniqueOrThrowArgs>(args: SelectSubset<T, monthlythemeimageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monthlythemeimage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthlythemeimageFindFirstArgs} args - Arguments to find a Monthlythemeimage
     * @example
     * // Get one Monthlythemeimage
     * const monthlythemeimage = await prisma.monthlythemeimage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends monthlythemeimageFindFirstArgs>(args?: SelectSubset<T, monthlythemeimageFindFirstArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monthlythemeimage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthlythemeimageFindFirstOrThrowArgs} args - Arguments to find a Monthlythemeimage
     * @example
     * // Get one Monthlythemeimage
     * const monthlythemeimage = await prisma.monthlythemeimage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends monthlythemeimageFindFirstOrThrowArgs>(args?: SelectSubset<T, monthlythemeimageFindFirstOrThrowArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monthlythemeimages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthlythemeimageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monthlythemeimages
     * const monthlythemeimages = await prisma.monthlythemeimage.findMany()
     * 
     * // Get first 10 Monthlythemeimages
     * const monthlythemeimages = await prisma.monthlythemeimage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monthlythemeimageWithIdOnly = await prisma.monthlythemeimage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends monthlythemeimageFindManyArgs>(args?: SelectSubset<T, monthlythemeimageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monthlythemeimage.
     * @param {monthlythemeimageCreateArgs} args - Arguments to create a Monthlythemeimage.
     * @example
     * // Create one Monthlythemeimage
     * const Monthlythemeimage = await prisma.monthlythemeimage.create({
     *   data: {
     *     // ... data to create a Monthlythemeimage
     *   }
     * })
     * 
     */
    create<T extends monthlythemeimageCreateArgs>(args: SelectSubset<T, monthlythemeimageCreateArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monthlythemeimages.
     * @param {monthlythemeimageCreateManyArgs} args - Arguments to create many Monthlythemeimages.
     * @example
     * // Create many Monthlythemeimages
     * const monthlythemeimage = await prisma.monthlythemeimage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends monthlythemeimageCreateManyArgs>(args?: SelectSubset<T, monthlythemeimageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monthlythemeimage.
     * @param {monthlythemeimageDeleteArgs} args - Arguments to delete one Monthlythemeimage.
     * @example
     * // Delete one Monthlythemeimage
     * const Monthlythemeimage = await prisma.monthlythemeimage.delete({
     *   where: {
     *     // ... filter to delete one Monthlythemeimage
     *   }
     * })
     * 
     */
    delete<T extends monthlythemeimageDeleteArgs>(args: SelectSubset<T, monthlythemeimageDeleteArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monthlythemeimage.
     * @param {monthlythemeimageUpdateArgs} args - Arguments to update one Monthlythemeimage.
     * @example
     * // Update one Monthlythemeimage
     * const monthlythemeimage = await prisma.monthlythemeimage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends monthlythemeimageUpdateArgs>(args: SelectSubset<T, monthlythemeimageUpdateArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monthlythemeimages.
     * @param {monthlythemeimageDeleteManyArgs} args - Arguments to filter Monthlythemeimages to delete.
     * @example
     * // Delete a few Monthlythemeimages
     * const { count } = await prisma.monthlythemeimage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends monthlythemeimageDeleteManyArgs>(args?: SelectSubset<T, monthlythemeimageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monthlythemeimages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthlythemeimageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monthlythemeimages
     * const monthlythemeimage = await prisma.monthlythemeimage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends monthlythemeimageUpdateManyArgs>(args: SelectSubset<T, monthlythemeimageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monthlythemeimage.
     * @param {monthlythemeimageUpsertArgs} args - Arguments to update or create a Monthlythemeimage.
     * @example
     * // Update or create a Monthlythemeimage
     * const monthlythemeimage = await prisma.monthlythemeimage.upsert({
     *   create: {
     *     // ... data to create a Monthlythemeimage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monthlythemeimage we want to update
     *   }
     * })
     */
    upsert<T extends monthlythemeimageUpsertArgs>(args: SelectSubset<T, monthlythemeimageUpsertArgs<ExtArgs>>): Prisma__monthlythemeimageClient<$Result.GetResult<Prisma.$monthlythemeimagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Monthlythemeimages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthlythemeimageCountArgs} args - Arguments to filter Monthlythemeimages to count.
     * @example
     * // Count the number of Monthlythemeimages
     * const count = await prisma.monthlythemeimage.count({
     *   where: {
     *     // ... the filter for the Monthlythemeimages we want to count
     *   }
     * })
    **/
    count<T extends monthlythemeimageCountArgs>(
      args?: Subset<T, monthlythemeimageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthlythemeimageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monthlythemeimage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlythemeimageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthlythemeimageAggregateArgs>(args: Subset<T, MonthlythemeimageAggregateArgs>): Prisma.PrismaPromise<GetMonthlythemeimageAggregateType<T>>

    /**
     * Group by Monthlythemeimage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {monthlythemeimageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends monthlythemeimageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: monthlythemeimageGroupByArgs['orderBy'] }
        : { orderBy?: monthlythemeimageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, monthlythemeimageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthlythemeimageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the monthlythemeimage model
   */
  readonly fields: monthlythemeimageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for monthlythemeimage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__monthlythemeimageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the monthlythemeimage model
   */ 
  interface monthlythemeimageFieldRefs {
    readonly id: FieldRef<"monthlythemeimage", 'String'>
    readonly year: FieldRef<"monthlythemeimage", 'Int'>
    readonly month: FieldRef<"monthlythemeimage", 'Int'>
    readonly imageUrls: FieldRef<"monthlythemeimage", 'Json'>
    readonly quoteOrCaption: FieldRef<"monthlythemeimage", 'String'>
    readonly createdAt: FieldRef<"monthlythemeimage", 'DateTime'>
    readonly updatedAt: FieldRef<"monthlythemeimage", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"monthlythemeimage", 'String'>
    readonly postedByOwnerName: FieldRef<"monthlythemeimage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * monthlythemeimage findUnique
   */
  export type monthlythemeimageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * Filter, which monthlythemeimage to fetch.
     */
    where: monthlythemeimageWhereUniqueInput
  }

  /**
   * monthlythemeimage findUniqueOrThrow
   */
  export type monthlythemeimageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * Filter, which monthlythemeimage to fetch.
     */
    where: monthlythemeimageWhereUniqueInput
  }

  /**
   * monthlythemeimage findFirst
   */
  export type monthlythemeimageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * Filter, which monthlythemeimage to fetch.
     */
    where?: monthlythemeimageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthlythemeimages to fetch.
     */
    orderBy?: monthlythemeimageOrderByWithRelationInput | monthlythemeimageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monthlythemeimages.
     */
    cursor?: monthlythemeimageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthlythemeimages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthlythemeimages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monthlythemeimages.
     */
    distinct?: MonthlythemeimageScalarFieldEnum | MonthlythemeimageScalarFieldEnum[]
  }

  /**
   * monthlythemeimage findFirstOrThrow
   */
  export type monthlythemeimageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * Filter, which monthlythemeimage to fetch.
     */
    where?: monthlythemeimageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthlythemeimages to fetch.
     */
    orderBy?: monthlythemeimageOrderByWithRelationInput | monthlythemeimageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for monthlythemeimages.
     */
    cursor?: monthlythemeimageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthlythemeimages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthlythemeimages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of monthlythemeimages.
     */
    distinct?: MonthlythemeimageScalarFieldEnum | MonthlythemeimageScalarFieldEnum[]
  }

  /**
   * monthlythemeimage findMany
   */
  export type monthlythemeimageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * Filter, which monthlythemeimages to fetch.
     */
    where?: monthlythemeimageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of monthlythemeimages to fetch.
     */
    orderBy?: monthlythemeimageOrderByWithRelationInput | monthlythemeimageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing monthlythemeimages.
     */
    cursor?: monthlythemeimageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` monthlythemeimages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` monthlythemeimages.
     */
    skip?: number
    distinct?: MonthlythemeimageScalarFieldEnum | MonthlythemeimageScalarFieldEnum[]
  }

  /**
   * monthlythemeimage create
   */
  export type monthlythemeimageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * The data needed to create a monthlythemeimage.
     */
    data: XOR<monthlythemeimageCreateInput, monthlythemeimageUncheckedCreateInput>
  }

  /**
   * monthlythemeimage createMany
   */
  export type monthlythemeimageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many monthlythemeimages.
     */
    data: monthlythemeimageCreateManyInput | monthlythemeimageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * monthlythemeimage update
   */
  export type monthlythemeimageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * The data needed to update a monthlythemeimage.
     */
    data: XOR<monthlythemeimageUpdateInput, monthlythemeimageUncheckedUpdateInput>
    /**
     * Choose, which monthlythemeimage to update.
     */
    where: monthlythemeimageWhereUniqueInput
  }

  /**
   * monthlythemeimage updateMany
   */
  export type monthlythemeimageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update monthlythemeimages.
     */
    data: XOR<monthlythemeimageUpdateManyMutationInput, monthlythemeimageUncheckedUpdateManyInput>
    /**
     * Filter which monthlythemeimages to update
     */
    where?: monthlythemeimageWhereInput
  }

  /**
   * monthlythemeimage upsert
   */
  export type monthlythemeimageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * The filter to search for the monthlythemeimage to update in case it exists.
     */
    where: monthlythemeimageWhereUniqueInput
    /**
     * In case the monthlythemeimage found by the `where` argument doesn't exist, create a new monthlythemeimage with this data.
     */
    create: XOR<monthlythemeimageCreateInput, monthlythemeimageUncheckedCreateInput>
    /**
     * In case the monthlythemeimage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<monthlythemeimageUpdateInput, monthlythemeimageUncheckedUpdateInput>
  }

  /**
   * monthlythemeimage delete
   */
  export type monthlythemeimageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
    /**
     * Filter which monthlythemeimage to delete.
     */
    where: monthlythemeimageWhereUniqueInput
  }

  /**
   * monthlythemeimage deleteMany
   */
  export type monthlythemeimageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which monthlythemeimages to delete
     */
    where?: monthlythemeimageWhereInput
  }

  /**
   * monthlythemeimage without action
   */
  export type monthlythemeimageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the monthlythemeimage
     */
    select?: monthlythemeimageSelect<ExtArgs> | null
  }


  /**
   * Model newsitem
   */

  export type AggregateNewsitem = {
    _count: NewsitemCountAggregateOutputType | null
    _avg: NewsitemAvgAggregateOutputType | null
    _sum: NewsitemSumAggregateOutputType | null
    _min: NewsitemMinAggregateOutputType | null
    _max: NewsitemMaxAggregateOutputType | null
  }

  export type NewsitemAvgAggregateOutputType = {
    likes: number | null
  }

  export type NewsitemSumAggregateOutputType = {
    likes: number | null
  }

  export type NewsitemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.newsitem_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    videoUrl: string | null
    audioUrl: string | null
    likes: number | null
  }

  export type NewsitemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.newsitem_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    videoUrl: string | null
    audioUrl: string | null
    likes: number | null
  }

  export type NewsitemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    linkPath: number
    category: number
    date: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    videoUrl: number
    audioUrl: number
    likes: number
    _all: number
  }


  export type NewsitemAvgAggregateInputType = {
    likes?: true
  }

  export type NewsitemSumAggregateInputType = {
    likes?: true
  }

  export type NewsitemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    videoUrl?: true
    audioUrl?: true
    likes?: true
  }

  export type NewsitemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    videoUrl?: true
    audioUrl?: true
    likes?: true
  }

  export type NewsitemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    videoUrl?: true
    audioUrl?: true
    likes?: true
    _all?: true
  }

  export type NewsitemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsitem to aggregate.
     */
    where?: newsitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsitems to fetch.
     */
    orderBy?: newsitemOrderByWithRelationInput | newsitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned newsitems
    **/
    _count?: true | NewsitemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsitemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsitemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsitemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsitemMaxAggregateInputType
  }

  export type GetNewsitemAggregateType<T extends NewsitemAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsitem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsitem[P]>
      : GetScalarType<T[P], AggregateNewsitem[P]>
  }




  export type newsitemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: newsitemWhereInput
    orderBy?: newsitemOrderByWithAggregationInput | newsitemOrderByWithAggregationInput[]
    by: NewsitemScalarFieldEnum[] | NewsitemScalarFieldEnum
    having?: newsitemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsitemCountAggregateInputType | true
    _avg?: NewsitemAvgAggregateInputType
    _sum?: NewsitemSumAggregateInputType
    _min?: NewsitemMinAggregateInputType
    _max?: NewsitemMaxAggregateInputType
  }

  export type NewsitemGroupByOutputType = {
    id: string
    title: string
    description: string
    imageUrl: string | null
    linkPath: string
    category: $Enums.newsitem_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    videoUrl: string | null
    audioUrl: string | null
    likes: number
    _count: NewsitemCountAggregateOutputType | null
    _avg: NewsitemAvgAggregateOutputType | null
    _sum: NewsitemSumAggregateOutputType | null
    _min: NewsitemMinAggregateOutputType | null
    _max: NewsitemMaxAggregateOutputType | null
  }

  type GetNewsitemGroupByPayload<T extends newsitemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsitemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsitemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsitemGroupByOutputType[P]>
            : GetScalarType<T[P], NewsitemGroupByOutputType[P]>
        }
      >
    >


  export type newsitemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    likes?: boolean
    comment?: boolean | newsitem$commentArgs<ExtArgs>
    _count?: boolean | NewsitemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["newsitem"]>


  export type newsitemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    likes?: boolean
  }

  export type newsitemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | newsitem$commentArgs<ExtArgs>
    _count?: boolean | NewsitemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $newsitemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "newsitem"
    objects: {
      comment: Prisma.$commentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      imageUrl: string | null
      linkPath: string
      category: $Enums.newsitem_category | null
      date: Date | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      videoUrl: string | null
      audioUrl: string | null
      likes: number
    }, ExtArgs["result"]["newsitem"]>
    composites: {}
  }

  type newsitemGetPayload<S extends boolean | null | undefined | newsitemDefaultArgs> = $Result.GetResult<Prisma.$newsitemPayload, S>

  type newsitemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<newsitemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NewsitemCountAggregateInputType | true
    }

  export interface newsitemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['newsitem'], meta: { name: 'newsitem' } }
    /**
     * Find zero or one Newsitem that matches the filter.
     * @param {newsitemFindUniqueArgs} args - Arguments to find a Newsitem
     * @example
     * // Get one Newsitem
     * const newsitem = await prisma.newsitem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends newsitemFindUniqueArgs>(args: SelectSubset<T, newsitemFindUniqueArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Newsitem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {newsitemFindUniqueOrThrowArgs} args - Arguments to find a Newsitem
     * @example
     * // Get one Newsitem
     * const newsitem = await prisma.newsitem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends newsitemFindUniqueOrThrowArgs>(args: SelectSubset<T, newsitemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Newsitem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsitemFindFirstArgs} args - Arguments to find a Newsitem
     * @example
     * // Get one Newsitem
     * const newsitem = await prisma.newsitem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends newsitemFindFirstArgs>(args?: SelectSubset<T, newsitemFindFirstArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Newsitem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsitemFindFirstOrThrowArgs} args - Arguments to find a Newsitem
     * @example
     * // Get one Newsitem
     * const newsitem = await prisma.newsitem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends newsitemFindFirstOrThrowArgs>(args?: SelectSubset<T, newsitemFindFirstOrThrowArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Newsitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsitemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Newsitems
     * const newsitems = await prisma.newsitem.findMany()
     * 
     * // Get first 10 Newsitems
     * const newsitems = await prisma.newsitem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsitemWithIdOnly = await prisma.newsitem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends newsitemFindManyArgs>(args?: SelectSubset<T, newsitemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Newsitem.
     * @param {newsitemCreateArgs} args - Arguments to create a Newsitem.
     * @example
     * // Create one Newsitem
     * const Newsitem = await prisma.newsitem.create({
     *   data: {
     *     // ... data to create a Newsitem
     *   }
     * })
     * 
     */
    create<T extends newsitemCreateArgs>(args: SelectSubset<T, newsitemCreateArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Newsitems.
     * @param {newsitemCreateManyArgs} args - Arguments to create many Newsitems.
     * @example
     * // Create many Newsitems
     * const newsitem = await prisma.newsitem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends newsitemCreateManyArgs>(args?: SelectSubset<T, newsitemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Newsitem.
     * @param {newsitemDeleteArgs} args - Arguments to delete one Newsitem.
     * @example
     * // Delete one Newsitem
     * const Newsitem = await prisma.newsitem.delete({
     *   where: {
     *     // ... filter to delete one Newsitem
     *   }
     * })
     * 
     */
    delete<T extends newsitemDeleteArgs>(args: SelectSubset<T, newsitemDeleteArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Newsitem.
     * @param {newsitemUpdateArgs} args - Arguments to update one Newsitem.
     * @example
     * // Update one Newsitem
     * const newsitem = await prisma.newsitem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends newsitemUpdateArgs>(args: SelectSubset<T, newsitemUpdateArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Newsitems.
     * @param {newsitemDeleteManyArgs} args - Arguments to filter Newsitems to delete.
     * @example
     * // Delete a few Newsitems
     * const { count } = await prisma.newsitem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends newsitemDeleteManyArgs>(args?: SelectSubset<T, newsitemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Newsitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsitemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Newsitems
     * const newsitem = await prisma.newsitem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends newsitemUpdateManyArgs>(args: SelectSubset<T, newsitemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Newsitem.
     * @param {newsitemUpsertArgs} args - Arguments to update or create a Newsitem.
     * @example
     * // Update or create a Newsitem
     * const newsitem = await prisma.newsitem.upsert({
     *   create: {
     *     // ... data to create a Newsitem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Newsitem we want to update
     *   }
     * })
     */
    upsert<T extends newsitemUpsertArgs>(args: SelectSubset<T, newsitemUpsertArgs<ExtArgs>>): Prisma__newsitemClient<$Result.GetResult<Prisma.$newsitemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Newsitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsitemCountArgs} args - Arguments to filter Newsitems to count.
     * @example
     * // Count the number of Newsitems
     * const count = await prisma.newsitem.count({
     *   where: {
     *     // ... the filter for the Newsitems we want to count
     *   }
     * })
    **/
    count<T extends newsitemCountArgs>(
      args?: Subset<T, newsitemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsitemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Newsitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsitemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsitemAggregateArgs>(args: Subset<T, NewsitemAggregateArgs>): Prisma.PrismaPromise<GetNewsitemAggregateType<T>>

    /**
     * Group by Newsitem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsitemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsitemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsitemGroupByArgs['orderBy'] }
        : { orderBy?: newsitemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsitemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsitemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the newsitem model
   */
  readonly fields: newsitemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for newsitem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__newsitemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends newsitem$commentArgs<ExtArgs> = {}>(args?: Subset<T, newsitem$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the newsitem model
   */ 
  interface newsitemFieldRefs {
    readonly id: FieldRef<"newsitem", 'String'>
    readonly title: FieldRef<"newsitem", 'String'>
    readonly description: FieldRef<"newsitem", 'String'>
    readonly imageUrl: FieldRef<"newsitem", 'String'>
    readonly linkPath: FieldRef<"newsitem", 'String'>
    readonly category: FieldRef<"newsitem", 'newsitem_category'>
    readonly date: FieldRef<"newsitem", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"newsitem", 'String'>
    readonly postedByOwnerName: FieldRef<"newsitem", 'String'>
    readonly createdAt: FieldRef<"newsitem", 'DateTime'>
    readonly updatedAt: FieldRef<"newsitem", 'DateTime'>
    readonly videoUrl: FieldRef<"newsitem", 'String'>
    readonly audioUrl: FieldRef<"newsitem", 'String'>
    readonly likes: FieldRef<"newsitem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * newsitem findUnique
   */
  export type newsitemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * Filter, which newsitem to fetch.
     */
    where: newsitemWhereUniqueInput
  }

  /**
   * newsitem findUniqueOrThrow
   */
  export type newsitemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * Filter, which newsitem to fetch.
     */
    where: newsitemWhereUniqueInput
  }

  /**
   * newsitem findFirst
   */
  export type newsitemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * Filter, which newsitem to fetch.
     */
    where?: newsitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsitems to fetch.
     */
    orderBy?: newsitemOrderByWithRelationInput | newsitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsitems.
     */
    cursor?: newsitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsitems.
     */
    distinct?: NewsitemScalarFieldEnum | NewsitemScalarFieldEnum[]
  }

  /**
   * newsitem findFirstOrThrow
   */
  export type newsitemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * Filter, which newsitem to fetch.
     */
    where?: newsitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsitems to fetch.
     */
    orderBy?: newsitemOrderByWithRelationInput | newsitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for newsitems.
     */
    cursor?: newsitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of newsitems.
     */
    distinct?: NewsitemScalarFieldEnum | NewsitemScalarFieldEnum[]
  }

  /**
   * newsitem findMany
   */
  export type newsitemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * Filter, which newsitems to fetch.
     */
    where?: newsitemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of newsitems to fetch.
     */
    orderBy?: newsitemOrderByWithRelationInput | newsitemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing newsitems.
     */
    cursor?: newsitemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` newsitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` newsitems.
     */
    skip?: number
    distinct?: NewsitemScalarFieldEnum | NewsitemScalarFieldEnum[]
  }

  /**
   * newsitem create
   */
  export type newsitemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * The data needed to create a newsitem.
     */
    data: XOR<newsitemCreateInput, newsitemUncheckedCreateInput>
  }

  /**
   * newsitem createMany
   */
  export type newsitemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many newsitems.
     */
    data: newsitemCreateManyInput | newsitemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * newsitem update
   */
  export type newsitemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * The data needed to update a newsitem.
     */
    data: XOR<newsitemUpdateInput, newsitemUncheckedUpdateInput>
    /**
     * Choose, which newsitem to update.
     */
    where: newsitemWhereUniqueInput
  }

  /**
   * newsitem updateMany
   */
  export type newsitemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update newsitems.
     */
    data: XOR<newsitemUpdateManyMutationInput, newsitemUncheckedUpdateManyInput>
    /**
     * Filter which newsitems to update
     */
    where?: newsitemWhereInput
  }

  /**
   * newsitem upsert
   */
  export type newsitemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * The filter to search for the newsitem to update in case it exists.
     */
    where: newsitemWhereUniqueInput
    /**
     * In case the newsitem found by the `where` argument doesn't exist, create a new newsitem with this data.
     */
    create: XOR<newsitemCreateInput, newsitemUncheckedCreateInput>
    /**
     * In case the newsitem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsitemUpdateInput, newsitemUncheckedUpdateInput>
  }

  /**
   * newsitem delete
   */
  export type newsitemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
    /**
     * Filter which newsitem to delete.
     */
    where: newsitemWhereUniqueInput
  }

  /**
   * newsitem deleteMany
   */
  export type newsitemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which newsitems to delete
     */
    where?: newsitemWhereInput
  }

  /**
   * newsitem.comment
   */
  export type newsitem$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * newsitem without action
   */
  export type newsitemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the newsitem
     */
    select?: newsitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: newsitemInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    targetUserId: string | null
    message: string | null
    link: string | null
    timestamp: Date | null
    read: boolean | null
    type: $Enums.notification_type | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    targetUserId: string | null
    message: string | null
    link: string | null
    timestamp: Date | null
    read: boolean | null
    type: $Enums.notification_type | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    targetUserId: number
    message: number
    link: number
    timestamp: number
    read: number
    type: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    targetUserId?: true
    message?: true
    link?: true
    timestamp?: true
    read?: true
    type?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    targetUserId?: true
    message?: true
    link?: true
    timestamp?: true
    read?: true
    type?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    targetUserId?: true
    message?: true
    link?: true
    timestamp?: true
    read?: true
    type?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    targetUserId: string
    message: string
    link: string | null
    timestamp: Date
    read: boolean
    type: $Enums.notification_type
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetUserId?: boolean
    message?: boolean
    link?: boolean
    timestamp?: boolean
    read?: boolean
    type?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type notificationSelectScalar = {
    id?: boolean
    targetUserId?: boolean
    message?: boolean
    link?: boolean
    timestamp?: boolean
    read?: boolean
    type?: boolean
  }

  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetUserId: string
      message: string
      link: string | null
      timestamp: Date
      read: boolean
      type: $Enums.notification_type
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */ 
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'String'>
    readonly targetUserId: FieldRef<"notification", 'String'>
    readonly message: FieldRef<"notification", 'String'>
    readonly link: FieldRef<"notification", 'String'>
    readonly timestamp: FieldRef<"notification", 'DateTime'>
    readonly read: FieldRef<"notification", 'Boolean'>
    readonly type: FieldRef<"notification", 'notification_type'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model prayer
   */

  export type AggregatePrayer = {
    _count: PrayerCountAggregateOutputType | null
    _min: PrayerMinAggregateOutputType | null
    _max: PrayerMaxAggregateOutputType | null
  }

  export type PrayerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    timestamp: Date | null
    prayerRequestId: string | null
  }

  export type PrayerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    timestamp: Date | null
    prayerRequestId: string | null
  }

  export type PrayerCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    timestamp: number
    prayerRequestId: number
    _all: number
  }


  export type PrayerMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    timestamp?: true
    prayerRequestId?: true
  }

  export type PrayerMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    timestamp?: true
    prayerRequestId?: true
  }

  export type PrayerCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    timestamp?: true
    prayerRequestId?: true
    _all?: true
  }

  export type PrayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prayer to aggregate.
     */
    where?: prayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayers to fetch.
     */
    orderBy?: prayerOrderByWithRelationInput | prayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prayers
    **/
    _count?: true | PrayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrayerMaxAggregateInputType
  }

  export type GetPrayerAggregateType<T extends PrayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePrayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrayer[P]>
      : GetScalarType<T[P], AggregatePrayer[P]>
  }




  export type prayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prayerWhereInput
    orderBy?: prayerOrderByWithAggregationInput | prayerOrderByWithAggregationInput[]
    by: PrayerScalarFieldEnum[] | PrayerScalarFieldEnum
    having?: prayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrayerCountAggregateInputType | true
    _min?: PrayerMinAggregateInputType
    _max?: PrayerMaxAggregateInputType
  }

  export type PrayerGroupByOutputType = {
    id: string
    userId: string
    userName: string
    timestamp: Date
    prayerRequestId: string
    _count: PrayerCountAggregateOutputType | null
    _min: PrayerMinAggregateOutputType | null
    _max: PrayerMaxAggregateOutputType | null
  }

  type GetPrayerGroupByPayload<T extends prayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrayerGroupByOutputType[P]>
            : GetScalarType<T[P], PrayerGroupByOutputType[P]>
        }
      >
    >


  export type prayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    timestamp?: boolean
    prayerRequestId?: boolean
    prayerrequest?: boolean | prayerrequestDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prayer"]>


  export type prayerSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    timestamp?: boolean
    prayerRequestId?: boolean
  }

  export type prayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prayerrequest?: boolean | prayerrequestDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $prayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prayer"
    objects: {
      prayerrequest: Prisma.$prayerrequestPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string
      timestamp: Date
      prayerRequestId: string
    }, ExtArgs["result"]["prayer"]>
    composites: {}
  }

  type prayerGetPayload<S extends boolean | null | undefined | prayerDefaultArgs> = $Result.GetResult<Prisma.$prayerPayload, S>

  type prayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrayerCountAggregateInputType | true
    }

  export interface prayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prayer'], meta: { name: 'prayer' } }
    /**
     * Find zero or one Prayer that matches the filter.
     * @param {prayerFindUniqueArgs} args - Arguments to find a Prayer
     * @example
     * // Get one Prayer
     * const prayer = await prisma.prayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prayerFindUniqueArgs>(args: SelectSubset<T, prayerFindUniqueArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prayer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prayerFindUniqueOrThrowArgs} args - Arguments to find a Prayer
     * @example
     * // Get one Prayer
     * const prayer = await prisma.prayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prayerFindUniqueOrThrowArgs>(args: SelectSubset<T, prayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerFindFirstArgs} args - Arguments to find a Prayer
     * @example
     * // Get one Prayer
     * const prayer = await prisma.prayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prayerFindFirstArgs>(args?: SelectSubset<T, prayerFindFirstArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerFindFirstOrThrowArgs} args - Arguments to find a Prayer
     * @example
     * // Get one Prayer
     * const prayer = await prisma.prayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prayerFindFirstOrThrowArgs>(args?: SelectSubset<T, prayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prayers
     * const prayers = await prisma.prayer.findMany()
     * 
     * // Get first 10 Prayers
     * const prayers = await prisma.prayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prayerWithIdOnly = await prisma.prayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prayerFindManyArgs>(args?: SelectSubset<T, prayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prayer.
     * @param {prayerCreateArgs} args - Arguments to create a Prayer.
     * @example
     * // Create one Prayer
     * const Prayer = await prisma.prayer.create({
     *   data: {
     *     // ... data to create a Prayer
     *   }
     * })
     * 
     */
    create<T extends prayerCreateArgs>(args: SelectSubset<T, prayerCreateArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prayers.
     * @param {prayerCreateManyArgs} args - Arguments to create many Prayers.
     * @example
     * // Create many Prayers
     * const prayer = await prisma.prayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prayerCreateManyArgs>(args?: SelectSubset<T, prayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prayer.
     * @param {prayerDeleteArgs} args - Arguments to delete one Prayer.
     * @example
     * // Delete one Prayer
     * const Prayer = await prisma.prayer.delete({
     *   where: {
     *     // ... filter to delete one Prayer
     *   }
     * })
     * 
     */
    delete<T extends prayerDeleteArgs>(args: SelectSubset<T, prayerDeleteArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prayer.
     * @param {prayerUpdateArgs} args - Arguments to update one Prayer.
     * @example
     * // Update one Prayer
     * const prayer = await prisma.prayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prayerUpdateArgs>(args: SelectSubset<T, prayerUpdateArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prayers.
     * @param {prayerDeleteManyArgs} args - Arguments to filter Prayers to delete.
     * @example
     * // Delete a few Prayers
     * const { count } = await prisma.prayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prayerDeleteManyArgs>(args?: SelectSubset<T, prayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prayers
     * const prayer = await prisma.prayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prayerUpdateManyArgs>(args: SelectSubset<T, prayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prayer.
     * @param {prayerUpsertArgs} args - Arguments to update or create a Prayer.
     * @example
     * // Update or create a Prayer
     * const prayer = await prisma.prayer.upsert({
     *   create: {
     *     // ... data to create a Prayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prayer we want to update
     *   }
     * })
     */
    upsert<T extends prayerUpsertArgs>(args: SelectSubset<T, prayerUpsertArgs<ExtArgs>>): Prisma__prayerClient<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerCountArgs} args - Arguments to filter Prayers to count.
     * @example
     * // Count the number of Prayers
     * const count = await prisma.prayer.count({
     *   where: {
     *     // ... the filter for the Prayers we want to count
     *   }
     * })
    **/
    count<T extends prayerCountArgs>(
      args?: Subset<T, prayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrayerAggregateArgs>(args: Subset<T, PrayerAggregateArgs>): Prisma.PrismaPromise<GetPrayerAggregateType<T>>

    /**
     * Group by Prayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prayerGroupByArgs['orderBy'] }
        : { orderBy?: prayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prayer model
   */
  readonly fields: prayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prayerrequest<T extends prayerrequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, prayerrequestDefaultArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prayer model
   */ 
  interface prayerFieldRefs {
    readonly id: FieldRef<"prayer", 'String'>
    readonly userId: FieldRef<"prayer", 'String'>
    readonly userName: FieldRef<"prayer", 'String'>
    readonly timestamp: FieldRef<"prayer", 'DateTime'>
    readonly prayerRequestId: FieldRef<"prayer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * prayer findUnique
   */
  export type prayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * Filter, which prayer to fetch.
     */
    where: prayerWhereUniqueInput
  }

  /**
   * prayer findUniqueOrThrow
   */
  export type prayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * Filter, which prayer to fetch.
     */
    where: prayerWhereUniqueInput
  }

  /**
   * prayer findFirst
   */
  export type prayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * Filter, which prayer to fetch.
     */
    where?: prayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayers to fetch.
     */
    orderBy?: prayerOrderByWithRelationInput | prayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prayers.
     */
    cursor?: prayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prayers.
     */
    distinct?: PrayerScalarFieldEnum | PrayerScalarFieldEnum[]
  }

  /**
   * prayer findFirstOrThrow
   */
  export type prayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * Filter, which prayer to fetch.
     */
    where?: prayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayers to fetch.
     */
    orderBy?: prayerOrderByWithRelationInput | prayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prayers.
     */
    cursor?: prayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prayers.
     */
    distinct?: PrayerScalarFieldEnum | PrayerScalarFieldEnum[]
  }

  /**
   * prayer findMany
   */
  export type prayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * Filter, which prayers to fetch.
     */
    where?: prayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayers to fetch.
     */
    orderBy?: prayerOrderByWithRelationInput | prayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prayers.
     */
    cursor?: prayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayers.
     */
    skip?: number
    distinct?: PrayerScalarFieldEnum | PrayerScalarFieldEnum[]
  }

  /**
   * prayer create
   */
  export type prayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * The data needed to create a prayer.
     */
    data: XOR<prayerCreateInput, prayerUncheckedCreateInput>
  }

  /**
   * prayer createMany
   */
  export type prayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prayers.
     */
    data: prayerCreateManyInput | prayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prayer update
   */
  export type prayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * The data needed to update a prayer.
     */
    data: XOR<prayerUpdateInput, prayerUncheckedUpdateInput>
    /**
     * Choose, which prayer to update.
     */
    where: prayerWhereUniqueInput
  }

  /**
   * prayer updateMany
   */
  export type prayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prayers.
     */
    data: XOR<prayerUpdateManyMutationInput, prayerUncheckedUpdateManyInput>
    /**
     * Filter which prayers to update
     */
    where?: prayerWhereInput
  }

  /**
   * prayer upsert
   */
  export type prayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * The filter to search for the prayer to update in case it exists.
     */
    where: prayerWhereUniqueInput
    /**
     * In case the prayer found by the `where` argument doesn't exist, create a new prayer with this data.
     */
    create: XOR<prayerCreateInput, prayerUncheckedCreateInput>
    /**
     * In case the prayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prayerUpdateInput, prayerUncheckedUpdateInput>
  }

  /**
   * prayer delete
   */
  export type prayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    /**
     * Filter which prayer to delete.
     */
    where: prayerWhereUniqueInput
  }

  /**
   * prayer deleteMany
   */
  export type prayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prayers to delete
     */
    where?: prayerWhereInput
  }

  /**
   * prayer without action
   */
  export type prayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
  }


  /**
   * Model prayerrequest
   */

  export type AggregatePrayerrequest = {
    _count: PrayerrequestCountAggregateOutputType | null
    _min: PrayerrequestMinAggregateOutputType | null
    _max: PrayerrequestMaxAggregateOutputType | null
  }

  export type PrayerrequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userProfileImageUrl: string | null
    title: string | null
    requestText: string | null
    visibility: $Enums.prayerrequest_visibility | null
    category: $Enums.prayerrequest_category | null
    status: $Enums.prayerrequest_status | null
    submittedAt: Date | null
    lastPrayedAt: Date | null
    adminNotes: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
  }

  export type PrayerrequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userProfileImageUrl: string | null
    title: string | null
    requestText: string | null
    visibility: $Enums.prayerrequest_visibility | null
    category: $Enums.prayerrequest_category | null
    status: $Enums.prayerrequest_status | null
    submittedAt: Date | null
    lastPrayedAt: Date | null
    adminNotes: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
  }

  export type PrayerrequestCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    userProfileImageUrl: number
    title: number
    requestText: number
    visibility: number
    category: number
    status: number
    submittedAt: number
    lastPrayedAt: number
    adminNotes: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    mediaUrls: number
    location: number
    taggedFriends: number
    feelingActivity: number
    backgroundTheme: number
    _all: number
  }


  export type PrayerrequestMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    title?: true
    requestText?: true
    visibility?: true
    category?: true
    status?: true
    submittedAt?: true
    lastPrayedAt?: true
    adminNotes?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
  }

  export type PrayerrequestMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    title?: true
    requestText?: true
    visibility?: true
    category?: true
    status?: true
    submittedAt?: true
    lastPrayedAt?: true
    adminNotes?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
  }

  export type PrayerrequestCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    title?: true
    requestText?: true
    visibility?: true
    category?: true
    status?: true
    submittedAt?: true
    lastPrayedAt?: true
    adminNotes?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    mediaUrls?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
    _all?: true
  }

  export type PrayerrequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prayerrequest to aggregate.
     */
    where?: prayerrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayerrequests to fetch.
     */
    orderBy?: prayerrequestOrderByWithRelationInput | prayerrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prayerrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayerrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayerrequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prayerrequests
    **/
    _count?: true | PrayerrequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrayerrequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrayerrequestMaxAggregateInputType
  }

  export type GetPrayerrequestAggregateType<T extends PrayerrequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePrayerrequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrayerrequest[P]>
      : GetScalarType<T[P], AggregatePrayerrequest[P]>
  }




  export type prayerrequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prayerrequestWhereInput
    orderBy?: prayerrequestOrderByWithAggregationInput | prayerrequestOrderByWithAggregationInput[]
    by: PrayerrequestScalarFieldEnum[] | PrayerrequestScalarFieldEnum
    having?: prayerrequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrayerrequestCountAggregateInputType | true
    _min?: PrayerrequestMinAggregateInputType
    _max?: PrayerrequestMaxAggregateInputType
  }

  export type PrayerrequestGroupByOutputType = {
    id: string
    userId: string | null
    userName: string | null
    userProfileImageUrl: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category: $Enums.prayerrequest_category | null
    status: $Enums.prayerrequest_status
    submittedAt: Date
    lastPrayedAt: Date | null
    adminNotes: string | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    mediaUrls: JsonValue | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
    _count: PrayerrequestCountAggregateOutputType | null
    _min: PrayerrequestMinAggregateOutputType | null
    _max: PrayerrequestMaxAggregateOutputType | null
  }

  type GetPrayerrequestGroupByPayload<T extends prayerrequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrayerrequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrayerrequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrayerrequestGroupByOutputType[P]>
            : GetScalarType<T[P], PrayerrequestGroupByOutputType[P]>
        }
      >
    >


  export type prayerrequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userProfileImageUrl?: boolean
    title?: boolean
    requestText?: boolean
    visibility?: boolean
    category?: boolean
    status?: boolean
    submittedAt?: boolean
    lastPrayedAt?: boolean
    adminNotes?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaUrls?: boolean
    location?: boolean
    taggedFriends?: boolean
    feelingActivity?: boolean
    backgroundTheme?: boolean
    comment?: boolean | prayerrequest$commentArgs<ExtArgs>
    prayer?: boolean | prayerrequest$prayerArgs<ExtArgs>
    user?: boolean | prayerrequest$userArgs<ExtArgs>
    _count?: boolean | PrayerrequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prayerrequest"]>


  export type prayerrequestSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    userProfileImageUrl?: boolean
    title?: boolean
    requestText?: boolean
    visibility?: boolean
    category?: boolean
    status?: boolean
    submittedAt?: boolean
    lastPrayedAt?: boolean
    adminNotes?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaUrls?: boolean
    location?: boolean
    taggedFriends?: boolean
    feelingActivity?: boolean
    backgroundTheme?: boolean
  }

  export type prayerrequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | prayerrequest$commentArgs<ExtArgs>
    prayer?: boolean | prayerrequest$prayerArgs<ExtArgs>
    user?: boolean | prayerrequest$userArgs<ExtArgs>
    _count?: boolean | PrayerrequestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $prayerrequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prayerrequest"
    objects: {
      comment: Prisma.$commentPayload<ExtArgs>[]
      prayer: Prisma.$prayerPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      userName: string | null
      userProfileImageUrl: string | null
      title: string
      requestText: string
      visibility: $Enums.prayerrequest_visibility
      category: $Enums.prayerrequest_category | null
      status: $Enums.prayerrequest_status
      submittedAt: Date
      lastPrayedAt: Date | null
      adminNotes: string | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      mediaUrls: Prisma.JsonValue | null
      location: string | null
      taggedFriends: string | null
      feelingActivity: string | null
      backgroundTheme: string | null
    }, ExtArgs["result"]["prayerrequest"]>
    composites: {}
  }

  type prayerrequestGetPayload<S extends boolean | null | undefined | prayerrequestDefaultArgs> = $Result.GetResult<Prisma.$prayerrequestPayload, S>

  type prayerrequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<prayerrequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrayerrequestCountAggregateInputType | true
    }

  export interface prayerrequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prayerrequest'], meta: { name: 'prayerrequest' } }
    /**
     * Find zero or one Prayerrequest that matches the filter.
     * @param {prayerrequestFindUniqueArgs} args - Arguments to find a Prayerrequest
     * @example
     * // Get one Prayerrequest
     * const prayerrequest = await prisma.prayerrequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prayerrequestFindUniqueArgs>(args: SelectSubset<T, prayerrequestFindUniqueArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prayerrequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {prayerrequestFindUniqueOrThrowArgs} args - Arguments to find a Prayerrequest
     * @example
     * // Get one Prayerrequest
     * const prayerrequest = await prisma.prayerrequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prayerrequestFindUniqueOrThrowArgs>(args: SelectSubset<T, prayerrequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prayerrequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerrequestFindFirstArgs} args - Arguments to find a Prayerrequest
     * @example
     * // Get one Prayerrequest
     * const prayerrequest = await prisma.prayerrequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prayerrequestFindFirstArgs>(args?: SelectSubset<T, prayerrequestFindFirstArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prayerrequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerrequestFindFirstOrThrowArgs} args - Arguments to find a Prayerrequest
     * @example
     * // Get one Prayerrequest
     * const prayerrequest = await prisma.prayerrequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prayerrequestFindFirstOrThrowArgs>(args?: SelectSubset<T, prayerrequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prayerrequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerrequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prayerrequests
     * const prayerrequests = await prisma.prayerrequest.findMany()
     * 
     * // Get first 10 Prayerrequests
     * const prayerrequests = await prisma.prayerrequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prayerrequestWithIdOnly = await prisma.prayerrequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends prayerrequestFindManyArgs>(args?: SelectSubset<T, prayerrequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prayerrequest.
     * @param {prayerrequestCreateArgs} args - Arguments to create a Prayerrequest.
     * @example
     * // Create one Prayerrequest
     * const Prayerrequest = await prisma.prayerrequest.create({
     *   data: {
     *     // ... data to create a Prayerrequest
     *   }
     * })
     * 
     */
    create<T extends prayerrequestCreateArgs>(args: SelectSubset<T, prayerrequestCreateArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prayerrequests.
     * @param {prayerrequestCreateManyArgs} args - Arguments to create many Prayerrequests.
     * @example
     * // Create many Prayerrequests
     * const prayerrequest = await prisma.prayerrequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prayerrequestCreateManyArgs>(args?: SelectSubset<T, prayerrequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Prayerrequest.
     * @param {prayerrequestDeleteArgs} args - Arguments to delete one Prayerrequest.
     * @example
     * // Delete one Prayerrequest
     * const Prayerrequest = await prisma.prayerrequest.delete({
     *   where: {
     *     // ... filter to delete one Prayerrequest
     *   }
     * })
     * 
     */
    delete<T extends prayerrequestDeleteArgs>(args: SelectSubset<T, prayerrequestDeleteArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prayerrequest.
     * @param {prayerrequestUpdateArgs} args - Arguments to update one Prayerrequest.
     * @example
     * // Update one Prayerrequest
     * const prayerrequest = await prisma.prayerrequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prayerrequestUpdateArgs>(args: SelectSubset<T, prayerrequestUpdateArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prayerrequests.
     * @param {prayerrequestDeleteManyArgs} args - Arguments to filter Prayerrequests to delete.
     * @example
     * // Delete a few Prayerrequests
     * const { count } = await prisma.prayerrequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prayerrequestDeleteManyArgs>(args?: SelectSubset<T, prayerrequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prayerrequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerrequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prayerrequests
     * const prayerrequest = await prisma.prayerrequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prayerrequestUpdateManyArgs>(args: SelectSubset<T, prayerrequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prayerrequest.
     * @param {prayerrequestUpsertArgs} args - Arguments to update or create a Prayerrequest.
     * @example
     * // Update or create a Prayerrequest
     * const prayerrequest = await prisma.prayerrequest.upsert({
     *   create: {
     *     // ... data to create a Prayerrequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prayerrequest we want to update
     *   }
     * })
     */
    upsert<T extends prayerrequestUpsertArgs>(args: SelectSubset<T, prayerrequestUpsertArgs<ExtArgs>>): Prisma__prayerrequestClient<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prayerrequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerrequestCountArgs} args - Arguments to filter Prayerrequests to count.
     * @example
     * // Count the number of Prayerrequests
     * const count = await prisma.prayerrequest.count({
     *   where: {
     *     // ... the filter for the Prayerrequests we want to count
     *   }
     * })
    **/
    count<T extends prayerrequestCountArgs>(
      args?: Subset<T, prayerrequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrayerrequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prayerrequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrayerrequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrayerrequestAggregateArgs>(args: Subset<T, PrayerrequestAggregateArgs>): Prisma.PrismaPromise<GetPrayerrequestAggregateType<T>>

    /**
     * Group by Prayerrequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prayerrequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prayerrequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prayerrequestGroupByArgs['orderBy'] }
        : { orderBy?: prayerrequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prayerrequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrayerrequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prayerrequest model
   */
  readonly fields: prayerrequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prayerrequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prayerrequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends prayerrequest$commentArgs<ExtArgs> = {}>(args?: Subset<T, prayerrequest$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany"> | Null>
    prayer<T extends prayerrequest$prayerArgs<ExtArgs> = {}>(args?: Subset<T, prayerrequest$prayerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends prayerrequest$userArgs<ExtArgs> = {}>(args?: Subset<T, prayerrequest$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prayerrequest model
   */ 
  interface prayerrequestFieldRefs {
    readonly id: FieldRef<"prayerrequest", 'String'>
    readonly userId: FieldRef<"prayerrequest", 'String'>
    readonly userName: FieldRef<"prayerrequest", 'String'>
    readonly userProfileImageUrl: FieldRef<"prayerrequest", 'String'>
    readonly title: FieldRef<"prayerrequest", 'String'>
    readonly requestText: FieldRef<"prayerrequest", 'String'>
    readonly visibility: FieldRef<"prayerrequest", 'prayerrequest_visibility'>
    readonly category: FieldRef<"prayerrequest", 'prayerrequest_category'>
    readonly status: FieldRef<"prayerrequest", 'prayerrequest_status'>
    readonly submittedAt: FieldRef<"prayerrequest", 'DateTime'>
    readonly lastPrayedAt: FieldRef<"prayerrequest", 'DateTime'>
    readonly adminNotes: FieldRef<"prayerrequest", 'String'>
    readonly postedByOwnerId: FieldRef<"prayerrequest", 'String'>
    readonly postedByOwnerName: FieldRef<"prayerrequest", 'String'>
    readonly createdAt: FieldRef<"prayerrequest", 'DateTime'>
    readonly updatedAt: FieldRef<"prayerrequest", 'DateTime'>
    readonly mediaUrls: FieldRef<"prayerrequest", 'Json'>
    readonly location: FieldRef<"prayerrequest", 'String'>
    readonly taggedFriends: FieldRef<"prayerrequest", 'String'>
    readonly feelingActivity: FieldRef<"prayerrequest", 'String'>
    readonly backgroundTheme: FieldRef<"prayerrequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * prayerrequest findUnique
   */
  export type prayerrequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * Filter, which prayerrequest to fetch.
     */
    where: prayerrequestWhereUniqueInput
  }

  /**
   * prayerrequest findUniqueOrThrow
   */
  export type prayerrequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * Filter, which prayerrequest to fetch.
     */
    where: prayerrequestWhereUniqueInput
  }

  /**
   * prayerrequest findFirst
   */
  export type prayerrequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * Filter, which prayerrequest to fetch.
     */
    where?: prayerrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayerrequests to fetch.
     */
    orderBy?: prayerrequestOrderByWithRelationInput | prayerrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prayerrequests.
     */
    cursor?: prayerrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayerrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayerrequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prayerrequests.
     */
    distinct?: PrayerrequestScalarFieldEnum | PrayerrequestScalarFieldEnum[]
  }

  /**
   * prayerrequest findFirstOrThrow
   */
  export type prayerrequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * Filter, which prayerrequest to fetch.
     */
    where?: prayerrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayerrequests to fetch.
     */
    orderBy?: prayerrequestOrderByWithRelationInput | prayerrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prayerrequests.
     */
    cursor?: prayerrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayerrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayerrequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prayerrequests.
     */
    distinct?: PrayerrequestScalarFieldEnum | PrayerrequestScalarFieldEnum[]
  }

  /**
   * prayerrequest findMany
   */
  export type prayerrequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * Filter, which prayerrequests to fetch.
     */
    where?: prayerrequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prayerrequests to fetch.
     */
    orderBy?: prayerrequestOrderByWithRelationInput | prayerrequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prayerrequests.
     */
    cursor?: prayerrequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prayerrequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prayerrequests.
     */
    skip?: number
    distinct?: PrayerrequestScalarFieldEnum | PrayerrequestScalarFieldEnum[]
  }

  /**
   * prayerrequest create
   */
  export type prayerrequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * The data needed to create a prayerrequest.
     */
    data: XOR<prayerrequestCreateInput, prayerrequestUncheckedCreateInput>
  }

  /**
   * prayerrequest createMany
   */
  export type prayerrequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prayerrequests.
     */
    data: prayerrequestCreateManyInput | prayerrequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prayerrequest update
   */
  export type prayerrequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * The data needed to update a prayerrequest.
     */
    data: XOR<prayerrequestUpdateInput, prayerrequestUncheckedUpdateInput>
    /**
     * Choose, which prayerrequest to update.
     */
    where: prayerrequestWhereUniqueInput
  }

  /**
   * prayerrequest updateMany
   */
  export type prayerrequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prayerrequests.
     */
    data: XOR<prayerrequestUpdateManyMutationInput, prayerrequestUncheckedUpdateManyInput>
    /**
     * Filter which prayerrequests to update
     */
    where?: prayerrequestWhereInput
  }

  /**
   * prayerrequest upsert
   */
  export type prayerrequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * The filter to search for the prayerrequest to update in case it exists.
     */
    where: prayerrequestWhereUniqueInput
    /**
     * In case the prayerrequest found by the `where` argument doesn't exist, create a new prayerrequest with this data.
     */
    create: XOR<prayerrequestCreateInput, prayerrequestUncheckedCreateInput>
    /**
     * In case the prayerrequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prayerrequestUpdateInput, prayerrequestUncheckedUpdateInput>
  }

  /**
   * prayerrequest delete
   */
  export type prayerrequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    /**
     * Filter which prayerrequest to delete.
     */
    where: prayerrequestWhereUniqueInput
  }

  /**
   * prayerrequest deleteMany
   */
  export type prayerrequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prayerrequests to delete
     */
    where?: prayerrequestWhereInput
  }

  /**
   * prayerrequest.comment
   */
  export type prayerrequest$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * prayerrequest.prayer
   */
  export type prayerrequest$prayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    where?: prayerWhereInput
    orderBy?: prayerOrderByWithRelationInput | prayerOrderByWithRelationInput[]
    cursor?: prayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrayerScalarFieldEnum | PrayerScalarFieldEnum[]
  }

  /**
   * prayerrequest.user
   */
  export type prayerrequest$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * prayerrequest without action
   */
  export type prayerrequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
  }


  /**
   * Model responsibility
   */

  export type AggregateResponsibility = {
    _count: ResponsibilityCountAggregateOutputType | null
    _min: ResponsibilityMinAggregateOutputType | null
    _max: ResponsibilityMaxAggregateOutputType | null
  }

  export type ResponsibilityMinAggregateOutputType = {
    id: string | null
    role: string | null
    assignedTo: string | null
    rosterItemId: string | null
    generatedScheduleId: string | null
  }

  export type ResponsibilityMaxAggregateOutputType = {
    id: string | null
    role: string | null
    assignedTo: string | null
    rosterItemId: string | null
    generatedScheduleId: string | null
  }

  export type ResponsibilityCountAggregateOutputType = {
    id: number
    role: number
    assignedTo: number
    rosterItemId: number
    generatedScheduleId: number
    _all: number
  }


  export type ResponsibilityMinAggregateInputType = {
    id?: true
    role?: true
    assignedTo?: true
    rosterItemId?: true
    generatedScheduleId?: true
  }

  export type ResponsibilityMaxAggregateInputType = {
    id?: true
    role?: true
    assignedTo?: true
    rosterItemId?: true
    generatedScheduleId?: true
  }

  export type ResponsibilityCountAggregateInputType = {
    id?: true
    role?: true
    assignedTo?: true
    rosterItemId?: true
    generatedScheduleId?: true
    _all?: true
  }

  export type ResponsibilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsibility to aggregate.
     */
    where?: responsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: responsibilityOrderByWithRelationInput | responsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: responsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned responsibilities
    **/
    _count?: true | ResponsibilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponsibilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponsibilityMaxAggregateInputType
  }

  export type GetResponsibilityAggregateType<T extends ResponsibilityAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsibility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsibility[P]>
      : GetScalarType<T[P], AggregateResponsibility[P]>
  }




  export type responsibilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: responsibilityWhereInput
    orderBy?: responsibilityOrderByWithAggregationInput | responsibilityOrderByWithAggregationInput[]
    by: ResponsibilityScalarFieldEnum[] | ResponsibilityScalarFieldEnum
    having?: responsibilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponsibilityCountAggregateInputType | true
    _min?: ResponsibilityMinAggregateInputType
    _max?: ResponsibilityMaxAggregateInputType
  }

  export type ResponsibilityGroupByOutputType = {
    id: string
    role: string
    assignedTo: string
    rosterItemId: string | null
    generatedScheduleId: string | null
    _count: ResponsibilityCountAggregateOutputType | null
    _min: ResponsibilityMinAggregateOutputType | null
    _max: ResponsibilityMaxAggregateOutputType | null
  }

  type GetResponsibilityGroupByPayload<T extends responsibilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponsibilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponsibilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponsibilityGroupByOutputType[P]>
            : GetScalarType<T[P], ResponsibilityGroupByOutputType[P]>
        }
      >
    >


  export type responsibilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    assignedTo?: boolean
    rosterItemId?: boolean
    generatedScheduleId?: boolean
    generatedscheduleitem?: boolean | responsibility$generatedscheduleitemArgs<ExtArgs>
    fellowshiprosteritem?: boolean | responsibility$fellowshiprosteritemArgs<ExtArgs>
  }, ExtArgs["result"]["responsibility"]>


  export type responsibilitySelectScalar = {
    id?: boolean
    role?: boolean
    assignedTo?: boolean
    rosterItemId?: boolean
    generatedScheduleId?: boolean
  }

  export type responsibilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedscheduleitem?: boolean | responsibility$generatedscheduleitemArgs<ExtArgs>
    fellowshiprosteritem?: boolean | responsibility$fellowshiprosteritemArgs<ExtArgs>
  }

  export type $responsibilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "responsibility"
    objects: {
      generatedscheduleitem: Prisma.$generatedscheduleitemPayload<ExtArgs> | null
      fellowshiprosteritem: Prisma.$fellowshiprosteritemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      assignedTo: string
      rosterItemId: string | null
      generatedScheduleId: string | null
    }, ExtArgs["result"]["responsibility"]>
    composites: {}
  }

  type responsibilityGetPayload<S extends boolean | null | undefined | responsibilityDefaultArgs> = $Result.GetResult<Prisma.$responsibilityPayload, S>

  type responsibilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<responsibilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResponsibilityCountAggregateInputType | true
    }

  export interface responsibilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['responsibility'], meta: { name: 'responsibility' } }
    /**
     * Find zero or one Responsibility that matches the filter.
     * @param {responsibilityFindUniqueArgs} args - Arguments to find a Responsibility
     * @example
     * // Get one Responsibility
     * const responsibility = await prisma.responsibility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends responsibilityFindUniqueArgs>(args: SelectSubset<T, responsibilityFindUniqueArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Responsibility that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {responsibilityFindUniqueOrThrowArgs} args - Arguments to find a Responsibility
     * @example
     * // Get one Responsibility
     * const responsibility = await prisma.responsibility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends responsibilityFindUniqueOrThrowArgs>(args: SelectSubset<T, responsibilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Responsibility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilityFindFirstArgs} args - Arguments to find a Responsibility
     * @example
     * // Get one Responsibility
     * const responsibility = await prisma.responsibility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends responsibilityFindFirstArgs>(args?: SelectSubset<T, responsibilityFindFirstArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Responsibility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilityFindFirstOrThrowArgs} args - Arguments to find a Responsibility
     * @example
     * // Get one Responsibility
     * const responsibility = await prisma.responsibility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends responsibilityFindFirstOrThrowArgs>(args?: SelectSubset<T, responsibilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Responsibilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Responsibilities
     * const responsibilities = await prisma.responsibility.findMany()
     * 
     * // Get first 10 Responsibilities
     * const responsibilities = await prisma.responsibility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responsibilityWithIdOnly = await prisma.responsibility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends responsibilityFindManyArgs>(args?: SelectSubset<T, responsibilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Responsibility.
     * @param {responsibilityCreateArgs} args - Arguments to create a Responsibility.
     * @example
     * // Create one Responsibility
     * const Responsibility = await prisma.responsibility.create({
     *   data: {
     *     // ... data to create a Responsibility
     *   }
     * })
     * 
     */
    create<T extends responsibilityCreateArgs>(args: SelectSubset<T, responsibilityCreateArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Responsibilities.
     * @param {responsibilityCreateManyArgs} args - Arguments to create many Responsibilities.
     * @example
     * // Create many Responsibilities
     * const responsibility = await prisma.responsibility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends responsibilityCreateManyArgs>(args?: SelectSubset<T, responsibilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Responsibility.
     * @param {responsibilityDeleteArgs} args - Arguments to delete one Responsibility.
     * @example
     * // Delete one Responsibility
     * const Responsibility = await prisma.responsibility.delete({
     *   where: {
     *     // ... filter to delete one Responsibility
     *   }
     * })
     * 
     */
    delete<T extends responsibilityDeleteArgs>(args: SelectSubset<T, responsibilityDeleteArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Responsibility.
     * @param {responsibilityUpdateArgs} args - Arguments to update one Responsibility.
     * @example
     * // Update one Responsibility
     * const responsibility = await prisma.responsibility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends responsibilityUpdateArgs>(args: SelectSubset<T, responsibilityUpdateArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Responsibilities.
     * @param {responsibilityDeleteManyArgs} args - Arguments to filter Responsibilities to delete.
     * @example
     * // Delete a few Responsibilities
     * const { count } = await prisma.responsibility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends responsibilityDeleteManyArgs>(args?: SelectSubset<T, responsibilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Responsibilities
     * const responsibility = await prisma.responsibility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends responsibilityUpdateManyArgs>(args: SelectSubset<T, responsibilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Responsibility.
     * @param {responsibilityUpsertArgs} args - Arguments to update or create a Responsibility.
     * @example
     * // Update or create a Responsibility
     * const responsibility = await prisma.responsibility.upsert({
     *   create: {
     *     // ... data to create a Responsibility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Responsibility we want to update
     *   }
     * })
     */
    upsert<T extends responsibilityUpsertArgs>(args: SelectSubset<T, responsibilityUpsertArgs<ExtArgs>>): Prisma__responsibilityClient<$Result.GetResult<Prisma.$responsibilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Responsibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilityCountArgs} args - Arguments to filter Responsibilities to count.
     * @example
     * // Count the number of Responsibilities
     * const count = await prisma.responsibility.count({
     *   where: {
     *     // ... the filter for the Responsibilities we want to count
     *   }
     * })
    **/
    count<T extends responsibilityCountArgs>(
      args?: Subset<T, responsibilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponsibilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Responsibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponsibilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponsibilityAggregateArgs>(args: Subset<T, ResponsibilityAggregateArgs>): Prisma.PrismaPromise<GetResponsibilityAggregateType<T>>

    /**
     * Group by Responsibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsibilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends responsibilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: responsibilityGroupByArgs['orderBy'] }
        : { orderBy?: responsibilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, responsibilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsibilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the responsibility model
   */
  readonly fields: responsibilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for responsibility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__responsibilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generatedscheduleitem<T extends responsibility$generatedscheduleitemArgs<ExtArgs> = {}>(args?: Subset<T, responsibility$generatedscheduleitemArgs<ExtArgs>>): Prisma__generatedscheduleitemClient<$Result.GetResult<Prisma.$generatedscheduleitemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    fellowshiprosteritem<T extends responsibility$fellowshiprosteritemArgs<ExtArgs> = {}>(args?: Subset<T, responsibility$fellowshiprosteritemArgs<ExtArgs>>): Prisma__fellowshiprosteritemClient<$Result.GetResult<Prisma.$fellowshiprosteritemPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the responsibility model
   */ 
  interface responsibilityFieldRefs {
    readonly id: FieldRef<"responsibility", 'String'>
    readonly role: FieldRef<"responsibility", 'String'>
    readonly assignedTo: FieldRef<"responsibility", 'String'>
    readonly rosterItemId: FieldRef<"responsibility", 'String'>
    readonly generatedScheduleId: FieldRef<"responsibility", 'String'>
  }
    

  // Custom InputTypes
  /**
   * responsibility findUnique
   */
  export type responsibilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * Filter, which responsibility to fetch.
     */
    where: responsibilityWhereUniqueInput
  }

  /**
   * responsibility findUniqueOrThrow
   */
  export type responsibilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * Filter, which responsibility to fetch.
     */
    where: responsibilityWhereUniqueInput
  }

  /**
   * responsibility findFirst
   */
  export type responsibilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * Filter, which responsibility to fetch.
     */
    where?: responsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: responsibilityOrderByWithRelationInput | responsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsibilities.
     */
    cursor?: responsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsibilities.
     */
    distinct?: ResponsibilityScalarFieldEnum | ResponsibilityScalarFieldEnum[]
  }

  /**
   * responsibility findFirstOrThrow
   */
  export type responsibilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * Filter, which responsibility to fetch.
     */
    where?: responsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: responsibilityOrderByWithRelationInput | responsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsibilities.
     */
    cursor?: responsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsibilities.
     */
    distinct?: ResponsibilityScalarFieldEnum | ResponsibilityScalarFieldEnum[]
  }

  /**
   * responsibility findMany
   */
  export type responsibilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * Filter, which responsibilities to fetch.
     */
    where?: responsibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsibilities to fetch.
     */
    orderBy?: responsibilityOrderByWithRelationInput | responsibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing responsibilities.
     */
    cursor?: responsibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsibilities.
     */
    skip?: number
    distinct?: ResponsibilityScalarFieldEnum | ResponsibilityScalarFieldEnum[]
  }

  /**
   * responsibility create
   */
  export type responsibilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * The data needed to create a responsibility.
     */
    data: XOR<responsibilityCreateInput, responsibilityUncheckedCreateInput>
  }

  /**
   * responsibility createMany
   */
  export type responsibilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many responsibilities.
     */
    data: responsibilityCreateManyInput | responsibilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * responsibility update
   */
  export type responsibilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * The data needed to update a responsibility.
     */
    data: XOR<responsibilityUpdateInput, responsibilityUncheckedUpdateInput>
    /**
     * Choose, which responsibility to update.
     */
    where: responsibilityWhereUniqueInput
  }

  /**
   * responsibility updateMany
   */
  export type responsibilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update responsibilities.
     */
    data: XOR<responsibilityUpdateManyMutationInput, responsibilityUncheckedUpdateManyInput>
    /**
     * Filter which responsibilities to update
     */
    where?: responsibilityWhereInput
  }

  /**
   * responsibility upsert
   */
  export type responsibilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * The filter to search for the responsibility to update in case it exists.
     */
    where: responsibilityWhereUniqueInput
    /**
     * In case the responsibility found by the `where` argument doesn't exist, create a new responsibility with this data.
     */
    create: XOR<responsibilityCreateInput, responsibilityUncheckedCreateInput>
    /**
     * In case the responsibility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<responsibilityUpdateInput, responsibilityUncheckedUpdateInput>
  }

  /**
   * responsibility delete
   */
  export type responsibilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
    /**
     * Filter which responsibility to delete.
     */
    where: responsibilityWhereUniqueInput
  }

  /**
   * responsibility deleteMany
   */
  export type responsibilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsibilities to delete
     */
    where?: responsibilityWhereInput
  }

  /**
   * responsibility.generatedscheduleitem
   */
  export type responsibility$generatedscheduleitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the generatedscheduleitem
     */
    select?: generatedscheduleitemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: generatedscheduleitemInclude<ExtArgs> | null
    where?: generatedscheduleitemWhereInput
  }

  /**
   * responsibility.fellowshiprosteritem
   */
  export type responsibility$fellowshiprosteritemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fellowshiprosteritem
     */
    select?: fellowshiprosteritemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fellowshiprosteritemInclude<ExtArgs> | null
    where?: fellowshiprosteritemWhereInput
  }

  /**
   * responsibility without action
   */
  export type responsibilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsibility
     */
    select?: responsibilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsibilityInclude<ExtArgs> | null
  }


  /**
   * Model sermon
   */

  export type AggregateSermon = {
    _count: SermonCountAggregateOutputType | null
    _avg: SermonAvgAggregateOutputType | null
    _sum: SermonSumAggregateOutputType | null
    _min: SermonMinAggregateOutputType | null
    _max: SermonMaxAggregateOutputType | null
  }

  export type SermonAvgAggregateOutputType = {
    likes: number | null
  }

  export type SermonSumAggregateOutputType = {
    likes: number | null
  }

  export type SermonMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.sermon_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    speaker: string | null
    scripture: string | null
    videoUrl: string | null
    audioUrl: string | null
    fullContent: string | null
    likes: number | null
  }

  export type SermonMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    linkPath: string | null
    category: $Enums.sermon_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    speaker: string | null
    scripture: string | null
    videoUrl: string | null
    audioUrl: string | null
    fullContent: string | null
    likes: number | null
  }

  export type SermonCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    linkPath: number
    category: number
    date: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    speaker: number
    scripture: number
    videoUrl: number
    audioUrl: number
    fullContent: number
    likes: number
    _all: number
  }


  export type SermonAvgAggregateInputType = {
    likes?: true
  }

  export type SermonSumAggregateInputType = {
    likes?: true
  }

  export type SermonMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    speaker?: true
    scripture?: true
    videoUrl?: true
    audioUrl?: true
    fullContent?: true
    likes?: true
  }

  export type SermonMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    speaker?: true
    scripture?: true
    videoUrl?: true
    audioUrl?: true
    fullContent?: true
    likes?: true
  }

  export type SermonCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    linkPath?: true
    category?: true
    date?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    speaker?: true
    scripture?: true
    videoUrl?: true
    audioUrl?: true
    fullContent?: true
    likes?: true
    _all?: true
  }

  export type SermonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sermon to aggregate.
     */
    where?: sermonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sermons to fetch.
     */
    orderBy?: sermonOrderByWithRelationInput | sermonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sermonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sermons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sermons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sermons
    **/
    _count?: true | SermonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SermonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SermonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SermonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SermonMaxAggregateInputType
  }

  export type GetSermonAggregateType<T extends SermonAggregateArgs> = {
        [P in keyof T & keyof AggregateSermon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSermon[P]>
      : GetScalarType<T[P], AggregateSermon[P]>
  }




  export type sermonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sermonWhereInput
    orderBy?: sermonOrderByWithAggregationInput | sermonOrderByWithAggregationInput[]
    by: SermonScalarFieldEnum[] | SermonScalarFieldEnum
    having?: sermonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SermonCountAggregateInputType | true
    _avg?: SermonAvgAggregateInputType
    _sum?: SermonSumAggregateInputType
    _min?: SermonMinAggregateInputType
    _max?: SermonMaxAggregateInputType
  }

  export type SermonGroupByOutputType = {
    id: string
    title: string
    description: string
    imageUrl: string | null
    linkPath: string
    category: $Enums.sermon_category | null
    date: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    speaker: string | null
    scripture: string | null
    videoUrl: string | null
    audioUrl: string | null
    fullContent: string | null
    likes: number
    _count: SermonCountAggregateOutputType | null
    _avg: SermonAvgAggregateOutputType | null
    _sum: SermonSumAggregateOutputType | null
    _min: SermonMinAggregateOutputType | null
    _max: SermonMaxAggregateOutputType | null
  }

  type GetSermonGroupByPayload<T extends sermonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SermonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SermonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SermonGroupByOutputType[P]>
            : GetScalarType<T[P], SermonGroupByOutputType[P]>
        }
      >
    >


  export type sermonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    speaker?: boolean
    scripture?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fullContent?: boolean
    likes?: boolean
    comment?: boolean | sermon$commentArgs<ExtArgs>
    _count?: boolean | SermonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sermon"]>


  export type sermonSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    linkPath?: boolean
    category?: boolean
    date?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    speaker?: boolean
    scripture?: boolean
    videoUrl?: boolean
    audioUrl?: boolean
    fullContent?: boolean
    likes?: boolean
  }

  export type sermonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | sermon$commentArgs<ExtArgs>
    _count?: boolean | SermonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sermonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sermon"
    objects: {
      comment: Prisma.$commentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      imageUrl: string | null
      linkPath: string
      category: $Enums.sermon_category | null
      date: Date | null
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      speaker: string | null
      scripture: string | null
      videoUrl: string | null
      audioUrl: string | null
      fullContent: string | null
      likes: number
    }, ExtArgs["result"]["sermon"]>
    composites: {}
  }

  type sermonGetPayload<S extends boolean | null | undefined | sermonDefaultArgs> = $Result.GetResult<Prisma.$sermonPayload, S>

  type sermonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sermonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SermonCountAggregateInputType | true
    }

  export interface sermonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sermon'], meta: { name: 'sermon' } }
    /**
     * Find zero or one Sermon that matches the filter.
     * @param {sermonFindUniqueArgs} args - Arguments to find a Sermon
     * @example
     * // Get one Sermon
     * const sermon = await prisma.sermon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sermonFindUniqueArgs>(args: SelectSubset<T, sermonFindUniqueArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sermon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sermonFindUniqueOrThrowArgs} args - Arguments to find a Sermon
     * @example
     * // Get one Sermon
     * const sermon = await prisma.sermon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sermonFindUniqueOrThrowArgs>(args: SelectSubset<T, sermonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sermon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sermonFindFirstArgs} args - Arguments to find a Sermon
     * @example
     * // Get one Sermon
     * const sermon = await prisma.sermon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sermonFindFirstArgs>(args?: SelectSubset<T, sermonFindFirstArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sermon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sermonFindFirstOrThrowArgs} args - Arguments to find a Sermon
     * @example
     * // Get one Sermon
     * const sermon = await prisma.sermon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sermonFindFirstOrThrowArgs>(args?: SelectSubset<T, sermonFindFirstOrThrowArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sermons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sermonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sermons
     * const sermons = await prisma.sermon.findMany()
     * 
     * // Get first 10 Sermons
     * const sermons = await prisma.sermon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sermonWithIdOnly = await prisma.sermon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sermonFindManyArgs>(args?: SelectSubset<T, sermonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sermon.
     * @param {sermonCreateArgs} args - Arguments to create a Sermon.
     * @example
     * // Create one Sermon
     * const Sermon = await prisma.sermon.create({
     *   data: {
     *     // ... data to create a Sermon
     *   }
     * })
     * 
     */
    create<T extends sermonCreateArgs>(args: SelectSubset<T, sermonCreateArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sermons.
     * @param {sermonCreateManyArgs} args - Arguments to create many Sermons.
     * @example
     * // Create many Sermons
     * const sermon = await prisma.sermon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sermonCreateManyArgs>(args?: SelectSubset<T, sermonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sermon.
     * @param {sermonDeleteArgs} args - Arguments to delete one Sermon.
     * @example
     * // Delete one Sermon
     * const Sermon = await prisma.sermon.delete({
     *   where: {
     *     // ... filter to delete one Sermon
     *   }
     * })
     * 
     */
    delete<T extends sermonDeleteArgs>(args: SelectSubset<T, sermonDeleteArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sermon.
     * @param {sermonUpdateArgs} args - Arguments to update one Sermon.
     * @example
     * // Update one Sermon
     * const sermon = await prisma.sermon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sermonUpdateArgs>(args: SelectSubset<T, sermonUpdateArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sermons.
     * @param {sermonDeleteManyArgs} args - Arguments to filter Sermons to delete.
     * @example
     * // Delete a few Sermons
     * const { count } = await prisma.sermon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sermonDeleteManyArgs>(args?: SelectSubset<T, sermonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sermons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sermonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sermons
     * const sermon = await prisma.sermon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sermonUpdateManyArgs>(args: SelectSubset<T, sermonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sermon.
     * @param {sermonUpsertArgs} args - Arguments to update or create a Sermon.
     * @example
     * // Update or create a Sermon
     * const sermon = await prisma.sermon.upsert({
     *   create: {
     *     // ... data to create a Sermon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sermon we want to update
     *   }
     * })
     */
    upsert<T extends sermonUpsertArgs>(args: SelectSubset<T, sermonUpsertArgs<ExtArgs>>): Prisma__sermonClient<$Result.GetResult<Prisma.$sermonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sermons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sermonCountArgs} args - Arguments to filter Sermons to count.
     * @example
     * // Count the number of Sermons
     * const count = await prisma.sermon.count({
     *   where: {
     *     // ... the filter for the Sermons we want to count
     *   }
     * })
    **/
    count<T extends sermonCountArgs>(
      args?: Subset<T, sermonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SermonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sermon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SermonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SermonAggregateArgs>(args: Subset<T, SermonAggregateArgs>): Prisma.PrismaPromise<GetSermonAggregateType<T>>

    /**
     * Group by Sermon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sermonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sermonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sermonGroupByArgs['orderBy'] }
        : { orderBy?: sermonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sermonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSermonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sermon model
   */
  readonly fields: sermonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sermon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sermonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends sermon$commentArgs<ExtArgs> = {}>(args?: Subset<T, sermon$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sermon model
   */ 
  interface sermonFieldRefs {
    readonly id: FieldRef<"sermon", 'String'>
    readonly title: FieldRef<"sermon", 'String'>
    readonly description: FieldRef<"sermon", 'String'>
    readonly imageUrl: FieldRef<"sermon", 'String'>
    readonly linkPath: FieldRef<"sermon", 'String'>
    readonly category: FieldRef<"sermon", 'sermon_category'>
    readonly date: FieldRef<"sermon", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"sermon", 'String'>
    readonly postedByOwnerName: FieldRef<"sermon", 'String'>
    readonly createdAt: FieldRef<"sermon", 'DateTime'>
    readonly updatedAt: FieldRef<"sermon", 'DateTime'>
    readonly speaker: FieldRef<"sermon", 'String'>
    readonly scripture: FieldRef<"sermon", 'String'>
    readonly videoUrl: FieldRef<"sermon", 'String'>
    readonly audioUrl: FieldRef<"sermon", 'String'>
    readonly fullContent: FieldRef<"sermon", 'String'>
    readonly likes: FieldRef<"sermon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * sermon findUnique
   */
  export type sermonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * Filter, which sermon to fetch.
     */
    where: sermonWhereUniqueInput
  }

  /**
   * sermon findUniqueOrThrow
   */
  export type sermonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * Filter, which sermon to fetch.
     */
    where: sermonWhereUniqueInput
  }

  /**
   * sermon findFirst
   */
  export type sermonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * Filter, which sermon to fetch.
     */
    where?: sermonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sermons to fetch.
     */
    orderBy?: sermonOrderByWithRelationInput | sermonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sermons.
     */
    cursor?: sermonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sermons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sermons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sermons.
     */
    distinct?: SermonScalarFieldEnum | SermonScalarFieldEnum[]
  }

  /**
   * sermon findFirstOrThrow
   */
  export type sermonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * Filter, which sermon to fetch.
     */
    where?: sermonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sermons to fetch.
     */
    orderBy?: sermonOrderByWithRelationInput | sermonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sermons.
     */
    cursor?: sermonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sermons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sermons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sermons.
     */
    distinct?: SermonScalarFieldEnum | SermonScalarFieldEnum[]
  }

  /**
   * sermon findMany
   */
  export type sermonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * Filter, which sermons to fetch.
     */
    where?: sermonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sermons to fetch.
     */
    orderBy?: sermonOrderByWithRelationInput | sermonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sermons.
     */
    cursor?: sermonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sermons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sermons.
     */
    skip?: number
    distinct?: SermonScalarFieldEnum | SermonScalarFieldEnum[]
  }

  /**
   * sermon create
   */
  export type sermonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * The data needed to create a sermon.
     */
    data: XOR<sermonCreateInput, sermonUncheckedCreateInput>
  }

  /**
   * sermon createMany
   */
  export type sermonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sermons.
     */
    data: sermonCreateManyInput | sermonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sermon update
   */
  export type sermonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * The data needed to update a sermon.
     */
    data: XOR<sermonUpdateInput, sermonUncheckedUpdateInput>
    /**
     * Choose, which sermon to update.
     */
    where: sermonWhereUniqueInput
  }

  /**
   * sermon updateMany
   */
  export type sermonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sermons.
     */
    data: XOR<sermonUpdateManyMutationInput, sermonUncheckedUpdateManyInput>
    /**
     * Filter which sermons to update
     */
    where?: sermonWhereInput
  }

  /**
   * sermon upsert
   */
  export type sermonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * The filter to search for the sermon to update in case it exists.
     */
    where: sermonWhereUniqueInput
    /**
     * In case the sermon found by the `where` argument doesn't exist, create a new sermon with this data.
     */
    create: XOR<sermonCreateInput, sermonUncheckedCreateInput>
    /**
     * In case the sermon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sermonUpdateInput, sermonUncheckedUpdateInput>
  }

  /**
   * sermon delete
   */
  export type sermonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
    /**
     * Filter which sermon to delete.
     */
    where: sermonWhereUniqueInput
  }

  /**
   * sermon deleteMany
   */
  export type sermonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sermons to delete
     */
    where?: sermonWhereInput
  }

  /**
   * sermon.comment
   */
  export type sermon$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * sermon without action
   */
  export type sermonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sermon
     */
    select?: sermonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sermonInclude<ExtArgs> | null
  }


  /**
   * Model testimonial
   */

  export type AggregateTestimonial = {
    _count: TestimonialCountAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  export type TestimonialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userProfileImageUrl: string | null
    title: string | null
    contentText: string | null
    visibility: $Enums.testimonial_visibility | null
    submittedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
  }

  export type TestimonialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userName: string | null
    userProfileImageUrl: string | null
    title: string | null
    contentText: string | null
    visibility: $Enums.testimonial_visibility | null
    submittedAt: Date | null
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
  }

  export type TestimonialCountAggregateOutputType = {
    id: number
    userId: number
    userName: number
    userProfileImageUrl: number
    title: number
    contentText: number
    visibility: number
    submittedAt: number
    postedByOwnerId: number
    postedByOwnerName: number
    createdAt: number
    updatedAt: number
    mediaUrls: number
    location: number
    taggedFriends: number
    feelingActivity: number
    backgroundTheme: number
    _all: number
  }


  export type TestimonialMinAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    title?: true
    contentText?: true
    visibility?: true
    submittedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
  }

  export type TestimonialMaxAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    title?: true
    contentText?: true
    visibility?: true
    submittedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
  }

  export type TestimonialCountAggregateInputType = {
    id?: true
    userId?: true
    userName?: true
    userProfileImageUrl?: true
    title?: true
    contentText?: true
    visibility?: true
    submittedAt?: true
    postedByOwnerId?: true
    postedByOwnerName?: true
    createdAt?: true
    updatedAt?: true
    mediaUrls?: true
    location?: true
    taggedFriends?: true
    feelingActivity?: true
    backgroundTheme?: true
    _all?: true
  }

  export type TestimonialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testimonial to aggregate.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testimonials
    **/
    _count?: true | TestimonialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestimonialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestimonialMaxAggregateInputType
  }

  export type GetTestimonialAggregateType<T extends TestimonialAggregateArgs> = {
        [P in keyof T & keyof AggregateTestimonial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestimonial[P]>
      : GetScalarType<T[P], AggregateTestimonial[P]>
  }




  export type testimonialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testimonialWhereInput
    orderBy?: testimonialOrderByWithAggregationInput | testimonialOrderByWithAggregationInput[]
    by: TestimonialScalarFieldEnum[] | TestimonialScalarFieldEnum
    having?: testimonialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestimonialCountAggregateInputType | true
    _min?: TestimonialMinAggregateInputType
    _max?: TestimonialMaxAggregateInputType
  }

  export type TestimonialGroupByOutputType = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl: string | null
    title: string
    contentText: string
    visibility: $Enums.testimonial_visibility
    submittedAt: Date
    postedByOwnerId: string | null
    postedByOwnerName: string | null
    createdAt: Date
    updatedAt: Date
    mediaUrls: JsonValue | null
    location: string | null
    taggedFriends: string | null
    feelingActivity: string | null
    backgroundTheme: string | null
    _count: TestimonialCountAggregateOutputType | null
    _min: TestimonialMinAggregateOutputType | null
    _max: TestimonialMaxAggregateOutputType | null
  }

  type GetTestimonialGroupByPayload<T extends testimonialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestimonialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestimonialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
            : GetScalarType<T[P], TestimonialGroupByOutputType[P]>
        }
      >
    >


  export type testimonialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userName?: boolean
    userProfileImageUrl?: boolean
    title?: boolean
    contentText?: boolean
    visibility?: boolean
    submittedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaUrls?: boolean
    location?: boolean
    taggedFriends?: boolean
    feelingActivity?: boolean
    backgroundTheme?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testimonial"]>


  export type testimonialSelectScalar = {
    id?: boolean
    userId?: boolean
    userName?: boolean
    userProfileImageUrl?: boolean
    title?: boolean
    contentText?: boolean
    visibility?: boolean
    submittedAt?: boolean
    postedByOwnerId?: boolean
    postedByOwnerName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mediaUrls?: boolean
    location?: boolean
    taggedFriends?: boolean
    feelingActivity?: boolean
    backgroundTheme?: boolean
  }

  export type testimonialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $testimonialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testimonial"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userName: string
      userProfileImageUrl: string | null
      title: string
      contentText: string
      visibility: $Enums.testimonial_visibility
      submittedAt: Date
      postedByOwnerId: string | null
      postedByOwnerName: string | null
      createdAt: Date
      updatedAt: Date
      mediaUrls: Prisma.JsonValue | null
      location: string | null
      taggedFriends: string | null
      feelingActivity: string | null
      backgroundTheme: string | null
    }, ExtArgs["result"]["testimonial"]>
    composites: {}
  }

  type testimonialGetPayload<S extends boolean | null | undefined | testimonialDefaultArgs> = $Result.GetResult<Prisma.$testimonialPayload, S>

  type testimonialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<testimonialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestimonialCountAggregateInputType | true
    }

  export interface testimonialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testimonial'], meta: { name: 'testimonial' } }
    /**
     * Find zero or one Testimonial that matches the filter.
     * @param {testimonialFindUniqueArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testimonialFindUniqueArgs>(args: SelectSubset<T, testimonialFindUniqueArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Testimonial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {testimonialFindUniqueOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testimonialFindUniqueOrThrowArgs>(args: SelectSubset<T, testimonialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialFindFirstArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testimonialFindFirstArgs>(args?: SelectSubset<T, testimonialFindFirstArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Testimonial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialFindFirstOrThrowArgs} args - Arguments to find a Testimonial
     * @example
     * // Get one Testimonial
     * const testimonial = await prisma.testimonial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testimonialFindFirstOrThrowArgs>(args?: SelectSubset<T, testimonialFindFirstOrThrowArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Testimonials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testimonials
     * const testimonials = await prisma.testimonial.findMany()
     * 
     * // Get first 10 Testimonials
     * const testimonials = await prisma.testimonial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testimonialWithIdOnly = await prisma.testimonial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends testimonialFindManyArgs>(args?: SelectSubset<T, testimonialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Testimonial.
     * @param {testimonialCreateArgs} args - Arguments to create a Testimonial.
     * @example
     * // Create one Testimonial
     * const Testimonial = await prisma.testimonial.create({
     *   data: {
     *     // ... data to create a Testimonial
     *   }
     * })
     * 
     */
    create<T extends testimonialCreateArgs>(args: SelectSubset<T, testimonialCreateArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Testimonials.
     * @param {testimonialCreateManyArgs} args - Arguments to create many Testimonials.
     * @example
     * // Create many Testimonials
     * const testimonial = await prisma.testimonial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testimonialCreateManyArgs>(args?: SelectSubset<T, testimonialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testimonial.
     * @param {testimonialDeleteArgs} args - Arguments to delete one Testimonial.
     * @example
     * // Delete one Testimonial
     * const Testimonial = await prisma.testimonial.delete({
     *   where: {
     *     // ... filter to delete one Testimonial
     *   }
     * })
     * 
     */
    delete<T extends testimonialDeleteArgs>(args: SelectSubset<T, testimonialDeleteArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Testimonial.
     * @param {testimonialUpdateArgs} args - Arguments to update one Testimonial.
     * @example
     * // Update one Testimonial
     * const testimonial = await prisma.testimonial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testimonialUpdateArgs>(args: SelectSubset<T, testimonialUpdateArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Testimonials.
     * @param {testimonialDeleteManyArgs} args - Arguments to filter Testimonials to delete.
     * @example
     * // Delete a few Testimonials
     * const { count } = await prisma.testimonial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testimonialDeleteManyArgs>(args?: SelectSubset<T, testimonialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testimonials
     * const testimonial = await prisma.testimonial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testimonialUpdateManyArgs>(args: SelectSubset<T, testimonialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testimonial.
     * @param {testimonialUpsertArgs} args - Arguments to update or create a Testimonial.
     * @example
     * // Update or create a Testimonial
     * const testimonial = await prisma.testimonial.upsert({
     *   create: {
     *     // ... data to create a Testimonial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testimonial we want to update
     *   }
     * })
     */
    upsert<T extends testimonialUpsertArgs>(args: SelectSubset<T, testimonialUpsertArgs<ExtArgs>>): Prisma__testimonialClient<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Testimonials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialCountArgs} args - Arguments to filter Testimonials to count.
     * @example
     * // Count the number of Testimonials
     * const count = await prisma.testimonial.count({
     *   where: {
     *     // ... the filter for the Testimonials we want to count
     *   }
     * })
    **/
    count<T extends testimonialCountArgs>(
      args?: Subset<T, testimonialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestimonialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestimonialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestimonialAggregateArgs>(args: Subset<T, TestimonialAggregateArgs>): Prisma.PrismaPromise<GetTestimonialAggregateType<T>>

    /**
     * Group by Testimonial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testimonialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testimonialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testimonialGroupByArgs['orderBy'] }
        : { orderBy?: testimonialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testimonialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestimonialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testimonial model
   */
  readonly fields: testimonialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testimonial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testimonialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testimonial model
   */ 
  interface testimonialFieldRefs {
    readonly id: FieldRef<"testimonial", 'String'>
    readonly userId: FieldRef<"testimonial", 'String'>
    readonly userName: FieldRef<"testimonial", 'String'>
    readonly userProfileImageUrl: FieldRef<"testimonial", 'String'>
    readonly title: FieldRef<"testimonial", 'String'>
    readonly contentText: FieldRef<"testimonial", 'String'>
    readonly visibility: FieldRef<"testimonial", 'testimonial_visibility'>
    readonly submittedAt: FieldRef<"testimonial", 'DateTime'>
    readonly postedByOwnerId: FieldRef<"testimonial", 'String'>
    readonly postedByOwnerName: FieldRef<"testimonial", 'String'>
    readonly createdAt: FieldRef<"testimonial", 'DateTime'>
    readonly updatedAt: FieldRef<"testimonial", 'DateTime'>
    readonly mediaUrls: FieldRef<"testimonial", 'Json'>
    readonly location: FieldRef<"testimonial", 'String'>
    readonly taggedFriends: FieldRef<"testimonial", 'String'>
    readonly feelingActivity: FieldRef<"testimonial", 'String'>
    readonly backgroundTheme: FieldRef<"testimonial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * testimonial findUnique
   */
  export type testimonialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial findUniqueOrThrow
   */
  export type testimonialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial findFirst
   */
  export type testimonialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testimonials.
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * testimonial findFirstOrThrow
   */
  export type testimonialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonial to fetch.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testimonials.
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testimonials.
     */
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * testimonial findMany
   */
  export type testimonialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter, which testimonials to fetch.
     */
    where?: testimonialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testimonials to fetch.
     */
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testimonials.
     */
    cursor?: testimonialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testimonials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testimonials.
     */
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * testimonial create
   */
  export type testimonialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * The data needed to create a testimonial.
     */
    data: XOR<testimonialCreateInput, testimonialUncheckedCreateInput>
  }

  /**
   * testimonial createMany
   */
  export type testimonialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testimonials.
     */
    data: testimonialCreateManyInput | testimonialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testimonial update
   */
  export type testimonialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * The data needed to update a testimonial.
     */
    data: XOR<testimonialUpdateInput, testimonialUncheckedUpdateInput>
    /**
     * Choose, which testimonial to update.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial updateMany
   */
  export type testimonialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testimonials.
     */
    data: XOR<testimonialUpdateManyMutationInput, testimonialUncheckedUpdateManyInput>
    /**
     * Filter which testimonials to update
     */
    where?: testimonialWhereInput
  }

  /**
   * testimonial upsert
   */
  export type testimonialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * The filter to search for the testimonial to update in case it exists.
     */
    where: testimonialWhereUniqueInput
    /**
     * In case the testimonial found by the `where` argument doesn't exist, create a new testimonial with this data.
     */
    create: XOR<testimonialCreateInput, testimonialUncheckedCreateInput>
    /**
     * In case the testimonial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testimonialUpdateInput, testimonialUncheckedUpdateInput>
  }

  /**
   * testimonial delete
   */
  export type testimonialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    /**
     * Filter which testimonial to delete.
     */
    where: testimonialWhereUniqueInput
  }

  /**
   * testimonial deleteMany
   */
  export type testimonialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testimonials to delete
     */
    where?: testimonialWhereInput
  }

  /**
   * testimonial without action
   */
  export type testimonialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    password: string | null
    passwordHash: string | null
    id: string | null
    username: string | null
    fullName: string | null
    email: string | null
    countryCode: string | null
    phone: string | null
    role: $Enums.user_role | null
    profileImageUrl: string | null
    coverPhotoUrl: string | null
    bio: string | null
    hometown: string | null
    currentCity: string | null
    work: string | null
    education: string | null
    relationshipStatus: $Enums.user_relationshipStatus | null
    interests: string | null
    favoriteScripture: string | null
    receiveContentUpdateNotifications: boolean | null
    receivePrayerRequestNotifications: boolean | null
    receiveTestimonialNotifications: boolean | null
    receiveFriendActivityNotifications: boolean | null
    friendsListPrivacy: $Enums.user_friendsListPrivacy | null
    profileInSearchPrivacy: boolean | null
    friendRequestPrivacy: $Enums.user_friendRequestPrivacy | null
    groupInvitePrivacy: $Enums.user_groupInvitePrivacy | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    password: string | null
    passwordHash: string | null
    id: string | null
    username: string | null
    fullName: string | null
    email: string | null
    countryCode: string | null
    phone: string | null
    role: $Enums.user_role | null
    profileImageUrl: string | null
    coverPhotoUrl: string | null
    bio: string | null
    hometown: string | null
    currentCity: string | null
    work: string | null
    education: string | null
    relationshipStatus: $Enums.user_relationshipStatus | null
    interests: string | null
    favoriteScripture: string | null
    receiveContentUpdateNotifications: boolean | null
    receivePrayerRequestNotifications: boolean | null
    receiveTestimonialNotifications: boolean | null
    receiveFriendActivityNotifications: boolean | null
    friendsListPrivacy: $Enums.user_friendsListPrivacy | null
    profileInSearchPrivacy: boolean | null
    friendRequestPrivacy: $Enums.user_friendRequestPrivacy | null
    groupInvitePrivacy: $Enums.user_groupInvitePrivacy | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    password: number
    passwordHash: number
    id: number
    username: number
    fullName: number
    email: number
    countryCode: number
    phone: number
    role: number
    profileImageUrl: number
    coverPhotoUrl: number
    bio: number
    hometown: number
    currentCity: number
    work: number
    education: number
    relationshipStatus: number
    interests: number
    favoriteScripture: number
    receiveContentUpdateNotifications: number
    receivePrayerRequestNotifications: number
    receiveTestimonialNotifications: number
    receiveFriendActivityNotifications: number
    friendsListPrivacy: number
    profileInSearchPrivacy: number
    friendRequestPrivacy: number
    groupInvitePrivacy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    password?: true
    passwordHash?: true
    id?: true
    username?: true
    fullName?: true
    email?: true
    countryCode?: true
    phone?: true
    role?: true
    profileImageUrl?: true
    coverPhotoUrl?: true
    bio?: true
    hometown?: true
    currentCity?: true
    work?: true
    education?: true
    relationshipStatus?: true
    interests?: true
    favoriteScripture?: true
    receiveContentUpdateNotifications?: true
    receivePrayerRequestNotifications?: true
    receiveTestimonialNotifications?: true
    receiveFriendActivityNotifications?: true
    friendsListPrivacy?: true
    profileInSearchPrivacy?: true
    friendRequestPrivacy?: true
    groupInvitePrivacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    password?: true
    passwordHash?: true
    id?: true
    username?: true
    fullName?: true
    email?: true
    countryCode?: true
    phone?: true
    role?: true
    profileImageUrl?: true
    coverPhotoUrl?: true
    bio?: true
    hometown?: true
    currentCity?: true
    work?: true
    education?: true
    relationshipStatus?: true
    interests?: true
    favoriteScripture?: true
    receiveContentUpdateNotifications?: true
    receivePrayerRequestNotifications?: true
    receiveTestimonialNotifications?: true
    receiveFriendActivityNotifications?: true
    friendsListPrivacy?: true
    profileInSearchPrivacy?: true
    friendRequestPrivacy?: true
    groupInvitePrivacy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    password?: true
    passwordHash?: true
    id?: true
    username?: true
    fullName?: true
    email?: true
    countryCode?: true
    phone?: true
    role?: true
    profileImageUrl?: true
    coverPhotoUrl?: true
    bio?: true
    hometown?: true
    currentCity?: true
    work?: true
    education?: true
    relationshipStatus?: true
    interests?: true
    favoriteScripture?: true
    receiveContentUpdateNotifications?: true
    receivePrayerRequestNotifications?: true
    receiveTestimonialNotifications?: true
    receiveFriendActivityNotifications?: true
    friendsListPrivacy?: true
    profileInSearchPrivacy?: true
    friendRequestPrivacy?: true
    groupInvitePrivacy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    password: string
    passwordHash: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode: string | null
    phone: string | null
    role: $Enums.user_role
    profileImageUrl: string | null
    coverPhotoUrl: string | null
    bio: string | null
    hometown: string | null
    currentCity: string | null
    work: string | null
    education: string | null
    relationshipStatus: $Enums.user_relationshipStatus | null
    interests: string | null
    favoriteScripture: string | null
    receiveContentUpdateNotifications: boolean
    receivePrayerRequestNotifications: boolean
    receiveTestimonialNotifications: boolean
    receiveFriendActivityNotifications: boolean
    friendsListPrivacy: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy: boolean
    friendRequestPrivacy: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy: $Enums.user_groupInvitePrivacy
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    password?: boolean
    passwordHash?: boolean
    id?: boolean
    username?: boolean
    fullName?: boolean
    email?: boolean
    countryCode?: boolean
    phone?: boolean
    role?: boolean
    profileImageUrl?: boolean
    coverPhotoUrl?: boolean
    bio?: boolean
    hometown?: boolean
    currentCity?: boolean
    work?: boolean
    education?: boolean
    relationshipStatus?: boolean
    interests?: boolean
    favoriteScripture?: boolean
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: boolean
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: boolean
    groupInvitePrivacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adminactionlog?: boolean | user$adminactionlogArgs<ExtArgs>
    churchmember?: boolean | user$churchmemberArgs<ExtArgs>
    comment?: boolean | user$commentArgs<ExtArgs>
    friendship_friendship_addresseeIdTouser?: boolean | user$friendship_friendship_addresseeIdTouserArgs<ExtArgs>
    friendship_friendship_requesterIdTouser?: boolean | user$friendship_friendship_requesterIdTouserArgs<ExtArgs>
    frontendactivitylog?: boolean | user$frontendactivitylogArgs<ExtArgs>
    groupmember?: boolean | user$groupmemberArgs<ExtArgs>
    groupmessage?: boolean | user$groupmessageArgs<ExtArgs>
    ministryjoinrequest?: boolean | user$ministryjoinrequestArgs<ExtArgs>
    notification?: boolean | user$notificationArgs<ExtArgs>
    prayer?: boolean | user$prayerArgs<ExtArgs>
    prayerrequest?: boolean | user$prayerrequestArgs<ExtArgs>
    testimonial?: boolean | user$testimonialArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type userSelectScalar = {
    password?: boolean
    passwordHash?: boolean
    id?: boolean
    username?: boolean
    fullName?: boolean
    email?: boolean
    countryCode?: boolean
    phone?: boolean
    role?: boolean
    profileImageUrl?: boolean
    coverPhotoUrl?: boolean
    bio?: boolean
    hometown?: boolean
    currentCity?: boolean
    work?: boolean
    education?: boolean
    relationshipStatus?: boolean
    interests?: boolean
    favoriteScripture?: boolean
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: boolean
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: boolean
    groupInvitePrivacy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminactionlog?: boolean | user$adminactionlogArgs<ExtArgs>
    churchmember?: boolean | user$churchmemberArgs<ExtArgs>
    comment?: boolean | user$commentArgs<ExtArgs>
    friendship_friendship_addresseeIdTouser?: boolean | user$friendship_friendship_addresseeIdTouserArgs<ExtArgs>
    friendship_friendship_requesterIdTouser?: boolean | user$friendship_friendship_requesterIdTouserArgs<ExtArgs>
    frontendactivitylog?: boolean | user$frontendactivitylogArgs<ExtArgs>
    groupmember?: boolean | user$groupmemberArgs<ExtArgs>
    groupmessage?: boolean | user$groupmessageArgs<ExtArgs>
    ministryjoinrequest?: boolean | user$ministryjoinrequestArgs<ExtArgs>
    notification?: boolean | user$notificationArgs<ExtArgs>
    prayer?: boolean | user$prayerArgs<ExtArgs>
    prayerrequest?: boolean | user$prayerrequestArgs<ExtArgs>
    testimonial?: boolean | user$testimonialArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      adminactionlog: Prisma.$adminactionlogPayload<ExtArgs>[]
      churchmember: Prisma.$churchmemberPayload<ExtArgs> | null
      comment: Prisma.$commentPayload<ExtArgs>[]
      friendship_friendship_addresseeIdTouser: Prisma.$friendshipPayload<ExtArgs>[]
      friendship_friendship_requesterIdTouser: Prisma.$friendshipPayload<ExtArgs>[]
      frontendactivitylog: Prisma.$frontendactivitylogPayload<ExtArgs>[]
      groupmember: Prisma.$groupmemberPayload<ExtArgs>[]
      groupmessage: Prisma.$groupmessagePayload<ExtArgs>[]
      ministryjoinrequest: Prisma.$ministryjoinrequestPayload<ExtArgs>[]
      notification: Prisma.$notificationPayload<ExtArgs>[]
      prayer: Prisma.$prayerPayload<ExtArgs>[]
      prayerrequest: Prisma.$prayerrequestPayload<ExtArgs>[]
      testimonial: Prisma.$testimonialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      password: string
      passwordHash: string | null
      id: string
      username: string
      fullName: string
      email: string
      countryCode: string | null
      phone: string | null
      role: $Enums.user_role
      profileImageUrl: string | null
      coverPhotoUrl: string | null
      bio: string | null
      hometown: string | null
      currentCity: string | null
      work: string | null
      education: string | null
      relationshipStatus: $Enums.user_relationshipStatus | null
      interests: string | null
      favoriteScripture: string | null
      receiveContentUpdateNotifications: boolean
      receivePrayerRequestNotifications: boolean
      receiveTestimonialNotifications: boolean
      receiveFriendActivityNotifications: boolean
      friendsListPrivacy: $Enums.user_friendsListPrivacy
      profileInSearchPrivacy: boolean
      friendRequestPrivacy: $Enums.user_friendRequestPrivacy
      groupInvitePrivacy: $Enums.user_groupInvitePrivacy
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `password`
     * const userWithPasswordOnly = await prisma.user.findMany({ select: { password: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adminactionlog<T extends user$adminactionlogArgs<ExtArgs> = {}>(args?: Subset<T, user$adminactionlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminactionlogPayload<ExtArgs>, T, "findMany"> | Null>
    churchmember<T extends user$churchmemberArgs<ExtArgs> = {}>(args?: Subset<T, user$churchmemberArgs<ExtArgs>>): Prisma__churchmemberClient<$Result.GetResult<Prisma.$churchmemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends user$commentArgs<ExtArgs> = {}>(args?: Subset<T, user$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany"> | Null>
    friendship_friendship_addresseeIdTouser<T extends user$friendship_friendship_addresseeIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$friendship_friendship_addresseeIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany"> | Null>
    friendship_friendship_requesterIdTouser<T extends user$friendship_friendship_requesterIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$friendship_friendship_requesterIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany"> | Null>
    frontendactivitylog<T extends user$frontendactivitylogArgs<ExtArgs> = {}>(args?: Subset<T, user$frontendactivitylogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$frontendactivitylogPayload<ExtArgs>, T, "findMany"> | Null>
    groupmember<T extends user$groupmemberArgs<ExtArgs> = {}>(args?: Subset<T, user$groupmemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmemberPayload<ExtArgs>, T, "findMany"> | Null>
    groupmessage<T extends user$groupmessageArgs<ExtArgs> = {}>(args?: Subset<T, user$groupmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmessagePayload<ExtArgs>, T, "findMany"> | Null>
    ministryjoinrequest<T extends user$ministryjoinrequestArgs<ExtArgs> = {}>(args?: Subset<T, user$ministryjoinrequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ministryjoinrequestPayload<ExtArgs>, T, "findMany"> | Null>
    notification<T extends user$notificationArgs<ExtArgs> = {}>(args?: Subset<T, user$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany"> | Null>
    prayer<T extends user$prayerArgs<ExtArgs> = {}>(args?: Subset<T, user$prayerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prayerPayload<ExtArgs>, T, "findMany"> | Null>
    prayerrequest<T extends user$prayerrequestArgs<ExtArgs> = {}>(args?: Subset<T, user$prayerrequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prayerrequestPayload<ExtArgs>, T, "findMany"> | Null>
    testimonial<T extends user$testimonialArgs<ExtArgs> = {}>(args?: Subset<T, user$testimonialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testimonialPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly password: FieldRef<"user", 'String'>
    readonly passwordHash: FieldRef<"user", 'String'>
    readonly id: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly fullName: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly countryCode: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'user_role'>
    readonly profileImageUrl: FieldRef<"user", 'String'>
    readonly coverPhotoUrl: FieldRef<"user", 'String'>
    readonly bio: FieldRef<"user", 'String'>
    readonly hometown: FieldRef<"user", 'String'>
    readonly currentCity: FieldRef<"user", 'String'>
    readonly work: FieldRef<"user", 'String'>
    readonly education: FieldRef<"user", 'String'>
    readonly relationshipStatus: FieldRef<"user", 'user_relationshipStatus'>
    readonly interests: FieldRef<"user", 'String'>
    readonly favoriteScripture: FieldRef<"user", 'String'>
    readonly receiveContentUpdateNotifications: FieldRef<"user", 'Boolean'>
    readonly receivePrayerRequestNotifications: FieldRef<"user", 'Boolean'>
    readonly receiveTestimonialNotifications: FieldRef<"user", 'Boolean'>
    readonly receiveFriendActivityNotifications: FieldRef<"user", 'Boolean'>
    readonly friendsListPrivacy: FieldRef<"user", 'user_friendsListPrivacy'>
    readonly profileInSearchPrivacy: FieldRef<"user", 'Boolean'>
    readonly friendRequestPrivacy: FieldRef<"user", 'user_friendRequestPrivacy'>
    readonly groupInvitePrivacy: FieldRef<"user", 'user_groupInvitePrivacy'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }

  /**
   * user.adminactionlog
   */
  export type user$adminactionlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the adminactionlog
     */
    select?: adminactionlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminactionlogInclude<ExtArgs> | null
    where?: adminactionlogWhereInput
    orderBy?: adminactionlogOrderByWithRelationInput | adminactionlogOrderByWithRelationInput[]
    cursor?: adminactionlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminactionlogScalarFieldEnum | AdminactionlogScalarFieldEnum[]
  }

  /**
   * user.churchmember
   */
  export type user$churchmemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the churchmember
     */
    select?: churchmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: churchmemberInclude<ExtArgs> | null
    where?: churchmemberWhereInput
  }

  /**
   * user.comment
   */
  export type user$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * user.friendship_friendship_addresseeIdTouser
   */
  export type user$friendship_friendship_addresseeIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    cursor?: friendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * user.friendship_friendship_requesterIdTouser
   */
  export type user$friendship_friendship_requesterIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    cursor?: friendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * user.frontendactivitylog
   */
  export type user$frontendactivitylogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the frontendactivitylog
     */
    select?: frontendactivitylogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: frontendactivitylogInclude<ExtArgs> | null
    where?: frontendactivitylogWhereInput
    orderBy?: frontendactivitylogOrderByWithRelationInput | frontendactivitylogOrderByWithRelationInput[]
    cursor?: frontendactivitylogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FrontendactivitylogScalarFieldEnum | FrontendactivitylogScalarFieldEnum[]
  }

  /**
   * user.groupmember
   */
  export type user$groupmemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmember
     */
    select?: groupmemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmemberInclude<ExtArgs> | null
    where?: groupmemberWhereInput
    orderBy?: groupmemberOrderByWithRelationInput | groupmemberOrderByWithRelationInput[]
    cursor?: groupmemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupmemberScalarFieldEnum | GroupmemberScalarFieldEnum[]
  }

  /**
   * user.groupmessage
   */
  export type user$groupmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmessage
     */
    select?: groupmessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmessageInclude<ExtArgs> | null
    where?: groupmessageWhereInput
    orderBy?: groupmessageOrderByWithRelationInput | groupmessageOrderByWithRelationInput[]
    cursor?: groupmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupmessageScalarFieldEnum | GroupmessageScalarFieldEnum[]
  }

  /**
   * user.ministryjoinrequest
   */
  export type user$ministryjoinrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ministryjoinrequest
     */
    select?: ministryjoinrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ministryjoinrequestInclude<ExtArgs> | null
    where?: ministryjoinrequestWhereInput
    orderBy?: ministryjoinrequestOrderByWithRelationInput | ministryjoinrequestOrderByWithRelationInput[]
    cursor?: ministryjoinrequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinistryjoinrequestScalarFieldEnum | MinistryjoinrequestScalarFieldEnum[]
  }

  /**
   * user.notification
   */
  export type user$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * user.prayer
   */
  export type user$prayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayer
     */
    select?: prayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerInclude<ExtArgs> | null
    where?: prayerWhereInput
    orderBy?: prayerOrderByWithRelationInput | prayerOrderByWithRelationInput[]
    cursor?: prayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrayerScalarFieldEnum | PrayerScalarFieldEnum[]
  }

  /**
   * user.prayerrequest
   */
  export type user$prayerrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prayerrequest
     */
    select?: prayerrequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: prayerrequestInclude<ExtArgs> | null
    where?: prayerrequestWhereInput
    orderBy?: prayerrequestOrderByWithRelationInput | prayerrequestOrderByWithRelationInput[]
    cursor?: prayerrequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrayerrequestScalarFieldEnum | PrayerrequestScalarFieldEnum[]
  }

  /**
   * user.testimonial
   */
  export type user$testimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testimonial
     */
    select?: testimonialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: testimonialInclude<ExtArgs> | null
    where?: testimonialWhereInput
    orderBy?: testimonialOrderByWithRelationInput | testimonialOrderByWithRelationInput[]
    cursor?: testimonialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestimonialScalarFieldEnum | TestimonialScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AboutsectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    imageUrl: 'imageUrl',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    isCoreSection: 'isCoreSection',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt'
  };

  export type AboutsectionScalarFieldEnum = (typeof AboutsectionScalarFieldEnum)[keyof typeof AboutsectionScalarFieldEnum]


  export const AdminactionlogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    adminId: 'adminId',
    adminName: 'adminName',
    action: 'action',
    targetId: 'targetId',
    details: 'details'
  };

  export type AdminactionlogScalarFieldEnum = (typeof AdminactionlogScalarFieldEnum)[keyof typeof AdminactionlogScalarFieldEnum]


  export const AdvertisementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    adType: 'adType',
    imageUrl: 'imageUrl',
    videoUrl: 'videoUrl',
    linkUrl: 'linkUrl',
    altText: 'altText',
    placements: 'placements',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    displayOrder: 'displayOrder',
    adSizeKey: 'adSizeKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName'
  };

  export type AdvertisementScalarFieldEnum = (typeof AdvertisementScalarFieldEnum)[keyof typeof AdvertisementScalarFieldEnum]


  export const BlogpostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    linkPath: 'linkPath',
    category: 'category',
    date: 'date',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    likes: 'likes',
    audioUrl: 'audioUrl',
    mediaUrls: 'mediaUrls',
    location: 'location',
    taggedFriends: 'taggedFriends',
    feelingActivity: 'feelingActivity',
    backgroundTheme: 'backgroundTheme',
    videoUrl: 'videoUrl'
  };

  export type BlogpostScalarFieldEnum = (typeof BlogpostScalarFieldEnum)[keyof typeof BlogpostScalarFieldEnum]


  export const BranchchurchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    pastorName: 'pastorName',
    phone: 'phone',
    email: 'email',
    serviceTimes: 'serviceTimes',
    mapEmbedUrl: 'mapEmbedUrl',
    imageUrl: 'imageUrl',
    description: 'description',
    establishedDate: 'establishedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName'
  };

  export type BranchchurchScalarFieldEnum = (typeof BranchchurchScalarFieldEnum)[keyof typeof BranchchurchScalarFieldEnum]


  export const ChurchmemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    fullName: 'fullName',
    username: 'username',
    contactPhone: 'contactPhone',
    contactEmail: 'contactEmail',
    address: 'address',
    memberSince: 'memberSince',
    dateOfBirth: 'dateOfBirth',
    baptismDate: 'baptismDate',
    familyMembers: 'familyMembers',
    notes: 'notes',
    isActiveMember: 'isActiveMember',
    profileImageUrl: 'profileImageUrl',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChurchmemberScalarFieldEnum = (typeof ChurchmemberScalarFieldEnum)[keyof typeof ChurchmemberScalarFieldEnum]


  export const CollectionrecordScalarFieldEnum: {
    id: 'id',
    collectorName: 'collectorName',
    collectionDate: 'collectionDate',
    amount: 'amount',
    purpose: 'purpose',
    source: 'source',
    notes: 'notes',
    recordedAt: 'recordedAt',
    recordedByOwnerId: 'recordedByOwnerId',
    recordedByOwnerName: 'recordedByOwnerName',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    countedBy: 'countedBy',
    isDeposited: 'isDeposited',
    depositDate: 'depositDate',
    bankDepositReference: 'bankDepositReference'
  };

  export type CollectionrecordScalarFieldEnum = (typeof CollectionrecordScalarFieldEnum)[keyof typeof CollectionrecordScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userProfileImageUrl: 'userProfileImageUrl',
    text: 'text',
    timestamp: 'timestamp',
    editedAt: 'editedAt',
    sermonId: 'sermonId',
    eventId: 'eventId',
    blogPostId: 'blogPostId',
    newsItemId: 'newsItemId',
    historyChapterId: 'historyChapterId',
    prayerRequestId: 'prayerRequestId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ContactmessageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    submittedAt: 'submittedAt',
    status: 'status',
    repliedAt: 'repliedAt',
    replyNote: 'replyNote'
  };

  export type ContactmessageScalarFieldEnum = (typeof ContactmessageScalarFieldEnum)[keyof typeof ContactmessageScalarFieldEnum]


  export const DecisionlogScalarFieldEnum: {
    id: 'id',
    decisionDate: 'decisionDate',
    title: 'title',
    description: 'description',
    madeBy: 'madeBy',
    status: 'status',
    followUpActions: 'followUpActions',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DecisionlogScalarFieldEnum = (typeof DecisionlogScalarFieldEnum)[keyof typeof DecisionlogScalarFieldEnum]


  export const DirectmediaitemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    mediaType: 'mediaType',
    category: 'category',
    tags: 'tags',
    uploadDate: 'uploadDate',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    updatedAt: 'updatedAt'
  };

  export type DirectmediaitemScalarFieldEnum = (typeof DirectmediaitemScalarFieldEnum)[keyof typeof DirectmediaitemScalarFieldEnum]


  export const DonatepagecontentScalarFieldEnum: {
    id: 'id',
    headerTitle: 'headerTitle',
    headerSubtitle: 'headerSubtitle',
    headerImageUrl: 'headerImageUrl',
    localDonationsTitle: 'localDonationsTitle',
    bankName: 'bankName',
    accountName: 'accountName',
    accountNumber: 'accountNumber',
    branch: 'branch',
    bankQrImageUrl: 'bankQrImageUrl',
    eSewaId: 'eSewaId',
    eSewaQrImageUrl: 'eSewaQrImageUrl',
    localDonationsNote: 'localDonationsNote',
    internationalDonationsTitle: 'internationalDonationsTitle',
    internationalDonationsContent: 'internationalDonationsContent',
    internationalDonationsContactEmail: 'internationalDonationsContactEmail',
    internationalQrImageUrl: 'internationalQrImageUrl',
    receiptVerses: 'receiptVerses',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName'
  };

  export type DonatepagecontentScalarFieldEnum = (typeof DonatepagecontentScalarFieldEnum)[keyof typeof DonatepagecontentScalarFieldEnum]


  export const DonationrecordScalarFieldEnum: {
    id: 'id',
    donorName: 'donorName',
    donorEmail: 'donorEmail',
    donorPhone: 'donorPhone',
    amount: 'amount',
    purpose: 'purpose',
    donationDate: 'donationDate',
    transactionTimestamp: 'transactionTimestamp',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentMethod: 'paymentMethod',
    transactionReference: 'transactionReference',
    notes: 'notes',
    isReceiptSent: 'isReceiptSent'
  };

  export type DonationrecordScalarFieldEnum = (typeof DonationrecordScalarFieldEnum)[keyof typeof DonationrecordScalarFieldEnum]


  export const DonordetailScalarFieldEnum: {
    id: 'id',
    donorName: 'donorName',
    amount: 'amount',
    address: 'address',
    contact: 'contact',
    collectionRecordId: 'collectionRecordId'
  };

  export type DonordetailScalarFieldEnum = (typeof DonordetailScalarFieldEnum)[keyof typeof DonordetailScalarFieldEnum]


  export const EventitemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    linkPath: 'linkPath',
    category: 'category',
    date: 'date',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    location: 'location',
    time: 'time',
    expectations: 'expectations',
    guests: 'guests',
    contactPerson: 'contactPerson',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    registrationLink: 'registrationLink',
    capacity: 'capacity',
    isFeeRequired: 'isFeeRequired',
    feeAmount: 'feeAmount',
    videoUrl: 'videoUrl',
    audioUrl: 'audioUrl',
    likes: 'likes'
  };

  export type EventitemScalarFieldEnum = (typeof EventitemScalarFieldEnum)[keyof typeof EventitemScalarFieldEnum]


  export const ExpenserecordScalarFieldEnum: {
    id: 'id',
    expenseDate: 'expenseDate',
    category: 'category',
    description: 'description',
    amount: 'amount',
    payee: 'payee',
    paymentMethod: 'paymentMethod',
    transactionReference: 'transactionReference',
    receiptUrl: 'receiptUrl',
    approvedBy: 'approvedBy',
    notes: 'notes',
    source: 'source',
    location: 'location',
    status: 'status',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenserecordScalarFieldEnum = (typeof ExpenserecordScalarFieldEnum)[keyof typeof ExpenserecordScalarFieldEnum]


  export const FellowshiprosteritemScalarFieldEnum: {
    id: 'id',
    rosterType: 'rosterType',
    groupNameOrEventTitle: 'groupNameOrEventTitle',
    assignedDate: 'assignedDate',
    timeSlot: 'timeSlot',
    location: 'location',
    contactNumber: 'contactNumber',
    additionalNotesOrProgramDetails: 'additionalNotesOrProgramDetails',
    isTemplate: 'isTemplate',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FellowshiprosteritemScalarFieldEnum = (typeof FellowshiprosteritemScalarFieldEnum)[keyof typeof FellowshiprosteritemScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    requesterId: 'requesterId',
    addresseeId: 'addresseeId',
    status: 'status',
    requestedAt: 'requestedAt',
    updatedAt: 'updatedAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const FrontendactivitylogScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    userId: 'userId',
    description: 'description',
    type: 'type',
    itemId: 'itemId',
    itemType: 'itemType'
  };

  export type FrontendactivitylogScalarFieldEnum = (typeof FrontendactivitylogScalarFieldEnum)[keyof typeof FrontendactivitylogScalarFieldEnum]


  export const GeneratedscheduleitemScalarFieldEnum: {
    id: 'id',
    basedOnRosterItemId: 'basedOnRosterItemId',
    rosterType: 'rosterType',
    groupNameOrEventTitle: 'groupNameOrEventTitle',
    scheduledDate: 'scheduledDate',
    timeSlot: 'timeSlot',
    location: 'location',
    contactNumber: 'contactNumber',
    additionalNotesOrProgramDetails: 'additionalNotesOrProgramDetails',
    generatedAt: 'generatedAt',
    isPublishedAsEvent: 'isPublishedAsEvent',
    publishedEventId: 'publishedEventId',
    adminNotes: 'adminNotes',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GeneratedscheduleitemScalarFieldEnum = (typeof GeneratedscheduleitemScalarFieldEnum)[keyof typeof GeneratedscheduleitemScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    creatorId: 'creatorId',
    groupImageUrl: 'groupImageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    editSettings: 'editSettings',
    sendMessage: 'sendMessage',
    addMembers: 'addMembers',
    approveMembers: 'approveMembers'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const GroupmemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    role: 'role',
    addedAt: 'addedAt'
  };

  export type GroupmemberScalarFieldEnum = (typeof GroupmemberScalarFieldEnum)[keyof typeof GroupmemberScalarFieldEnum]


  export const GroupmessageScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    senderId: 'senderId',
    senderName: 'senderName',
    senderProfileImageUrl: 'senderProfileImageUrl',
    text: 'text',
    mediaUrl: 'mediaUrl',
    mediaType: 'mediaType',
    timestamp: 'timestamp'
  };

  export type GroupmessageScalarFieldEnum = (typeof GroupmessageScalarFieldEnum)[keyof typeof GroupmessageScalarFieldEnum]


  export const HistorychapterScalarFieldEnum: {
    id: 'id',
    chapterNumber: 'chapterNumber',
    title: 'title',
    content: 'content',
    status: 'status',
    imageUrl: 'imageUrl',
    summary: 'summary',
    authorId: 'authorId',
    authorName: 'authorName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastPublishedAt: 'lastPublishedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    likes: 'likes'
  };

  export type HistorychapterScalarFieldEnum = (typeof HistorychapterScalarFieldEnum)[keyof typeof HistorychapterScalarFieldEnum]


  export const HistorymilestoneScalarFieldEnum: {
    id: 'id',
    year: 'year',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName'
  };

  export type HistorymilestoneScalarFieldEnum = (typeof HistorymilestoneScalarFieldEnum)[keyof typeof HistorymilestoneScalarFieldEnum]


  export const HomeslideScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    ctaText: 'ctaText',
    linkPath: 'linkPath',
    order: 'order',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName'
  };

  export type HomeslideScalarFieldEnum = (typeof HomeslideScalarFieldEnum)[keyof typeof HomeslideScalarFieldEnum]


  export const KeypersonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    imageUrl: 'imageUrl',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName'
  };

  export type KeypersonScalarFieldEnum = (typeof KeypersonScalarFieldEnum)[keyof typeof KeypersonScalarFieldEnum]


  export const MeetingdecisionpointScalarFieldEnum: {
    id: 'id',
    description: 'description',
    proposedBy: 'proposedBy',
    status: 'status',
    followUpNotes: 'followUpNotes',
    resolutionDate: 'resolutionDate',
    meetingLogId: 'meetingLogId'
  };

  export type MeetingdecisionpointScalarFieldEnum = (typeof MeetingdecisionpointScalarFieldEnum)[keyof typeof MeetingdecisionpointScalarFieldEnum]


  export const MeetinglogScalarFieldEnum: {
    id: 'id',
    meetingDate: 'meetingDate',
    title: 'title',
    meetingType: 'meetingType',
    attendees: 'attendees',
    agenda: 'agenda',
    minutes: 'minutes',
    actionItems: 'actionItems',
    status: 'status',
    imageUrl: 'imageUrl',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetinglogScalarFieldEnum = (typeof MeetinglogScalarFieldEnum)[keyof typeof MeetinglogScalarFieldEnum]


  export const MinistryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    linkPath: 'linkPath',
    category: 'category',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    leader: 'leader',
    meetingTime: 'meetingTime'
  };

  export type MinistryScalarFieldEnum = (typeof MinistryScalarFieldEnum)[keyof typeof MinistryScalarFieldEnum]


  export const MinistryjoinrequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userEmail: 'userEmail',
    ministryId: 'ministryId',
    ministryName: 'ministryName',
    ministryGuidelines: 'ministryGuidelines',
    requestDate: 'requestDate',
    message: 'message',
    status: 'status',
    processedDate: 'processedDate',
    adminNotes: 'adminNotes'
  };

  export type MinistryjoinrequestScalarFieldEnum = (typeof MinistryjoinrequestScalarFieldEnum)[keyof typeof MinistryjoinrequestScalarFieldEnum]


  export const MonthlythemeimageScalarFieldEnum: {
    id: 'id',
    year: 'year',
    month: 'month',
    imageUrls: 'imageUrls',
    quoteOrCaption: 'quoteOrCaption',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName'
  };

  export type MonthlythemeimageScalarFieldEnum = (typeof MonthlythemeimageScalarFieldEnum)[keyof typeof MonthlythemeimageScalarFieldEnum]


  export const NewsitemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    linkPath: 'linkPath',
    category: 'category',
    date: 'date',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    videoUrl: 'videoUrl',
    audioUrl: 'audioUrl',
    likes: 'likes'
  };

  export type NewsitemScalarFieldEnum = (typeof NewsitemScalarFieldEnum)[keyof typeof NewsitemScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    targetUserId: 'targetUserId',
    message: 'message',
    link: 'link',
    timestamp: 'timestamp',
    read: 'read',
    type: 'type'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PrayerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    timestamp: 'timestamp',
    prayerRequestId: 'prayerRequestId'
  };

  export type PrayerScalarFieldEnum = (typeof PrayerScalarFieldEnum)[keyof typeof PrayerScalarFieldEnum]


  export const PrayerrequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userProfileImageUrl: 'userProfileImageUrl',
    title: 'title',
    requestText: 'requestText',
    visibility: 'visibility',
    category: 'category',
    status: 'status',
    submittedAt: 'submittedAt',
    lastPrayedAt: 'lastPrayedAt',
    adminNotes: 'adminNotes',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mediaUrls: 'mediaUrls',
    location: 'location',
    taggedFriends: 'taggedFriends',
    feelingActivity: 'feelingActivity',
    backgroundTheme: 'backgroundTheme'
  };

  export type PrayerrequestScalarFieldEnum = (typeof PrayerrequestScalarFieldEnum)[keyof typeof PrayerrequestScalarFieldEnum]


  export const ResponsibilityScalarFieldEnum: {
    id: 'id',
    role: 'role',
    assignedTo: 'assignedTo',
    rosterItemId: 'rosterItemId',
    generatedScheduleId: 'generatedScheduleId'
  };

  export type ResponsibilityScalarFieldEnum = (typeof ResponsibilityScalarFieldEnum)[keyof typeof ResponsibilityScalarFieldEnum]


  export const SermonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    linkPath: 'linkPath',
    category: 'category',
    date: 'date',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    speaker: 'speaker',
    scripture: 'scripture',
    videoUrl: 'videoUrl',
    audioUrl: 'audioUrl',
    fullContent: 'fullContent',
    likes: 'likes'
  };

  export type SermonScalarFieldEnum = (typeof SermonScalarFieldEnum)[keyof typeof SermonScalarFieldEnum]


  export const TestimonialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userName: 'userName',
    userProfileImageUrl: 'userProfileImageUrl',
    title: 'title',
    contentText: 'contentText',
    visibility: 'visibility',
    submittedAt: 'submittedAt',
    postedByOwnerId: 'postedByOwnerId',
    postedByOwnerName: 'postedByOwnerName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    mediaUrls: 'mediaUrls',
    location: 'location',
    taggedFriends: 'taggedFriends',
    feelingActivity: 'feelingActivity',
    backgroundTheme: 'backgroundTheme'
  };

  export type TestimonialScalarFieldEnum = (typeof TestimonialScalarFieldEnum)[keyof typeof TestimonialScalarFieldEnum]


  export const UserScalarFieldEnum: {
    password: 'password',
    passwordHash: 'passwordHash',
    id: 'id',
    username: 'username',
    fullName: 'fullName',
    email: 'email',
    countryCode: 'countryCode',
    phone: 'phone',
    role: 'role',
    profileImageUrl: 'profileImageUrl',
    coverPhotoUrl: 'coverPhotoUrl',
    bio: 'bio',
    hometown: 'hometown',
    currentCity: 'currentCity',
    work: 'work',
    education: 'education',
    relationshipStatus: 'relationshipStatus',
    interests: 'interests',
    favoriteScripture: 'favoriteScripture',
    receiveContentUpdateNotifications: 'receiveContentUpdateNotifications',
    receivePrayerRequestNotifications: 'receivePrayerRequestNotifications',
    receiveTestimonialNotifications: 'receiveTestimonialNotifications',
    receiveFriendActivityNotifications: 'receiveFriendActivityNotifications',
    friendsListPrivacy: 'friendsListPrivacy',
    profileInSearchPrivacy: 'profileInSearchPrivacy',
    friendRequestPrivacy: 'friendRequestPrivacy',
    groupInvitePrivacy: 'groupInvitePrivacy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'advertisement_adType'
   */
  export type Enumadvertisement_adTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'advertisement_adType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'blogpost_category'
   */
  export type Enumblogpost_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'blogpost_category'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'collectionrecord_purpose'
   */
  export type Enumcollectionrecord_purposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'collectionrecord_purpose'>
    


  /**
   * Reference to a field of type 'contactmessage_status'
   */
  export type Enumcontactmessage_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'contactmessage_status'>
    


  /**
   * Reference to a field of type 'decisionlog_status'
   */
  export type Enumdecisionlog_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'decisionlog_status'>
    


  /**
   * Reference to a field of type 'directmediaitem_mediaType'
   */
  export type Enumdirectmediaitem_mediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'directmediaitem_mediaType'>
    


  /**
   * Reference to a field of type 'donationrecord_purpose'
   */
  export type Enumdonationrecord_purposeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'donationrecord_purpose'>
    


  /**
   * Reference to a field of type 'donationrecord_paymentMethod'
   */
  export type Enumdonationrecord_paymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'donationrecord_paymentMethod'>
    


  /**
   * Reference to a field of type 'eventitem_category'
   */
  export type Enumeventitem_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'eventitem_category'>
    


  /**
   * Reference to a field of type 'expenserecord_category'
   */
  export type Enumexpenserecord_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'expenserecord_category'>
    


  /**
   * Reference to a field of type 'expenserecord_paymentMethod'
   */
  export type Enumexpenserecord_paymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'expenserecord_paymentMethod'>
    


  /**
   * Reference to a field of type 'expenserecord_status'
   */
  export type Enumexpenserecord_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'expenserecord_status'>
    


  /**
   * Reference to a field of type 'fellowshiprosteritem_rosterType'
   */
  export type Enumfellowshiprosteritem_rosterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'fellowshiprosteritem_rosterType'>
    


  /**
   * Reference to a field of type 'friendship_status'
   */
  export type Enumfriendship_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'friendship_status'>
    


  /**
   * Reference to a field of type 'generatedscheduleitem_rosterType'
   */
  export type Enumgeneratedscheduleitem_rosterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'generatedscheduleitem_rosterType'>
    


  /**
   * Reference to a field of type 'group_editSettings'
   */
  export type Enumgroup_editSettingsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'group_editSettings'>
    


  /**
   * Reference to a field of type 'group_sendMessage'
   */
  export type Enumgroup_sendMessageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'group_sendMessage'>
    


  /**
   * Reference to a field of type 'group_addMembers'
   */
  export type Enumgroup_addMembersFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'group_addMembers'>
    


  /**
   * Reference to a field of type 'group_approveMembers'
   */
  export type Enumgroup_approveMembersFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'group_approveMembers'>
    


  /**
   * Reference to a field of type 'groupmember_role'
   */
  export type Enumgroupmember_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'groupmember_role'>
    


  /**
   * Reference to a field of type 'groupmessage_mediaType'
   */
  export type Enumgroupmessage_mediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'groupmessage_mediaType'>
    


  /**
   * Reference to a field of type 'historychapter_status'
   */
  export type Enumhistorychapter_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'historychapter_status'>
    


  /**
   * Reference to a field of type 'meetingdecisionpoint_status'
   */
  export type Enummeetingdecisionpoint_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meetingdecisionpoint_status'>
    


  /**
   * Reference to a field of type 'meetinglog_meetingType'
   */
  export type Enummeetinglog_meetingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meetinglog_meetingType'>
    


  /**
   * Reference to a field of type 'meetinglog_status'
   */
  export type Enummeetinglog_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'meetinglog_status'>
    


  /**
   * Reference to a field of type 'ministry_category'
   */
  export type Enumministry_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ministry_category'>
    


  /**
   * Reference to a field of type 'ministryjoinrequest_status'
   */
  export type Enumministryjoinrequest_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ministryjoinrequest_status'>
    


  /**
   * Reference to a field of type 'newsitem_category'
   */
  export type Enumnewsitem_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'newsitem_category'>
    


  /**
   * Reference to a field of type 'notification_type'
   */
  export type Enumnotification_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'notification_type'>
    


  /**
   * Reference to a field of type 'prayerrequest_visibility'
   */
  export type Enumprayerrequest_visibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'prayerrequest_visibility'>
    


  /**
   * Reference to a field of type 'prayerrequest_category'
   */
  export type Enumprayerrequest_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'prayerrequest_category'>
    


  /**
   * Reference to a field of type 'prayerrequest_status'
   */
  export type Enumprayerrequest_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'prayerrequest_status'>
    


  /**
   * Reference to a field of type 'sermon_category'
   */
  export type Enumsermon_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'sermon_category'>
    


  /**
   * Reference to a field of type 'testimonial_visibility'
   */
  export type Enumtestimonial_visibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'testimonial_visibility'>
    


  /**
   * Reference to a field of type 'user_role'
   */
  export type Enumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role'>
    


  /**
   * Reference to a field of type 'user_relationshipStatus'
   */
  export type Enumuser_relationshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_relationshipStatus'>
    


  /**
   * Reference to a field of type 'user_friendsListPrivacy'
   */
  export type Enumuser_friendsListPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_friendsListPrivacy'>
    


  /**
   * Reference to a field of type 'user_friendRequestPrivacy'
   */
  export type Enumuser_friendRequestPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_friendRequestPrivacy'>
    


  /**
   * Reference to a field of type 'user_groupInvitePrivacy'
   */
  export type Enumuser_groupInvitePrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_groupInvitePrivacy'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type aboutsectionWhereInput = {
    AND?: aboutsectionWhereInput | aboutsectionWhereInput[]
    OR?: aboutsectionWhereInput[]
    NOT?: aboutsectionWhereInput | aboutsectionWhereInput[]
    id?: StringFilter<"aboutsection"> | string
    title?: StringFilter<"aboutsection"> | string
    content?: StringFilter<"aboutsection"> | string
    imageUrl?: StringNullableFilter<"aboutsection"> | string | null
    updatedAt?: DateTimeFilter<"aboutsection"> | Date | string
    postedByOwnerId?: StringNullableFilter<"aboutsection"> | string | null
    postedByOwnerName?: StringNullableFilter<"aboutsection"> | string | null
    isCoreSection?: BoolFilter<"aboutsection"> | boolean
    displayOrder?: IntFilter<"aboutsection"> | number
    createdAt?: DateTimeFilter<"aboutsection"> | Date | string
  }

  export type aboutsectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    isCoreSection?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type aboutsectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: aboutsectionWhereInput | aboutsectionWhereInput[]
    OR?: aboutsectionWhereInput[]
    NOT?: aboutsectionWhereInput | aboutsectionWhereInput[]
    title?: StringFilter<"aboutsection"> | string
    content?: StringFilter<"aboutsection"> | string
    imageUrl?: StringNullableFilter<"aboutsection"> | string | null
    updatedAt?: DateTimeFilter<"aboutsection"> | Date | string
    postedByOwnerId?: StringNullableFilter<"aboutsection"> | string | null
    postedByOwnerName?: StringNullableFilter<"aboutsection"> | string | null
    isCoreSection?: BoolFilter<"aboutsection"> | boolean
    displayOrder?: IntFilter<"aboutsection"> | number
    createdAt?: DateTimeFilter<"aboutsection"> | Date | string
  }, "id">

  export type aboutsectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    isCoreSection?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    _count?: aboutsectionCountOrderByAggregateInput
    _avg?: aboutsectionAvgOrderByAggregateInput
    _max?: aboutsectionMaxOrderByAggregateInput
    _min?: aboutsectionMinOrderByAggregateInput
    _sum?: aboutsectionSumOrderByAggregateInput
  }

  export type aboutsectionScalarWhereWithAggregatesInput = {
    AND?: aboutsectionScalarWhereWithAggregatesInput | aboutsectionScalarWhereWithAggregatesInput[]
    OR?: aboutsectionScalarWhereWithAggregatesInput[]
    NOT?: aboutsectionScalarWhereWithAggregatesInput | aboutsectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"aboutsection"> | string
    title?: StringWithAggregatesFilter<"aboutsection"> | string
    content?: StringWithAggregatesFilter<"aboutsection"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"aboutsection"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"aboutsection"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"aboutsection"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"aboutsection"> | string | null
    isCoreSection?: BoolWithAggregatesFilter<"aboutsection"> | boolean
    displayOrder?: IntWithAggregatesFilter<"aboutsection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"aboutsection"> | Date | string
  }

  export type adminactionlogWhereInput = {
    AND?: adminactionlogWhereInput | adminactionlogWhereInput[]
    OR?: adminactionlogWhereInput[]
    NOT?: adminactionlogWhereInput | adminactionlogWhereInput[]
    id?: StringFilter<"adminactionlog"> | string
    timestamp?: DateTimeFilter<"adminactionlog"> | Date | string
    adminId?: StringFilter<"adminactionlog"> | string
    adminName?: StringFilter<"adminactionlog"> | string
    action?: StringFilter<"adminactionlog"> | string
    targetId?: StringNullableFilter<"adminactionlog"> | string | null
    details?: StringNullableFilter<"adminactionlog"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type adminactionlogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    adminId?: SortOrder
    adminName?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type adminactionlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: adminactionlogWhereInput | adminactionlogWhereInput[]
    OR?: adminactionlogWhereInput[]
    NOT?: adminactionlogWhereInput | adminactionlogWhereInput[]
    timestamp?: DateTimeFilter<"adminactionlog"> | Date | string
    adminId?: StringFilter<"adminactionlog"> | string
    adminName?: StringFilter<"adminactionlog"> | string
    action?: StringFilter<"adminactionlog"> | string
    targetId?: StringNullableFilter<"adminactionlog"> | string | null
    details?: StringNullableFilter<"adminactionlog"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type adminactionlogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    adminId?: SortOrder
    adminName?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    _count?: adminactionlogCountOrderByAggregateInput
    _max?: adminactionlogMaxOrderByAggregateInput
    _min?: adminactionlogMinOrderByAggregateInput
  }

  export type adminactionlogScalarWhereWithAggregatesInput = {
    AND?: adminactionlogScalarWhereWithAggregatesInput | adminactionlogScalarWhereWithAggregatesInput[]
    OR?: adminactionlogScalarWhereWithAggregatesInput[]
    NOT?: adminactionlogScalarWhereWithAggregatesInput | adminactionlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"adminactionlog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"adminactionlog"> | Date | string
    adminId?: StringWithAggregatesFilter<"adminactionlog"> | string
    adminName?: StringWithAggregatesFilter<"adminactionlog"> | string
    action?: StringWithAggregatesFilter<"adminactionlog"> | string
    targetId?: StringNullableWithAggregatesFilter<"adminactionlog"> | string | null
    details?: StringNullableWithAggregatesFilter<"adminactionlog"> | string | null
  }

  export type advertisementWhereInput = {
    AND?: advertisementWhereInput | advertisementWhereInput[]
    OR?: advertisementWhereInput[]
    NOT?: advertisementWhereInput | advertisementWhereInput[]
    id?: StringFilter<"advertisement"> | string
    name?: StringFilter<"advertisement"> | string
    adType?: Enumadvertisement_adTypeFilter<"advertisement"> | $Enums.advertisement_adType
    imageUrl?: StringNullableFilter<"advertisement"> | string | null
    videoUrl?: StringNullableFilter<"advertisement"> | string | null
    linkUrl?: StringNullableFilter<"advertisement"> | string | null
    altText?: StringNullableFilter<"advertisement"> | string | null
    placements?: JsonFilter<"advertisement">
    startDate?: DateTimeNullableFilter<"advertisement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"advertisement"> | Date | string | null
    isActive?: BoolFilter<"advertisement"> | boolean
    displayOrder?: IntNullableFilter<"advertisement"> | number | null
    adSizeKey?: StringNullableFilter<"advertisement"> | string | null
    createdAt?: DateTimeFilter<"advertisement"> | Date | string
    updatedAt?: DateTimeFilter<"advertisement"> | Date | string
    postedByOwnerId?: StringNullableFilter<"advertisement"> | string | null
    postedByOwnerName?: StringNullableFilter<"advertisement"> | string | null
  }

  export type advertisementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    adType?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    altText?: SortOrderInput | SortOrder
    placements?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    adSizeKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
  }

  export type advertisementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: advertisementWhereInput | advertisementWhereInput[]
    OR?: advertisementWhereInput[]
    NOT?: advertisementWhereInput | advertisementWhereInput[]
    name?: StringFilter<"advertisement"> | string
    adType?: Enumadvertisement_adTypeFilter<"advertisement"> | $Enums.advertisement_adType
    imageUrl?: StringNullableFilter<"advertisement"> | string | null
    videoUrl?: StringNullableFilter<"advertisement"> | string | null
    linkUrl?: StringNullableFilter<"advertisement"> | string | null
    altText?: StringNullableFilter<"advertisement"> | string | null
    placements?: JsonFilter<"advertisement">
    startDate?: DateTimeNullableFilter<"advertisement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"advertisement"> | Date | string | null
    isActive?: BoolFilter<"advertisement"> | boolean
    displayOrder?: IntNullableFilter<"advertisement"> | number | null
    adSizeKey?: StringNullableFilter<"advertisement"> | string | null
    createdAt?: DateTimeFilter<"advertisement"> | Date | string
    updatedAt?: DateTimeFilter<"advertisement"> | Date | string
    postedByOwnerId?: StringNullableFilter<"advertisement"> | string | null
    postedByOwnerName?: StringNullableFilter<"advertisement"> | string | null
  }, "id">

  export type advertisementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    adType?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    altText?: SortOrderInput | SortOrder
    placements?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrderInput | SortOrder
    adSizeKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    _count?: advertisementCountOrderByAggregateInput
    _avg?: advertisementAvgOrderByAggregateInput
    _max?: advertisementMaxOrderByAggregateInput
    _min?: advertisementMinOrderByAggregateInput
    _sum?: advertisementSumOrderByAggregateInput
  }

  export type advertisementScalarWhereWithAggregatesInput = {
    AND?: advertisementScalarWhereWithAggregatesInput | advertisementScalarWhereWithAggregatesInput[]
    OR?: advertisementScalarWhereWithAggregatesInput[]
    NOT?: advertisementScalarWhereWithAggregatesInput | advertisementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"advertisement"> | string
    name?: StringWithAggregatesFilter<"advertisement"> | string
    adType?: Enumadvertisement_adTypeWithAggregatesFilter<"advertisement"> | $Enums.advertisement_adType
    imageUrl?: StringNullableWithAggregatesFilter<"advertisement"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"advertisement"> | string | null
    linkUrl?: StringNullableWithAggregatesFilter<"advertisement"> | string | null
    altText?: StringNullableWithAggregatesFilter<"advertisement"> | string | null
    placements?: JsonWithAggregatesFilter<"advertisement">
    startDate?: DateTimeNullableWithAggregatesFilter<"advertisement"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"advertisement"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"advertisement"> | boolean
    displayOrder?: IntNullableWithAggregatesFilter<"advertisement"> | number | null
    adSizeKey?: StringNullableWithAggregatesFilter<"advertisement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"advertisement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"advertisement"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"advertisement"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"advertisement"> | string | null
  }

  export type blogpostWhereInput = {
    AND?: blogpostWhereInput | blogpostWhereInput[]
    OR?: blogpostWhereInput[]
    NOT?: blogpostWhereInput | blogpostWhereInput[]
    id?: StringFilter<"blogpost"> | string
    title?: StringFilter<"blogpost"> | string
    description?: StringFilter<"blogpost"> | string
    imageUrl?: StringNullableFilter<"blogpost"> | string | null
    linkPath?: StringFilter<"blogpost"> | string
    category?: Enumblogpost_categoryNullableFilter<"blogpost"> | $Enums.blogpost_category | null
    date?: DateTimeNullableFilter<"blogpost"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"blogpost"> | string | null
    postedByOwnerName?: StringNullableFilter<"blogpost"> | string | null
    createdAt?: DateTimeFilter<"blogpost"> | Date | string
    updatedAt?: DateTimeFilter<"blogpost"> | Date | string
    likes?: IntFilter<"blogpost"> | number
    audioUrl?: StringNullableFilter<"blogpost"> | string | null
    mediaUrls?: JsonNullableFilter<"blogpost">
    location?: StringNullableFilter<"blogpost"> | string | null
    taggedFriends?: StringNullableFilter<"blogpost"> | string | null
    feelingActivity?: StringNullableFilter<"blogpost"> | string | null
    backgroundTheme?: StringNullableFilter<"blogpost"> | string | null
    videoUrl?: StringNullableFilter<"blogpost"> | string | null
    comment?: CommentListRelationFilter
  }

  export type blogpostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    taggedFriends?: SortOrderInput | SortOrder
    feelingActivity?: SortOrderInput | SortOrder
    backgroundTheme?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    comment?: commentOrderByRelationAggregateInput
  }

  export type blogpostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: blogpostWhereInput | blogpostWhereInput[]
    OR?: blogpostWhereInput[]
    NOT?: blogpostWhereInput | blogpostWhereInput[]
    title?: StringFilter<"blogpost"> | string
    description?: StringFilter<"blogpost"> | string
    imageUrl?: StringNullableFilter<"blogpost"> | string | null
    linkPath?: StringFilter<"blogpost"> | string
    category?: Enumblogpost_categoryNullableFilter<"blogpost"> | $Enums.blogpost_category | null
    date?: DateTimeNullableFilter<"blogpost"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"blogpost"> | string | null
    postedByOwnerName?: StringNullableFilter<"blogpost"> | string | null
    createdAt?: DateTimeFilter<"blogpost"> | Date | string
    updatedAt?: DateTimeFilter<"blogpost"> | Date | string
    likes?: IntFilter<"blogpost"> | number
    audioUrl?: StringNullableFilter<"blogpost"> | string | null
    mediaUrls?: JsonNullableFilter<"blogpost">
    location?: StringNullableFilter<"blogpost"> | string | null
    taggedFriends?: StringNullableFilter<"blogpost"> | string | null
    feelingActivity?: StringNullableFilter<"blogpost"> | string | null
    backgroundTheme?: StringNullableFilter<"blogpost"> | string | null
    videoUrl?: StringNullableFilter<"blogpost"> | string | null
    comment?: CommentListRelationFilter
  }, "id">

  export type blogpostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    taggedFriends?: SortOrderInput | SortOrder
    feelingActivity?: SortOrderInput | SortOrder
    backgroundTheme?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    _count?: blogpostCountOrderByAggregateInput
    _avg?: blogpostAvgOrderByAggregateInput
    _max?: blogpostMaxOrderByAggregateInput
    _min?: blogpostMinOrderByAggregateInput
    _sum?: blogpostSumOrderByAggregateInput
  }

  export type blogpostScalarWhereWithAggregatesInput = {
    AND?: blogpostScalarWhereWithAggregatesInput | blogpostScalarWhereWithAggregatesInput[]
    OR?: blogpostScalarWhereWithAggregatesInput[]
    NOT?: blogpostScalarWhereWithAggregatesInput | blogpostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"blogpost"> | string
    title?: StringWithAggregatesFilter<"blogpost"> | string
    description?: StringWithAggregatesFilter<"blogpost"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    linkPath?: StringWithAggregatesFilter<"blogpost"> | string
    category?: Enumblogpost_categoryNullableWithAggregatesFilter<"blogpost"> | $Enums.blogpost_category | null
    date?: DateTimeNullableWithAggregatesFilter<"blogpost"> | Date | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"blogpost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"blogpost"> | Date | string
    likes?: IntWithAggregatesFilter<"blogpost"> | number
    audioUrl?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    mediaUrls?: JsonNullableWithAggregatesFilter<"blogpost">
    location?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    taggedFriends?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    feelingActivity?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    backgroundTheme?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"blogpost"> | string | null
  }

  export type branchchurchWhereInput = {
    AND?: branchchurchWhereInput | branchchurchWhereInput[]
    OR?: branchchurchWhereInput[]
    NOT?: branchchurchWhereInput | branchchurchWhereInput[]
    id?: StringFilter<"branchchurch"> | string
    name?: StringFilter<"branchchurch"> | string
    address?: StringFilter<"branchchurch"> | string
    pastorName?: StringNullableFilter<"branchchurch"> | string | null
    phone?: StringNullableFilter<"branchchurch"> | string | null
    email?: StringNullableFilter<"branchchurch"> | string | null
    serviceTimes?: StringFilter<"branchchurch"> | string
    mapEmbedUrl?: StringNullableFilter<"branchchurch"> | string | null
    imageUrl?: StringNullableFilter<"branchchurch"> | string | null
    description?: StringNullableFilter<"branchchurch"> | string | null
    establishedDate?: DateTimeNullableFilter<"branchchurch"> | Date | string | null
    createdAt?: DateTimeFilter<"branchchurch"> | Date | string
    updatedAt?: DateTimeFilter<"branchchurch"> | Date | string
    postedByOwnerId?: StringNullableFilter<"branchchurch"> | string | null
    postedByOwnerName?: StringNullableFilter<"branchchurch"> | string | null
  }

  export type branchchurchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pastorName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    serviceTimes?: SortOrder
    mapEmbedUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    establishedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
  }

  export type branchchurchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: branchchurchWhereInput | branchchurchWhereInput[]
    OR?: branchchurchWhereInput[]
    NOT?: branchchurchWhereInput | branchchurchWhereInput[]
    name?: StringFilter<"branchchurch"> | string
    address?: StringFilter<"branchchurch"> | string
    pastorName?: StringNullableFilter<"branchchurch"> | string | null
    phone?: StringNullableFilter<"branchchurch"> | string | null
    email?: StringNullableFilter<"branchchurch"> | string | null
    serviceTimes?: StringFilter<"branchchurch"> | string
    mapEmbedUrl?: StringNullableFilter<"branchchurch"> | string | null
    imageUrl?: StringNullableFilter<"branchchurch"> | string | null
    description?: StringNullableFilter<"branchchurch"> | string | null
    establishedDate?: DateTimeNullableFilter<"branchchurch"> | Date | string | null
    createdAt?: DateTimeFilter<"branchchurch"> | Date | string
    updatedAt?: DateTimeFilter<"branchchurch"> | Date | string
    postedByOwnerId?: StringNullableFilter<"branchchurch"> | string | null
    postedByOwnerName?: StringNullableFilter<"branchchurch"> | string | null
  }, "id">

  export type branchchurchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pastorName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    serviceTimes?: SortOrder
    mapEmbedUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    establishedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    _count?: branchchurchCountOrderByAggregateInput
    _max?: branchchurchMaxOrderByAggregateInput
    _min?: branchchurchMinOrderByAggregateInput
  }

  export type branchchurchScalarWhereWithAggregatesInput = {
    AND?: branchchurchScalarWhereWithAggregatesInput | branchchurchScalarWhereWithAggregatesInput[]
    OR?: branchchurchScalarWhereWithAggregatesInput[]
    NOT?: branchchurchScalarWhereWithAggregatesInput | branchchurchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"branchchurch"> | string
    name?: StringWithAggregatesFilter<"branchchurch"> | string
    address?: StringWithAggregatesFilter<"branchchurch"> | string
    pastorName?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
    phone?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
    email?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
    serviceTimes?: StringWithAggregatesFilter<"branchchurch"> | string
    mapEmbedUrl?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
    description?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
    establishedDate?: DateTimeNullableWithAggregatesFilter<"branchchurch"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"branchchurch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"branchchurch"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"branchchurch"> | string | null
  }

  export type churchmemberWhereInput = {
    AND?: churchmemberWhereInput | churchmemberWhereInput[]
    OR?: churchmemberWhereInput[]
    NOT?: churchmemberWhereInput | churchmemberWhereInput[]
    id?: StringFilter<"churchmember"> | string
    userId?: StringNullableFilter<"churchmember"> | string | null
    fullName?: StringFilter<"churchmember"> | string
    username?: StringNullableFilter<"churchmember"> | string | null
    contactPhone?: StringNullableFilter<"churchmember"> | string | null
    contactEmail?: StringNullableFilter<"churchmember"> | string | null
    address?: StringNullableFilter<"churchmember"> | string | null
    memberSince?: DateTimeFilter<"churchmember"> | Date | string
    dateOfBirth?: DateTimeNullableFilter<"churchmember"> | Date | string | null
    baptismDate?: DateTimeNullableFilter<"churchmember"> | Date | string | null
    familyMembers?: StringNullableFilter<"churchmember"> | string | null
    notes?: StringNullableFilter<"churchmember"> | string | null
    isActiveMember?: BoolFilter<"churchmember"> | boolean
    profileImageUrl?: StringNullableFilter<"churchmember"> | string | null
    postedByOwnerId?: StringNullableFilter<"churchmember"> | string | null
    postedByOwnerName?: StringNullableFilter<"churchmember"> | string | null
    createdAt?: DateTimeFilter<"churchmember"> | Date | string
    updatedAt?: DateTimeFilter<"churchmember"> | Date | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type churchmemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    memberSince?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    baptismDate?: SortOrderInput | SortOrder
    familyMembers?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActiveMember?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type churchmemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: churchmemberWhereInput | churchmemberWhereInput[]
    OR?: churchmemberWhereInput[]
    NOT?: churchmemberWhereInput | churchmemberWhereInput[]
    fullName?: StringFilter<"churchmember"> | string
    username?: StringNullableFilter<"churchmember"> | string | null
    contactPhone?: StringNullableFilter<"churchmember"> | string | null
    contactEmail?: StringNullableFilter<"churchmember"> | string | null
    address?: StringNullableFilter<"churchmember"> | string | null
    memberSince?: DateTimeFilter<"churchmember"> | Date | string
    dateOfBirth?: DateTimeNullableFilter<"churchmember"> | Date | string | null
    baptismDate?: DateTimeNullableFilter<"churchmember"> | Date | string | null
    familyMembers?: StringNullableFilter<"churchmember"> | string | null
    notes?: StringNullableFilter<"churchmember"> | string | null
    isActiveMember?: BoolFilter<"churchmember"> | boolean
    profileImageUrl?: StringNullableFilter<"churchmember"> | string | null
    postedByOwnerId?: StringNullableFilter<"churchmember"> | string | null
    postedByOwnerName?: StringNullableFilter<"churchmember"> | string | null
    createdAt?: DateTimeFilter<"churchmember"> | Date | string
    updatedAt?: DateTimeFilter<"churchmember"> | Date | string
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id" | "userId">

  export type churchmemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    username?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    memberSince?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    baptismDate?: SortOrderInput | SortOrder
    familyMembers?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActiveMember?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: churchmemberCountOrderByAggregateInput
    _max?: churchmemberMaxOrderByAggregateInput
    _min?: churchmemberMinOrderByAggregateInput
  }

  export type churchmemberScalarWhereWithAggregatesInput = {
    AND?: churchmemberScalarWhereWithAggregatesInput | churchmemberScalarWhereWithAggregatesInput[]
    OR?: churchmemberScalarWhereWithAggregatesInput[]
    NOT?: churchmemberScalarWhereWithAggregatesInput | churchmemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"churchmember"> | string
    userId?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    fullName?: StringWithAggregatesFilter<"churchmember"> | string
    username?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    address?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    memberSince?: DateTimeWithAggregatesFilter<"churchmember"> | Date | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"churchmember"> | Date | string | null
    baptismDate?: DateTimeNullableWithAggregatesFilter<"churchmember"> | Date | string | null
    familyMembers?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    notes?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    isActiveMember?: BoolWithAggregatesFilter<"churchmember"> | boolean
    profileImageUrl?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"churchmember"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"churchmember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"churchmember"> | Date | string
  }

  export type collectionrecordWhereInput = {
    AND?: collectionrecordWhereInput | collectionrecordWhereInput[]
    OR?: collectionrecordWhereInput[]
    NOT?: collectionrecordWhereInput | collectionrecordWhereInput[]
    id?: StringFilter<"collectionrecord"> | string
    collectorName?: StringFilter<"collectionrecord"> | string
    collectionDate?: DateTimeFilter<"collectionrecord"> | Date | string
    amount?: DecimalFilter<"collectionrecord"> | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFilter<"collectionrecord"> | $Enums.collectionrecord_purpose
    source?: StringNullableFilter<"collectionrecord"> | string | null
    notes?: StringNullableFilter<"collectionrecord"> | string | null
    recordedAt?: DateTimeFilter<"collectionrecord"> | Date | string
    recordedByOwnerId?: StringNullableFilter<"collectionrecord"> | string | null
    recordedByOwnerName?: StringNullableFilter<"collectionrecord"> | string | null
    updatedAt?: DateTimeFilter<"collectionrecord"> | Date | string
    postedByOwnerId?: StringNullableFilter<"collectionrecord"> | string | null
    postedByOwnerName?: StringNullableFilter<"collectionrecord"> | string | null
    createdAt?: DateTimeFilter<"collectionrecord"> | Date | string
    countedBy?: StringNullableFilter<"collectionrecord"> | string | null
    isDeposited?: BoolFilter<"collectionrecord"> | boolean
    depositDate?: DateTimeNullableFilter<"collectionrecord"> | Date | string | null
    bankDepositReference?: StringNullableFilter<"collectionrecord"> | string | null
    donordetail?: DonordetailListRelationFilter
  }

  export type collectionrecordOrderByWithRelationInput = {
    id?: SortOrder
    collectorName?: SortOrder
    collectionDate?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    recordedByOwnerId?: SortOrderInput | SortOrder
    recordedByOwnerName?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    countedBy?: SortOrderInput | SortOrder
    isDeposited?: SortOrder
    depositDate?: SortOrderInput | SortOrder
    bankDepositReference?: SortOrderInput | SortOrder
    donordetail?: donordetailOrderByRelationAggregateInput
  }

  export type collectionrecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: collectionrecordWhereInput | collectionrecordWhereInput[]
    OR?: collectionrecordWhereInput[]
    NOT?: collectionrecordWhereInput | collectionrecordWhereInput[]
    collectorName?: StringFilter<"collectionrecord"> | string
    collectionDate?: DateTimeFilter<"collectionrecord"> | Date | string
    amount?: DecimalFilter<"collectionrecord"> | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFilter<"collectionrecord"> | $Enums.collectionrecord_purpose
    source?: StringNullableFilter<"collectionrecord"> | string | null
    notes?: StringNullableFilter<"collectionrecord"> | string | null
    recordedAt?: DateTimeFilter<"collectionrecord"> | Date | string
    recordedByOwnerId?: StringNullableFilter<"collectionrecord"> | string | null
    recordedByOwnerName?: StringNullableFilter<"collectionrecord"> | string | null
    updatedAt?: DateTimeFilter<"collectionrecord"> | Date | string
    postedByOwnerId?: StringNullableFilter<"collectionrecord"> | string | null
    postedByOwnerName?: StringNullableFilter<"collectionrecord"> | string | null
    createdAt?: DateTimeFilter<"collectionrecord"> | Date | string
    countedBy?: StringNullableFilter<"collectionrecord"> | string | null
    isDeposited?: BoolFilter<"collectionrecord"> | boolean
    depositDate?: DateTimeNullableFilter<"collectionrecord"> | Date | string | null
    bankDepositReference?: StringNullableFilter<"collectionrecord"> | string | null
    donordetail?: DonordetailListRelationFilter
  }, "id">

  export type collectionrecordOrderByWithAggregationInput = {
    id?: SortOrder
    collectorName?: SortOrder
    collectionDate?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedAt?: SortOrder
    recordedByOwnerId?: SortOrderInput | SortOrder
    recordedByOwnerName?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    countedBy?: SortOrderInput | SortOrder
    isDeposited?: SortOrder
    depositDate?: SortOrderInput | SortOrder
    bankDepositReference?: SortOrderInput | SortOrder
    _count?: collectionrecordCountOrderByAggregateInput
    _avg?: collectionrecordAvgOrderByAggregateInput
    _max?: collectionrecordMaxOrderByAggregateInput
    _min?: collectionrecordMinOrderByAggregateInput
    _sum?: collectionrecordSumOrderByAggregateInput
  }

  export type collectionrecordScalarWhereWithAggregatesInput = {
    AND?: collectionrecordScalarWhereWithAggregatesInput | collectionrecordScalarWhereWithAggregatesInput[]
    OR?: collectionrecordScalarWhereWithAggregatesInput[]
    NOT?: collectionrecordScalarWhereWithAggregatesInput | collectionrecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"collectionrecord"> | string
    collectorName?: StringWithAggregatesFilter<"collectionrecord"> | string
    collectionDate?: DateTimeWithAggregatesFilter<"collectionrecord"> | Date | string
    amount?: DecimalWithAggregatesFilter<"collectionrecord"> | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeWithAggregatesFilter<"collectionrecord"> | $Enums.collectionrecord_purpose
    source?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
    notes?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
    recordedAt?: DateTimeWithAggregatesFilter<"collectionrecord"> | Date | string
    recordedByOwnerId?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
    recordedByOwnerName?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"collectionrecord"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"collectionrecord"> | Date | string
    countedBy?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
    isDeposited?: BoolWithAggregatesFilter<"collectionrecord"> | boolean
    depositDate?: DateTimeNullableWithAggregatesFilter<"collectionrecord"> | Date | string | null
    bankDepositReference?: StringNullableWithAggregatesFilter<"collectionrecord"> | string | null
  }

  export type commentWhereInput = {
    AND?: commentWhereInput | commentWhereInput[]
    OR?: commentWhereInput[]
    NOT?: commentWhereInput | commentWhereInput[]
    id?: StringFilter<"comment"> | string
    userId?: StringFilter<"comment"> | string
    userName?: StringFilter<"comment"> | string
    userProfileImageUrl?: StringNullableFilter<"comment"> | string | null
    text?: StringFilter<"comment"> | string
    timestamp?: DateTimeFilter<"comment"> | Date | string
    editedAt?: DateTimeNullableFilter<"comment"> | Date | string | null
    sermonId?: StringNullableFilter<"comment"> | string | null
    eventId?: StringNullableFilter<"comment"> | string | null
    blogPostId?: StringNullableFilter<"comment"> | string | null
    newsItemId?: StringNullableFilter<"comment"> | string | null
    historyChapterId?: StringNullableFilter<"comment"> | string | null
    prayerRequestId?: StringNullableFilter<"comment"> | string | null
    blogpost?: XOR<BlogpostNullableRelationFilter, blogpostWhereInput> | null
    eventitem?: XOR<EventitemNullableRelationFilter, eventitemWhereInput> | null
    historychapter?: XOR<HistorychapterNullableRelationFilter, historychapterWhereInput> | null
    newsitem?: XOR<NewsitemNullableRelationFilter, newsitemWhereInput> | null
    prayerrequest?: XOR<PrayerrequestNullableRelationFilter, prayerrequestWhereInput> | null
    sermon?: XOR<SermonNullableRelationFilter, sermonWhereInput> | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type commentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrderInput | SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    sermonId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    blogPostId?: SortOrderInput | SortOrder
    newsItemId?: SortOrderInput | SortOrder
    historyChapterId?: SortOrderInput | SortOrder
    prayerRequestId?: SortOrderInput | SortOrder
    blogpost?: blogpostOrderByWithRelationInput
    eventitem?: eventitemOrderByWithRelationInput
    historychapter?: historychapterOrderByWithRelationInput
    newsitem?: newsitemOrderByWithRelationInput
    prayerrequest?: prayerrequestOrderByWithRelationInput
    sermon?: sermonOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type commentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: commentWhereInput | commentWhereInput[]
    OR?: commentWhereInput[]
    NOT?: commentWhereInput | commentWhereInput[]
    userId?: StringFilter<"comment"> | string
    userName?: StringFilter<"comment"> | string
    userProfileImageUrl?: StringNullableFilter<"comment"> | string | null
    text?: StringFilter<"comment"> | string
    timestamp?: DateTimeFilter<"comment"> | Date | string
    editedAt?: DateTimeNullableFilter<"comment"> | Date | string | null
    sermonId?: StringNullableFilter<"comment"> | string | null
    eventId?: StringNullableFilter<"comment"> | string | null
    blogPostId?: StringNullableFilter<"comment"> | string | null
    newsItemId?: StringNullableFilter<"comment"> | string | null
    historyChapterId?: StringNullableFilter<"comment"> | string | null
    prayerRequestId?: StringNullableFilter<"comment"> | string | null
    blogpost?: XOR<BlogpostNullableRelationFilter, blogpostWhereInput> | null
    eventitem?: XOR<EventitemNullableRelationFilter, eventitemWhereInput> | null
    historychapter?: XOR<HistorychapterNullableRelationFilter, historychapterWhereInput> | null
    newsitem?: XOR<NewsitemNullableRelationFilter, newsitemWhereInput> | null
    prayerrequest?: XOR<PrayerrequestNullableRelationFilter, prayerrequestWhereInput> | null
    sermon?: XOR<SermonNullableRelationFilter, sermonWhereInput> | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type commentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrderInput | SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    sermonId?: SortOrderInput | SortOrder
    eventId?: SortOrderInput | SortOrder
    blogPostId?: SortOrderInput | SortOrder
    newsItemId?: SortOrderInput | SortOrder
    historyChapterId?: SortOrderInput | SortOrder
    prayerRequestId?: SortOrderInput | SortOrder
    _count?: commentCountOrderByAggregateInput
    _max?: commentMaxOrderByAggregateInput
    _min?: commentMinOrderByAggregateInput
  }

  export type commentScalarWhereWithAggregatesInput = {
    AND?: commentScalarWhereWithAggregatesInput | commentScalarWhereWithAggregatesInput[]
    OR?: commentScalarWhereWithAggregatesInput[]
    NOT?: commentScalarWhereWithAggregatesInput | commentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"comment"> | string
    userId?: StringWithAggregatesFilter<"comment"> | string
    userName?: StringWithAggregatesFilter<"comment"> | string
    userProfileImageUrl?: StringNullableWithAggregatesFilter<"comment"> | string | null
    text?: StringWithAggregatesFilter<"comment"> | string
    timestamp?: DateTimeWithAggregatesFilter<"comment"> | Date | string
    editedAt?: DateTimeNullableWithAggregatesFilter<"comment"> | Date | string | null
    sermonId?: StringNullableWithAggregatesFilter<"comment"> | string | null
    eventId?: StringNullableWithAggregatesFilter<"comment"> | string | null
    blogPostId?: StringNullableWithAggregatesFilter<"comment"> | string | null
    newsItemId?: StringNullableWithAggregatesFilter<"comment"> | string | null
    historyChapterId?: StringNullableWithAggregatesFilter<"comment"> | string | null
    prayerRequestId?: StringNullableWithAggregatesFilter<"comment"> | string | null
  }

  export type contactmessageWhereInput = {
    AND?: contactmessageWhereInput | contactmessageWhereInput[]
    OR?: contactmessageWhereInput[]
    NOT?: contactmessageWhereInput | contactmessageWhereInput[]
    id?: StringFilter<"contactmessage"> | string
    name?: StringFilter<"contactmessage"> | string
    email?: StringFilter<"contactmessage"> | string
    subject?: StringFilter<"contactmessage"> | string
    message?: StringFilter<"contactmessage"> | string
    submittedAt?: DateTimeFilter<"contactmessage"> | Date | string
    status?: Enumcontactmessage_statusFilter<"contactmessage"> | $Enums.contactmessage_status
    repliedAt?: DateTimeNullableFilter<"contactmessage"> | Date | string | null
    replyNote?: StringNullableFilter<"contactmessage"> | string | null
  }

  export type contactmessageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    repliedAt?: SortOrderInput | SortOrder
    replyNote?: SortOrderInput | SortOrder
  }

  export type contactmessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: contactmessageWhereInput | contactmessageWhereInput[]
    OR?: contactmessageWhereInput[]
    NOT?: contactmessageWhereInput | contactmessageWhereInput[]
    name?: StringFilter<"contactmessage"> | string
    email?: StringFilter<"contactmessage"> | string
    subject?: StringFilter<"contactmessage"> | string
    message?: StringFilter<"contactmessage"> | string
    submittedAt?: DateTimeFilter<"contactmessage"> | Date | string
    status?: Enumcontactmessage_statusFilter<"contactmessage"> | $Enums.contactmessage_status
    repliedAt?: DateTimeNullableFilter<"contactmessage"> | Date | string | null
    replyNote?: StringNullableFilter<"contactmessage"> | string | null
  }, "id">

  export type contactmessageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    repliedAt?: SortOrderInput | SortOrder
    replyNote?: SortOrderInput | SortOrder
    _count?: contactmessageCountOrderByAggregateInput
    _max?: contactmessageMaxOrderByAggregateInput
    _min?: contactmessageMinOrderByAggregateInput
  }

  export type contactmessageScalarWhereWithAggregatesInput = {
    AND?: contactmessageScalarWhereWithAggregatesInput | contactmessageScalarWhereWithAggregatesInput[]
    OR?: contactmessageScalarWhereWithAggregatesInput[]
    NOT?: contactmessageScalarWhereWithAggregatesInput | contactmessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contactmessage"> | string
    name?: StringWithAggregatesFilter<"contactmessage"> | string
    email?: StringWithAggregatesFilter<"contactmessage"> | string
    subject?: StringWithAggregatesFilter<"contactmessage"> | string
    message?: StringWithAggregatesFilter<"contactmessage"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"contactmessage"> | Date | string
    status?: Enumcontactmessage_statusWithAggregatesFilter<"contactmessage"> | $Enums.contactmessage_status
    repliedAt?: DateTimeNullableWithAggregatesFilter<"contactmessage"> | Date | string | null
    replyNote?: StringNullableWithAggregatesFilter<"contactmessage"> | string | null
  }

  export type decisionlogWhereInput = {
    AND?: decisionlogWhereInput | decisionlogWhereInput[]
    OR?: decisionlogWhereInput[]
    NOT?: decisionlogWhereInput | decisionlogWhereInput[]
    id?: StringFilter<"decisionlog"> | string
    decisionDate?: DateTimeFilter<"decisionlog"> | Date | string
    title?: StringFilter<"decisionlog"> | string
    description?: StringFilter<"decisionlog"> | string
    madeBy?: StringFilter<"decisionlog"> | string
    status?: Enumdecisionlog_statusNullableFilter<"decisionlog"> | $Enums.decisionlog_status | null
    followUpActions?: StringNullableFilter<"decisionlog"> | string | null
    postedByOwnerId?: StringNullableFilter<"decisionlog"> | string | null
    postedByOwnerName?: StringNullableFilter<"decisionlog"> | string | null
    createdAt?: DateTimeFilter<"decisionlog"> | Date | string
    updatedAt?: DateTimeFilter<"decisionlog"> | Date | string
  }

  export type decisionlogOrderByWithRelationInput = {
    id?: SortOrder
    decisionDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    madeBy?: SortOrder
    status?: SortOrderInput | SortOrder
    followUpActions?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type decisionlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: decisionlogWhereInput | decisionlogWhereInput[]
    OR?: decisionlogWhereInput[]
    NOT?: decisionlogWhereInput | decisionlogWhereInput[]
    decisionDate?: DateTimeFilter<"decisionlog"> | Date | string
    title?: StringFilter<"decisionlog"> | string
    description?: StringFilter<"decisionlog"> | string
    madeBy?: StringFilter<"decisionlog"> | string
    status?: Enumdecisionlog_statusNullableFilter<"decisionlog"> | $Enums.decisionlog_status | null
    followUpActions?: StringNullableFilter<"decisionlog"> | string | null
    postedByOwnerId?: StringNullableFilter<"decisionlog"> | string | null
    postedByOwnerName?: StringNullableFilter<"decisionlog"> | string | null
    createdAt?: DateTimeFilter<"decisionlog"> | Date | string
    updatedAt?: DateTimeFilter<"decisionlog"> | Date | string
  }, "id">

  export type decisionlogOrderByWithAggregationInput = {
    id?: SortOrder
    decisionDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    madeBy?: SortOrder
    status?: SortOrderInput | SortOrder
    followUpActions?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: decisionlogCountOrderByAggregateInput
    _max?: decisionlogMaxOrderByAggregateInput
    _min?: decisionlogMinOrderByAggregateInput
  }

  export type decisionlogScalarWhereWithAggregatesInput = {
    AND?: decisionlogScalarWhereWithAggregatesInput | decisionlogScalarWhereWithAggregatesInput[]
    OR?: decisionlogScalarWhereWithAggregatesInput[]
    NOT?: decisionlogScalarWhereWithAggregatesInput | decisionlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"decisionlog"> | string
    decisionDate?: DateTimeWithAggregatesFilter<"decisionlog"> | Date | string
    title?: StringWithAggregatesFilter<"decisionlog"> | string
    description?: StringWithAggregatesFilter<"decisionlog"> | string
    madeBy?: StringWithAggregatesFilter<"decisionlog"> | string
    status?: Enumdecisionlog_statusNullableWithAggregatesFilter<"decisionlog"> | $Enums.decisionlog_status | null
    followUpActions?: StringNullableWithAggregatesFilter<"decisionlog"> | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"decisionlog"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"decisionlog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"decisionlog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"decisionlog"> | Date | string
  }

  export type directmediaitemWhereInput = {
    AND?: directmediaitemWhereInput | directmediaitemWhereInput[]
    OR?: directmediaitemWhereInput[]
    NOT?: directmediaitemWhereInput | directmediaitemWhereInput[]
    id?: StringFilter<"directmediaitem"> | string
    title?: StringFilter<"directmediaitem"> | string
    description?: StringNullableFilter<"directmediaitem"> | string | null
    url?: StringFilter<"directmediaitem"> | string
    mediaType?: Enumdirectmediaitem_mediaTypeFilter<"directmediaitem"> | $Enums.directmediaitem_mediaType
    category?: StringNullableFilter<"directmediaitem"> | string | null
    tags?: JsonNullableFilter<"directmediaitem">
    uploadDate?: DateTimeFilter<"directmediaitem"> | Date | string
    postedByOwnerId?: StringNullableFilter<"directmediaitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"directmediaitem"> | string | null
    updatedAt?: DateTimeFilter<"directmediaitem"> | Date | string
  }

  export type directmediaitemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type directmediaitemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: directmediaitemWhereInput | directmediaitemWhereInput[]
    OR?: directmediaitemWhereInput[]
    NOT?: directmediaitemWhereInput | directmediaitemWhereInput[]
    title?: StringFilter<"directmediaitem"> | string
    description?: StringNullableFilter<"directmediaitem"> | string | null
    url?: StringFilter<"directmediaitem"> | string
    mediaType?: Enumdirectmediaitem_mediaTypeFilter<"directmediaitem"> | $Enums.directmediaitem_mediaType
    category?: StringNullableFilter<"directmediaitem"> | string | null
    tags?: JsonNullableFilter<"directmediaitem">
    uploadDate?: DateTimeFilter<"directmediaitem"> | Date | string
    postedByOwnerId?: StringNullableFilter<"directmediaitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"directmediaitem"> | string | null
    updatedAt?: DateTimeFilter<"directmediaitem"> | Date | string
  }, "id">

  export type directmediaitemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    uploadDate?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: directmediaitemCountOrderByAggregateInput
    _max?: directmediaitemMaxOrderByAggregateInput
    _min?: directmediaitemMinOrderByAggregateInput
  }

  export type directmediaitemScalarWhereWithAggregatesInput = {
    AND?: directmediaitemScalarWhereWithAggregatesInput | directmediaitemScalarWhereWithAggregatesInput[]
    OR?: directmediaitemScalarWhereWithAggregatesInput[]
    NOT?: directmediaitemScalarWhereWithAggregatesInput | directmediaitemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"directmediaitem"> | string
    title?: StringWithAggregatesFilter<"directmediaitem"> | string
    description?: StringNullableWithAggregatesFilter<"directmediaitem"> | string | null
    url?: StringWithAggregatesFilter<"directmediaitem"> | string
    mediaType?: Enumdirectmediaitem_mediaTypeWithAggregatesFilter<"directmediaitem"> | $Enums.directmediaitem_mediaType
    category?: StringNullableWithAggregatesFilter<"directmediaitem"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"directmediaitem">
    uploadDate?: DateTimeWithAggregatesFilter<"directmediaitem"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"directmediaitem"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"directmediaitem"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"directmediaitem"> | Date | string
  }

  export type donatepagecontentWhereInput = {
    AND?: donatepagecontentWhereInput | donatepagecontentWhereInput[]
    OR?: donatepagecontentWhereInput[]
    NOT?: donatepagecontentWhereInput | donatepagecontentWhereInput[]
    id?: StringFilter<"donatepagecontent"> | string
    headerTitle?: StringFilter<"donatepagecontent"> | string
    headerSubtitle?: StringFilter<"donatepagecontent"> | string
    headerImageUrl?: StringFilter<"donatepagecontent"> | string
    localDonationsTitle?: StringFilter<"donatepagecontent"> | string
    bankName?: StringFilter<"donatepagecontent"> | string
    accountName?: StringFilter<"donatepagecontent"> | string
    accountNumber?: StringFilter<"donatepagecontent"> | string
    branch?: StringFilter<"donatepagecontent"> | string
    bankQrImageUrl?: StringNullableFilter<"donatepagecontent"> | string | null
    eSewaId?: StringFilter<"donatepagecontent"> | string
    eSewaQrImageUrl?: StringNullableFilter<"donatepagecontent"> | string | null
    localDonationsNote?: StringFilter<"donatepagecontent"> | string
    internationalDonationsTitle?: StringFilter<"donatepagecontent"> | string
    internationalDonationsContent?: StringFilter<"donatepagecontent"> | string
    internationalDonationsContactEmail?: StringFilter<"donatepagecontent"> | string
    internationalQrImageUrl?: StringNullableFilter<"donatepagecontent"> | string | null
    receiptVerses?: StringNullableFilter<"donatepagecontent"> | string | null
    updatedAt?: DateTimeFilter<"donatepagecontent"> | Date | string
    postedByOwnerId?: StringNullableFilter<"donatepagecontent"> | string | null
    postedByOwnerName?: StringNullableFilter<"donatepagecontent"> | string | null
  }

  export type donatepagecontentOrderByWithRelationInput = {
    id?: SortOrder
    headerTitle?: SortOrder
    headerSubtitle?: SortOrder
    headerImageUrl?: SortOrder
    localDonationsTitle?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    branch?: SortOrder
    bankQrImageUrl?: SortOrderInput | SortOrder
    eSewaId?: SortOrder
    eSewaQrImageUrl?: SortOrderInput | SortOrder
    localDonationsNote?: SortOrder
    internationalDonationsTitle?: SortOrder
    internationalDonationsContent?: SortOrder
    internationalDonationsContactEmail?: SortOrder
    internationalQrImageUrl?: SortOrderInput | SortOrder
    receiptVerses?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
  }

  export type donatepagecontentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: donatepagecontentWhereInput | donatepagecontentWhereInput[]
    OR?: donatepagecontentWhereInput[]
    NOT?: donatepagecontentWhereInput | donatepagecontentWhereInput[]
    headerTitle?: StringFilter<"donatepagecontent"> | string
    headerSubtitle?: StringFilter<"donatepagecontent"> | string
    headerImageUrl?: StringFilter<"donatepagecontent"> | string
    localDonationsTitle?: StringFilter<"donatepagecontent"> | string
    bankName?: StringFilter<"donatepagecontent"> | string
    accountName?: StringFilter<"donatepagecontent"> | string
    accountNumber?: StringFilter<"donatepagecontent"> | string
    branch?: StringFilter<"donatepagecontent"> | string
    bankQrImageUrl?: StringNullableFilter<"donatepagecontent"> | string | null
    eSewaId?: StringFilter<"donatepagecontent"> | string
    eSewaQrImageUrl?: StringNullableFilter<"donatepagecontent"> | string | null
    localDonationsNote?: StringFilter<"donatepagecontent"> | string
    internationalDonationsTitle?: StringFilter<"donatepagecontent"> | string
    internationalDonationsContent?: StringFilter<"donatepagecontent"> | string
    internationalDonationsContactEmail?: StringFilter<"donatepagecontent"> | string
    internationalQrImageUrl?: StringNullableFilter<"donatepagecontent"> | string | null
    receiptVerses?: StringNullableFilter<"donatepagecontent"> | string | null
    updatedAt?: DateTimeFilter<"donatepagecontent"> | Date | string
    postedByOwnerId?: StringNullableFilter<"donatepagecontent"> | string | null
    postedByOwnerName?: StringNullableFilter<"donatepagecontent"> | string | null
  }, "id">

  export type donatepagecontentOrderByWithAggregationInput = {
    id?: SortOrder
    headerTitle?: SortOrder
    headerSubtitle?: SortOrder
    headerImageUrl?: SortOrder
    localDonationsTitle?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    branch?: SortOrder
    bankQrImageUrl?: SortOrderInput | SortOrder
    eSewaId?: SortOrder
    eSewaQrImageUrl?: SortOrderInput | SortOrder
    localDonationsNote?: SortOrder
    internationalDonationsTitle?: SortOrder
    internationalDonationsContent?: SortOrder
    internationalDonationsContactEmail?: SortOrder
    internationalQrImageUrl?: SortOrderInput | SortOrder
    receiptVerses?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    _count?: donatepagecontentCountOrderByAggregateInput
    _max?: donatepagecontentMaxOrderByAggregateInput
    _min?: donatepagecontentMinOrderByAggregateInput
  }

  export type donatepagecontentScalarWhereWithAggregatesInput = {
    AND?: donatepagecontentScalarWhereWithAggregatesInput | donatepagecontentScalarWhereWithAggregatesInput[]
    OR?: donatepagecontentScalarWhereWithAggregatesInput[]
    NOT?: donatepagecontentScalarWhereWithAggregatesInput | donatepagecontentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"donatepagecontent"> | string
    headerTitle?: StringWithAggregatesFilter<"donatepagecontent"> | string
    headerSubtitle?: StringWithAggregatesFilter<"donatepagecontent"> | string
    headerImageUrl?: StringWithAggregatesFilter<"donatepagecontent"> | string
    localDonationsTitle?: StringWithAggregatesFilter<"donatepagecontent"> | string
    bankName?: StringWithAggregatesFilter<"donatepagecontent"> | string
    accountName?: StringWithAggregatesFilter<"donatepagecontent"> | string
    accountNumber?: StringWithAggregatesFilter<"donatepagecontent"> | string
    branch?: StringWithAggregatesFilter<"donatepagecontent"> | string
    bankQrImageUrl?: StringNullableWithAggregatesFilter<"donatepagecontent"> | string | null
    eSewaId?: StringWithAggregatesFilter<"donatepagecontent"> | string
    eSewaQrImageUrl?: StringNullableWithAggregatesFilter<"donatepagecontent"> | string | null
    localDonationsNote?: StringWithAggregatesFilter<"donatepagecontent"> | string
    internationalDonationsTitle?: StringWithAggregatesFilter<"donatepagecontent"> | string
    internationalDonationsContent?: StringWithAggregatesFilter<"donatepagecontent"> | string
    internationalDonationsContactEmail?: StringWithAggregatesFilter<"donatepagecontent"> | string
    internationalQrImageUrl?: StringNullableWithAggregatesFilter<"donatepagecontent"> | string | null
    receiptVerses?: StringNullableWithAggregatesFilter<"donatepagecontent"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"donatepagecontent"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"donatepagecontent"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"donatepagecontent"> | string | null
  }

  export type donationrecordWhereInput = {
    AND?: donationrecordWhereInput | donationrecordWhereInput[]
    OR?: donationrecordWhereInput[]
    NOT?: donationrecordWhereInput | donationrecordWhereInput[]
    id?: StringFilter<"donationrecord"> | string
    donorName?: StringFilter<"donationrecord"> | string
    donorEmail?: StringFilter<"donationrecord"> | string
    donorPhone?: StringNullableFilter<"donationrecord"> | string | null
    amount?: DecimalFilter<"donationrecord"> | Decimal | DecimalJsLike | number | string
    purpose?: Enumdonationrecord_purposeFilter<"donationrecord"> | $Enums.donationrecord_purpose
    donationDate?: DateTimeFilter<"donationrecord"> | Date | string
    transactionTimestamp?: DateTimeFilter<"donationrecord"> | Date | string
    postedByOwnerId?: StringNullableFilter<"donationrecord"> | string | null
    postedByOwnerName?: StringNullableFilter<"donationrecord"> | string | null
    createdAt?: DateTimeFilter<"donationrecord"> | Date | string
    updatedAt?: DateTimeFilter<"donationrecord"> | Date | string
    paymentMethod?: Enumdonationrecord_paymentMethodNullableFilter<"donationrecord"> | $Enums.donationrecord_paymentMethod | null
    transactionReference?: StringNullableFilter<"donationrecord"> | string | null
    notes?: StringNullableFilter<"donationrecord"> | string | null
    isReceiptSent?: BoolFilter<"donationrecord"> | boolean
  }

  export type donationrecordOrderByWithRelationInput = {
    id?: SortOrder
    donorName?: SortOrder
    donorEmail?: SortOrder
    donorPhone?: SortOrderInput | SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    donationDate?: SortOrder
    transactionTimestamp?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionReference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isReceiptSent?: SortOrder
  }

  export type donationrecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: donationrecordWhereInput | donationrecordWhereInput[]
    OR?: donationrecordWhereInput[]
    NOT?: donationrecordWhereInput | donationrecordWhereInput[]
    donorName?: StringFilter<"donationrecord"> | string
    donorEmail?: StringFilter<"donationrecord"> | string
    donorPhone?: StringNullableFilter<"donationrecord"> | string | null
    amount?: DecimalFilter<"donationrecord"> | Decimal | DecimalJsLike | number | string
    purpose?: Enumdonationrecord_purposeFilter<"donationrecord"> | $Enums.donationrecord_purpose
    donationDate?: DateTimeFilter<"donationrecord"> | Date | string
    transactionTimestamp?: DateTimeFilter<"donationrecord"> | Date | string
    postedByOwnerId?: StringNullableFilter<"donationrecord"> | string | null
    postedByOwnerName?: StringNullableFilter<"donationrecord"> | string | null
    createdAt?: DateTimeFilter<"donationrecord"> | Date | string
    updatedAt?: DateTimeFilter<"donationrecord"> | Date | string
    paymentMethod?: Enumdonationrecord_paymentMethodNullableFilter<"donationrecord"> | $Enums.donationrecord_paymentMethod | null
    transactionReference?: StringNullableFilter<"donationrecord"> | string | null
    notes?: StringNullableFilter<"donationrecord"> | string | null
    isReceiptSent?: BoolFilter<"donationrecord"> | boolean
  }, "id">

  export type donationrecordOrderByWithAggregationInput = {
    id?: SortOrder
    donorName?: SortOrder
    donorEmail?: SortOrder
    donorPhone?: SortOrderInput | SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    donationDate?: SortOrder
    transactionTimestamp?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionReference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isReceiptSent?: SortOrder
    _count?: donationrecordCountOrderByAggregateInput
    _avg?: donationrecordAvgOrderByAggregateInput
    _max?: donationrecordMaxOrderByAggregateInput
    _min?: donationrecordMinOrderByAggregateInput
    _sum?: donationrecordSumOrderByAggregateInput
  }

  export type donationrecordScalarWhereWithAggregatesInput = {
    AND?: donationrecordScalarWhereWithAggregatesInput | donationrecordScalarWhereWithAggregatesInput[]
    OR?: donationrecordScalarWhereWithAggregatesInput[]
    NOT?: donationrecordScalarWhereWithAggregatesInput | donationrecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"donationrecord"> | string
    donorName?: StringWithAggregatesFilter<"donationrecord"> | string
    donorEmail?: StringWithAggregatesFilter<"donationrecord"> | string
    donorPhone?: StringNullableWithAggregatesFilter<"donationrecord"> | string | null
    amount?: DecimalWithAggregatesFilter<"donationrecord"> | Decimal | DecimalJsLike | number | string
    purpose?: Enumdonationrecord_purposeWithAggregatesFilter<"donationrecord"> | $Enums.donationrecord_purpose
    donationDate?: DateTimeWithAggregatesFilter<"donationrecord"> | Date | string
    transactionTimestamp?: DateTimeWithAggregatesFilter<"donationrecord"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"donationrecord"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"donationrecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"donationrecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"donationrecord"> | Date | string
    paymentMethod?: Enumdonationrecord_paymentMethodNullableWithAggregatesFilter<"donationrecord"> | $Enums.donationrecord_paymentMethod | null
    transactionReference?: StringNullableWithAggregatesFilter<"donationrecord"> | string | null
    notes?: StringNullableWithAggregatesFilter<"donationrecord"> | string | null
    isReceiptSent?: BoolWithAggregatesFilter<"donationrecord"> | boolean
  }

  export type donordetailWhereInput = {
    AND?: donordetailWhereInput | donordetailWhereInput[]
    OR?: donordetailWhereInput[]
    NOT?: donordetailWhereInput | donordetailWhereInput[]
    id?: StringFilter<"donordetail"> | string
    donorName?: StringFilter<"donordetail"> | string
    amount?: DecimalFilter<"donordetail"> | Decimal | DecimalJsLike | number | string
    address?: StringNullableFilter<"donordetail"> | string | null
    contact?: StringNullableFilter<"donordetail"> | string | null
    collectionRecordId?: StringFilter<"donordetail"> | string
    collectionrecord?: XOR<CollectionrecordRelationFilter, collectionrecordWhereInput>
  }

  export type donordetailOrderByWithRelationInput = {
    id?: SortOrder
    donorName?: SortOrder
    amount?: SortOrder
    address?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    collectionRecordId?: SortOrder
    collectionrecord?: collectionrecordOrderByWithRelationInput
  }

  export type donordetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: donordetailWhereInput | donordetailWhereInput[]
    OR?: donordetailWhereInput[]
    NOT?: donordetailWhereInput | donordetailWhereInput[]
    donorName?: StringFilter<"donordetail"> | string
    amount?: DecimalFilter<"donordetail"> | Decimal | DecimalJsLike | number | string
    address?: StringNullableFilter<"donordetail"> | string | null
    contact?: StringNullableFilter<"donordetail"> | string | null
    collectionRecordId?: StringFilter<"donordetail"> | string
    collectionrecord?: XOR<CollectionrecordRelationFilter, collectionrecordWhereInput>
  }, "id">

  export type donordetailOrderByWithAggregationInput = {
    id?: SortOrder
    donorName?: SortOrder
    amount?: SortOrder
    address?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    collectionRecordId?: SortOrder
    _count?: donordetailCountOrderByAggregateInput
    _avg?: donordetailAvgOrderByAggregateInput
    _max?: donordetailMaxOrderByAggregateInput
    _min?: donordetailMinOrderByAggregateInput
    _sum?: donordetailSumOrderByAggregateInput
  }

  export type donordetailScalarWhereWithAggregatesInput = {
    AND?: donordetailScalarWhereWithAggregatesInput | donordetailScalarWhereWithAggregatesInput[]
    OR?: donordetailScalarWhereWithAggregatesInput[]
    NOT?: donordetailScalarWhereWithAggregatesInput | donordetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"donordetail"> | string
    donorName?: StringWithAggregatesFilter<"donordetail"> | string
    amount?: DecimalWithAggregatesFilter<"donordetail"> | Decimal | DecimalJsLike | number | string
    address?: StringNullableWithAggregatesFilter<"donordetail"> | string | null
    contact?: StringNullableWithAggregatesFilter<"donordetail"> | string | null
    collectionRecordId?: StringWithAggregatesFilter<"donordetail"> | string
  }

  export type eventitemWhereInput = {
    AND?: eventitemWhereInput | eventitemWhereInput[]
    OR?: eventitemWhereInput[]
    NOT?: eventitemWhereInput | eventitemWhereInput[]
    id?: StringFilter<"eventitem"> | string
    title?: StringFilter<"eventitem"> | string
    description?: StringFilter<"eventitem"> | string
    imageUrl?: StringNullableFilter<"eventitem"> | string | null
    linkPath?: StringFilter<"eventitem"> | string
    category?: Enumeventitem_categoryNullableFilter<"eventitem"> | $Enums.eventitem_category | null
    date?: DateTimeNullableFilter<"eventitem"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"eventitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"eventitem"> | string | null
    createdAt?: DateTimeFilter<"eventitem"> | Date | string
    updatedAt?: DateTimeFilter<"eventitem"> | Date | string
    location?: StringNullableFilter<"eventitem"> | string | null
    time?: StringNullableFilter<"eventitem"> | string | null
    expectations?: StringNullableFilter<"eventitem"> | string | null
    guests?: StringNullableFilter<"eventitem"> | string | null
    contactPerson?: StringNullableFilter<"eventitem"> | string | null
    contactEmail?: StringNullableFilter<"eventitem"> | string | null
    contactPhone?: StringNullableFilter<"eventitem"> | string | null
    registrationLink?: StringNullableFilter<"eventitem"> | string | null
    capacity?: IntNullableFilter<"eventitem"> | number | null
    isFeeRequired?: BoolFilter<"eventitem"> | boolean
    feeAmount?: StringNullableFilter<"eventitem"> | string | null
    videoUrl?: StringNullableFilter<"eventitem"> | string | null
    audioUrl?: StringNullableFilter<"eventitem"> | string | null
    likes?: IntFilter<"eventitem"> | number
    comment?: CommentListRelationFilter
  }

  export type eventitemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    expectations?: SortOrderInput | SortOrder
    guests?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    registrationLink?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    isFeeRequired?: SortOrder
    feeAmount?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    likes?: SortOrder
    comment?: commentOrderByRelationAggregateInput
  }

  export type eventitemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: eventitemWhereInput | eventitemWhereInput[]
    OR?: eventitemWhereInput[]
    NOT?: eventitemWhereInput | eventitemWhereInput[]
    title?: StringFilter<"eventitem"> | string
    description?: StringFilter<"eventitem"> | string
    imageUrl?: StringNullableFilter<"eventitem"> | string | null
    linkPath?: StringFilter<"eventitem"> | string
    category?: Enumeventitem_categoryNullableFilter<"eventitem"> | $Enums.eventitem_category | null
    date?: DateTimeNullableFilter<"eventitem"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"eventitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"eventitem"> | string | null
    createdAt?: DateTimeFilter<"eventitem"> | Date | string
    updatedAt?: DateTimeFilter<"eventitem"> | Date | string
    location?: StringNullableFilter<"eventitem"> | string | null
    time?: StringNullableFilter<"eventitem"> | string | null
    expectations?: StringNullableFilter<"eventitem"> | string | null
    guests?: StringNullableFilter<"eventitem"> | string | null
    contactPerson?: StringNullableFilter<"eventitem"> | string | null
    contactEmail?: StringNullableFilter<"eventitem"> | string | null
    contactPhone?: StringNullableFilter<"eventitem"> | string | null
    registrationLink?: StringNullableFilter<"eventitem"> | string | null
    capacity?: IntNullableFilter<"eventitem"> | number | null
    isFeeRequired?: BoolFilter<"eventitem"> | boolean
    feeAmount?: StringNullableFilter<"eventitem"> | string | null
    videoUrl?: StringNullableFilter<"eventitem"> | string | null
    audioUrl?: StringNullableFilter<"eventitem"> | string | null
    likes?: IntFilter<"eventitem"> | number
    comment?: CommentListRelationFilter
  }, "id">

  export type eventitemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    expectations?: SortOrderInput | SortOrder
    guests?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    registrationLink?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    isFeeRequired?: SortOrder
    feeAmount?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    likes?: SortOrder
    _count?: eventitemCountOrderByAggregateInput
    _avg?: eventitemAvgOrderByAggregateInput
    _max?: eventitemMaxOrderByAggregateInput
    _min?: eventitemMinOrderByAggregateInput
    _sum?: eventitemSumOrderByAggregateInput
  }

  export type eventitemScalarWhereWithAggregatesInput = {
    AND?: eventitemScalarWhereWithAggregatesInput | eventitemScalarWhereWithAggregatesInput[]
    OR?: eventitemScalarWhereWithAggregatesInput[]
    NOT?: eventitemScalarWhereWithAggregatesInput | eventitemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"eventitem"> | string
    title?: StringWithAggregatesFilter<"eventitem"> | string
    description?: StringWithAggregatesFilter<"eventitem"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    linkPath?: StringWithAggregatesFilter<"eventitem"> | string
    category?: Enumeventitem_categoryNullableWithAggregatesFilter<"eventitem"> | $Enums.eventitem_category | null
    date?: DateTimeNullableWithAggregatesFilter<"eventitem"> | Date | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"eventitem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"eventitem"> | Date | string
    location?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    time?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    expectations?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    guests?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    registrationLink?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    capacity?: IntNullableWithAggregatesFilter<"eventitem"> | number | null
    isFeeRequired?: BoolWithAggregatesFilter<"eventitem"> | boolean
    feeAmount?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"eventitem"> | string | null
    likes?: IntWithAggregatesFilter<"eventitem"> | number
  }

  export type expenserecordWhereInput = {
    AND?: expenserecordWhereInput | expenserecordWhereInput[]
    OR?: expenserecordWhereInput[]
    NOT?: expenserecordWhereInput | expenserecordWhereInput[]
    id?: StringFilter<"expenserecord"> | string
    expenseDate?: DateTimeFilter<"expenserecord"> | Date | string
    category?: Enumexpenserecord_categoryFilter<"expenserecord"> | $Enums.expenserecord_category
    description?: StringFilter<"expenserecord"> | string
    amount?: DecimalFilter<"expenserecord"> | Decimal | DecimalJsLike | number | string
    payee?: StringNullableFilter<"expenserecord"> | string | null
    paymentMethod?: Enumexpenserecord_paymentMethodNullableFilter<"expenserecord"> | $Enums.expenserecord_paymentMethod | null
    transactionReference?: StringNullableFilter<"expenserecord"> | string | null
    receiptUrl?: StringNullableFilter<"expenserecord"> | string | null
    approvedBy?: StringNullableFilter<"expenserecord"> | string | null
    notes?: StringNullableFilter<"expenserecord"> | string | null
    source?: StringNullableFilter<"expenserecord"> | string | null
    location?: StringNullableFilter<"expenserecord"> | string | null
    status?: Enumexpenserecord_statusNullableFilter<"expenserecord"> | $Enums.expenserecord_status | null
    postedByOwnerId?: StringNullableFilter<"expenserecord"> | string | null
    postedByOwnerName?: StringNullableFilter<"expenserecord"> | string | null
    createdAt?: DateTimeFilter<"expenserecord"> | Date | string
    updatedAt?: DateTimeFilter<"expenserecord"> | Date | string
  }

  export type expenserecordOrderByWithRelationInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    payee?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionReference?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type expenserecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: expenserecordWhereInput | expenserecordWhereInput[]
    OR?: expenserecordWhereInput[]
    NOT?: expenserecordWhereInput | expenserecordWhereInput[]
    expenseDate?: DateTimeFilter<"expenserecord"> | Date | string
    category?: Enumexpenserecord_categoryFilter<"expenserecord"> | $Enums.expenserecord_category
    description?: StringFilter<"expenserecord"> | string
    amount?: DecimalFilter<"expenserecord"> | Decimal | DecimalJsLike | number | string
    payee?: StringNullableFilter<"expenserecord"> | string | null
    paymentMethod?: Enumexpenserecord_paymentMethodNullableFilter<"expenserecord"> | $Enums.expenserecord_paymentMethod | null
    transactionReference?: StringNullableFilter<"expenserecord"> | string | null
    receiptUrl?: StringNullableFilter<"expenserecord"> | string | null
    approvedBy?: StringNullableFilter<"expenserecord"> | string | null
    notes?: StringNullableFilter<"expenserecord"> | string | null
    source?: StringNullableFilter<"expenserecord"> | string | null
    location?: StringNullableFilter<"expenserecord"> | string | null
    status?: Enumexpenserecord_statusNullableFilter<"expenserecord"> | $Enums.expenserecord_status | null
    postedByOwnerId?: StringNullableFilter<"expenserecord"> | string | null
    postedByOwnerName?: StringNullableFilter<"expenserecord"> | string | null
    createdAt?: DateTimeFilter<"expenserecord"> | Date | string
    updatedAt?: DateTimeFilter<"expenserecord"> | Date | string
  }, "id">

  export type expenserecordOrderByWithAggregationInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    payee?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    transactionReference?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: expenserecordCountOrderByAggregateInput
    _avg?: expenserecordAvgOrderByAggregateInput
    _max?: expenserecordMaxOrderByAggregateInput
    _min?: expenserecordMinOrderByAggregateInput
    _sum?: expenserecordSumOrderByAggregateInput
  }

  export type expenserecordScalarWhereWithAggregatesInput = {
    AND?: expenserecordScalarWhereWithAggregatesInput | expenserecordScalarWhereWithAggregatesInput[]
    OR?: expenserecordScalarWhereWithAggregatesInput[]
    NOT?: expenserecordScalarWhereWithAggregatesInput | expenserecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"expenserecord"> | string
    expenseDate?: DateTimeWithAggregatesFilter<"expenserecord"> | Date | string
    category?: Enumexpenserecord_categoryWithAggregatesFilter<"expenserecord"> | $Enums.expenserecord_category
    description?: StringWithAggregatesFilter<"expenserecord"> | string
    amount?: DecimalWithAggregatesFilter<"expenserecord"> | Decimal | DecimalJsLike | number | string
    payee?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    paymentMethod?: Enumexpenserecord_paymentMethodNullableWithAggregatesFilter<"expenserecord"> | $Enums.expenserecord_paymentMethod | null
    transactionReference?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    notes?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    source?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    location?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    status?: Enumexpenserecord_statusNullableWithAggregatesFilter<"expenserecord"> | $Enums.expenserecord_status | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"expenserecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"expenserecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"expenserecord"> | Date | string
  }

  export type fellowshiprosteritemWhereInput = {
    AND?: fellowshiprosteritemWhereInput | fellowshiprosteritemWhereInput[]
    OR?: fellowshiprosteritemWhereInput[]
    NOT?: fellowshiprosteritemWhereInput | fellowshiprosteritemWhereInput[]
    id?: StringFilter<"fellowshiprosteritem"> | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFilter<"fellowshiprosteritem"> | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFilter<"fellowshiprosteritem"> | string
    assignedDate?: DateTimeFilter<"fellowshiprosteritem"> | Date | string
    timeSlot?: StringFilter<"fellowshiprosteritem"> | string
    location?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    contactNumber?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    additionalNotesOrProgramDetails?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    isTemplate?: BoolFilter<"fellowshiprosteritem"> | boolean
    postedByOwnerId?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    postedByOwnerName?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    createdAt?: DateTimeFilter<"fellowshiprosteritem"> | Date | string
    updatedAt?: DateTimeFilter<"fellowshiprosteritem"> | Date | string
    generatedscheduleitem?: GeneratedscheduleitemListRelationFilter
    responsibility?: ResponsibilityListRelationFilter
  }

  export type fellowshiprosteritemOrderByWithRelationInput = {
    id?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    assignedDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    additionalNotesOrProgramDetails?: SortOrderInput | SortOrder
    isTemplate?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedscheduleitem?: generatedscheduleitemOrderByRelationAggregateInput
    responsibility?: responsibilityOrderByRelationAggregateInput
  }

  export type fellowshiprosteritemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: fellowshiprosteritemWhereInput | fellowshiprosteritemWhereInput[]
    OR?: fellowshiprosteritemWhereInput[]
    NOT?: fellowshiprosteritemWhereInput | fellowshiprosteritemWhereInput[]
    rosterType?: Enumfellowshiprosteritem_rosterTypeFilter<"fellowshiprosteritem"> | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFilter<"fellowshiprosteritem"> | string
    assignedDate?: DateTimeFilter<"fellowshiprosteritem"> | Date | string
    timeSlot?: StringFilter<"fellowshiprosteritem"> | string
    location?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    contactNumber?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    additionalNotesOrProgramDetails?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    isTemplate?: BoolFilter<"fellowshiprosteritem"> | boolean
    postedByOwnerId?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    postedByOwnerName?: StringNullableFilter<"fellowshiprosteritem"> | string | null
    createdAt?: DateTimeFilter<"fellowshiprosteritem"> | Date | string
    updatedAt?: DateTimeFilter<"fellowshiprosteritem"> | Date | string
    generatedscheduleitem?: GeneratedscheduleitemListRelationFilter
    responsibility?: ResponsibilityListRelationFilter
  }, "id">

  export type fellowshiprosteritemOrderByWithAggregationInput = {
    id?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    assignedDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    additionalNotesOrProgramDetails?: SortOrderInput | SortOrder
    isTemplate?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: fellowshiprosteritemCountOrderByAggregateInput
    _max?: fellowshiprosteritemMaxOrderByAggregateInput
    _min?: fellowshiprosteritemMinOrderByAggregateInput
  }

  export type fellowshiprosteritemScalarWhereWithAggregatesInput = {
    AND?: fellowshiprosteritemScalarWhereWithAggregatesInput | fellowshiprosteritemScalarWhereWithAggregatesInput[]
    OR?: fellowshiprosteritemScalarWhereWithAggregatesInput[]
    NOT?: fellowshiprosteritemScalarWhereWithAggregatesInput | fellowshiprosteritemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"fellowshiprosteritem"> | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeWithAggregatesFilter<"fellowshiprosteritem"> | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringWithAggregatesFilter<"fellowshiprosteritem"> | string
    assignedDate?: DateTimeWithAggregatesFilter<"fellowshiprosteritem"> | Date | string
    timeSlot?: StringWithAggregatesFilter<"fellowshiprosteritem"> | string
    location?: StringNullableWithAggregatesFilter<"fellowshiprosteritem"> | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"fellowshiprosteritem"> | string | null
    additionalNotesOrProgramDetails?: StringNullableWithAggregatesFilter<"fellowshiprosteritem"> | string | null
    isTemplate?: BoolWithAggregatesFilter<"fellowshiprosteritem"> | boolean
    postedByOwnerId?: StringNullableWithAggregatesFilter<"fellowshiprosteritem"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"fellowshiprosteritem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"fellowshiprosteritem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"fellowshiprosteritem"> | Date | string
  }

  export type friendshipWhereInput = {
    AND?: friendshipWhereInput | friendshipWhereInput[]
    OR?: friendshipWhereInput[]
    NOT?: friendshipWhereInput | friendshipWhereInput[]
    id?: StringFilter<"friendship"> | string
    requesterId?: StringFilter<"friendship"> | string
    addresseeId?: StringFilter<"friendship"> | string
    status?: Enumfriendship_statusFilter<"friendship"> | $Enums.friendship_status
    requestedAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeFilter<"friendship"> | Date | string
    user_friendship_addresseeIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_friendship_requesterIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }

  export type friendshipOrderByWithRelationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
    user_friendship_addresseeIdTouser?: userOrderByWithRelationInput
    user_friendship_requesterIdTouser?: userOrderByWithRelationInput
  }

  export type friendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requesterId_addresseeId?: friendshipRequesterIdAddresseeIdCompoundUniqueInput
    AND?: friendshipWhereInput | friendshipWhereInput[]
    OR?: friendshipWhereInput[]
    NOT?: friendshipWhereInput | friendshipWhereInput[]
    requesterId?: StringFilter<"friendship"> | string
    addresseeId?: StringFilter<"friendship"> | string
    status?: Enumfriendship_statusFilter<"friendship"> | $Enums.friendship_status
    requestedAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeFilter<"friendship"> | Date | string
    user_friendship_addresseeIdTouser?: XOR<UserRelationFilter, userWhereInput>
    user_friendship_requesterIdTouser?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "requesterId_addresseeId">

  export type friendshipOrderByWithAggregationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: friendshipCountOrderByAggregateInput
    _max?: friendshipMaxOrderByAggregateInput
    _min?: friendshipMinOrderByAggregateInput
  }

  export type friendshipScalarWhereWithAggregatesInput = {
    AND?: friendshipScalarWhereWithAggregatesInput | friendshipScalarWhereWithAggregatesInput[]
    OR?: friendshipScalarWhereWithAggregatesInput[]
    NOT?: friendshipScalarWhereWithAggregatesInput | friendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"friendship"> | string
    requesterId?: StringWithAggregatesFilter<"friendship"> | string
    addresseeId?: StringWithAggregatesFilter<"friendship"> | string
    status?: Enumfriendship_statusWithAggregatesFilter<"friendship"> | $Enums.friendship_status
    requestedAt?: DateTimeWithAggregatesFilter<"friendship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"friendship"> | Date | string
  }

  export type frontendactivitylogWhereInput = {
    AND?: frontendactivitylogWhereInput | frontendactivitylogWhereInput[]
    OR?: frontendactivitylogWhereInput[]
    NOT?: frontendactivitylogWhereInput | frontendactivitylogWhereInput[]
    id?: StringFilter<"frontendactivitylog"> | string
    timestamp?: DateTimeFilter<"frontendactivitylog"> | Date | string
    userId?: StringNullableFilter<"frontendactivitylog"> | string | null
    description?: StringFilter<"frontendactivitylog"> | string
    type?: StringFilter<"frontendactivitylog"> | string
    itemId?: StringNullableFilter<"frontendactivitylog"> | string | null
    itemType?: StringNullableFilter<"frontendactivitylog"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type frontendactivitylogOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    description?: SortOrder
    type?: SortOrder
    itemId?: SortOrderInput | SortOrder
    itemType?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type frontendactivitylogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: frontendactivitylogWhereInput | frontendactivitylogWhereInput[]
    OR?: frontendactivitylogWhereInput[]
    NOT?: frontendactivitylogWhereInput | frontendactivitylogWhereInput[]
    timestamp?: DateTimeFilter<"frontendactivitylog"> | Date | string
    userId?: StringNullableFilter<"frontendactivitylog"> | string | null
    description?: StringFilter<"frontendactivitylog"> | string
    type?: StringFilter<"frontendactivitylog"> | string
    itemId?: StringNullableFilter<"frontendactivitylog"> | string | null
    itemType?: StringNullableFilter<"frontendactivitylog"> | string | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type frontendactivitylogOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrderInput | SortOrder
    description?: SortOrder
    type?: SortOrder
    itemId?: SortOrderInput | SortOrder
    itemType?: SortOrderInput | SortOrder
    _count?: frontendactivitylogCountOrderByAggregateInput
    _max?: frontendactivitylogMaxOrderByAggregateInput
    _min?: frontendactivitylogMinOrderByAggregateInput
  }

  export type frontendactivitylogScalarWhereWithAggregatesInput = {
    AND?: frontendactivitylogScalarWhereWithAggregatesInput | frontendactivitylogScalarWhereWithAggregatesInput[]
    OR?: frontendactivitylogScalarWhereWithAggregatesInput[]
    NOT?: frontendactivitylogScalarWhereWithAggregatesInput | frontendactivitylogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"frontendactivitylog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"frontendactivitylog"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"frontendactivitylog"> | string | null
    description?: StringWithAggregatesFilter<"frontendactivitylog"> | string
    type?: StringWithAggregatesFilter<"frontendactivitylog"> | string
    itemId?: StringNullableWithAggregatesFilter<"frontendactivitylog"> | string | null
    itemType?: StringNullableWithAggregatesFilter<"frontendactivitylog"> | string | null
  }

  export type generatedscheduleitemWhereInput = {
    AND?: generatedscheduleitemWhereInput | generatedscheduleitemWhereInput[]
    OR?: generatedscheduleitemWhereInput[]
    NOT?: generatedscheduleitemWhereInput | generatedscheduleitemWhereInput[]
    id?: StringFilter<"generatedscheduleitem"> | string
    basedOnRosterItemId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFilter<"generatedscheduleitem"> | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFilter<"generatedscheduleitem"> | string
    scheduledDate?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    timeSlot?: StringFilter<"generatedscheduleitem"> | string
    location?: StringNullableFilter<"generatedscheduleitem"> | string | null
    contactNumber?: StringNullableFilter<"generatedscheduleitem"> | string | null
    additionalNotesOrProgramDetails?: StringNullableFilter<"generatedscheduleitem"> | string | null
    generatedAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    isPublishedAsEvent?: BoolFilter<"generatedscheduleitem"> | boolean
    publishedEventId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    adminNotes?: StringNullableFilter<"generatedscheduleitem"> | string | null
    postedByOwnerId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"generatedscheduleitem"> | string | null
    createdAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    updatedAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    fellowshiprosteritem?: XOR<FellowshiprosteritemNullableRelationFilter, fellowshiprosteritemWhereInput> | null
    responsibility?: ResponsibilityListRelationFilter
  }

  export type generatedscheduleitemOrderByWithRelationInput = {
    id?: SortOrder
    basedOnRosterItemId?: SortOrderInput | SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    scheduledDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    additionalNotesOrProgramDetails?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    isPublishedAsEvent?: SortOrder
    publishedEventId?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fellowshiprosteritem?: fellowshiprosteritemOrderByWithRelationInput
    responsibility?: responsibilityOrderByRelationAggregateInput
  }

  export type generatedscheduleitemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: generatedscheduleitemWhereInput | generatedscheduleitemWhereInput[]
    OR?: generatedscheduleitemWhereInput[]
    NOT?: generatedscheduleitemWhereInput | generatedscheduleitemWhereInput[]
    basedOnRosterItemId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFilter<"generatedscheduleitem"> | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFilter<"generatedscheduleitem"> | string
    scheduledDate?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    timeSlot?: StringFilter<"generatedscheduleitem"> | string
    location?: StringNullableFilter<"generatedscheduleitem"> | string | null
    contactNumber?: StringNullableFilter<"generatedscheduleitem"> | string | null
    additionalNotesOrProgramDetails?: StringNullableFilter<"generatedscheduleitem"> | string | null
    generatedAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    isPublishedAsEvent?: BoolFilter<"generatedscheduleitem"> | boolean
    publishedEventId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    adminNotes?: StringNullableFilter<"generatedscheduleitem"> | string | null
    postedByOwnerId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"generatedscheduleitem"> | string | null
    createdAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    updatedAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    fellowshiprosteritem?: XOR<FellowshiprosteritemNullableRelationFilter, fellowshiprosteritemWhereInput> | null
    responsibility?: ResponsibilityListRelationFilter
  }, "id">

  export type generatedscheduleitemOrderByWithAggregationInput = {
    id?: SortOrder
    basedOnRosterItemId?: SortOrderInput | SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    scheduledDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    additionalNotesOrProgramDetails?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    isPublishedAsEvent?: SortOrder
    publishedEventId?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: generatedscheduleitemCountOrderByAggregateInput
    _max?: generatedscheduleitemMaxOrderByAggregateInput
    _min?: generatedscheduleitemMinOrderByAggregateInput
  }

  export type generatedscheduleitemScalarWhereWithAggregatesInput = {
    AND?: generatedscheduleitemScalarWhereWithAggregatesInput | generatedscheduleitemScalarWhereWithAggregatesInput[]
    OR?: generatedscheduleitemScalarWhereWithAggregatesInput[]
    NOT?: generatedscheduleitemScalarWhereWithAggregatesInput | generatedscheduleitemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"generatedscheduleitem"> | string
    basedOnRosterItemId?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    rosterType?: Enumgeneratedscheduleitem_rosterTypeWithAggregatesFilter<"generatedscheduleitem"> | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringWithAggregatesFilter<"generatedscheduleitem"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"generatedscheduleitem"> | Date | string
    timeSlot?: StringWithAggregatesFilter<"generatedscheduleitem"> | string
    location?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    additionalNotesOrProgramDetails?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"generatedscheduleitem"> | Date | string
    isPublishedAsEvent?: BoolWithAggregatesFilter<"generatedscheduleitem"> | boolean
    publishedEventId?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"generatedscheduleitem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"generatedscheduleitem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"generatedscheduleitem"> | Date | string
  }

  export type groupWhereInput = {
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    id?: StringFilter<"group"> | string
    name?: StringFilter<"group"> | string
    creatorId?: StringFilter<"group"> | string
    groupImageUrl?: StringNullableFilter<"group"> | string | null
    createdAt?: DateTimeFilter<"group"> | Date | string
    updatedAt?: DateTimeFilter<"group"> | Date | string
    editSettings?: Enumgroup_editSettingsFilter<"group"> | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFilter<"group"> | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFilter<"group"> | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFilter<"group"> | $Enums.group_approveMembers
    groupmember?: GroupmemberListRelationFilter
    groupmessage?: GroupmessageListRelationFilter
  }

  export type groupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    groupImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editSettings?: SortOrder
    sendMessage?: SortOrder
    addMembers?: SortOrder
    approveMembers?: SortOrder
    groupmember?: groupmemberOrderByRelationAggregateInput
    groupmessage?: groupmessageOrderByRelationAggregateInput
  }

  export type groupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    name?: StringFilter<"group"> | string
    creatorId?: StringFilter<"group"> | string
    groupImageUrl?: StringNullableFilter<"group"> | string | null
    createdAt?: DateTimeFilter<"group"> | Date | string
    updatedAt?: DateTimeFilter<"group"> | Date | string
    editSettings?: Enumgroup_editSettingsFilter<"group"> | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFilter<"group"> | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFilter<"group"> | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFilter<"group"> | $Enums.group_approveMembers
    groupmember?: GroupmemberListRelationFilter
    groupmessage?: GroupmessageListRelationFilter
  }, "id">

  export type groupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    groupImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editSettings?: SortOrder
    sendMessage?: SortOrder
    addMembers?: SortOrder
    approveMembers?: SortOrder
    _count?: groupCountOrderByAggregateInput
    _max?: groupMaxOrderByAggregateInput
    _min?: groupMinOrderByAggregateInput
  }

  export type groupScalarWhereWithAggregatesInput = {
    AND?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    OR?: groupScalarWhereWithAggregatesInput[]
    NOT?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"group"> | string
    name?: StringWithAggregatesFilter<"group"> | string
    creatorId?: StringWithAggregatesFilter<"group"> | string
    groupImageUrl?: StringNullableWithAggregatesFilter<"group"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"group"> | Date | string
    editSettings?: Enumgroup_editSettingsWithAggregatesFilter<"group"> | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageWithAggregatesFilter<"group"> | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersWithAggregatesFilter<"group"> | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersWithAggregatesFilter<"group"> | $Enums.group_approveMembers
  }

  export type groupmemberWhereInput = {
    AND?: groupmemberWhereInput | groupmemberWhereInput[]
    OR?: groupmemberWhereInput[]
    NOT?: groupmemberWhereInput | groupmemberWhereInput[]
    id?: StringFilter<"groupmember"> | string
    groupId?: StringFilter<"groupmember"> | string
    userId?: StringFilter<"groupmember"> | string
    role?: Enumgroupmember_roleFilter<"groupmember"> | $Enums.groupmember_role
    addedAt?: DateTimeFilter<"groupmember"> | Date | string
    group?: XOR<GroupRelationFilter, groupWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type groupmemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    addedAt?: SortOrder
    group?: groupOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type groupmemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: groupmemberGroupIdUserIdCompoundUniqueInput
    AND?: groupmemberWhereInput | groupmemberWhereInput[]
    OR?: groupmemberWhereInput[]
    NOT?: groupmemberWhereInput | groupmemberWhereInput[]
    groupId?: StringFilter<"groupmember"> | string
    userId?: StringFilter<"groupmember"> | string
    role?: Enumgroupmember_roleFilter<"groupmember"> | $Enums.groupmember_role
    addedAt?: DateTimeFilter<"groupmember"> | Date | string
    group?: XOR<GroupRelationFilter, groupWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "groupId_userId">

  export type groupmemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    addedAt?: SortOrder
    _count?: groupmemberCountOrderByAggregateInput
    _max?: groupmemberMaxOrderByAggregateInput
    _min?: groupmemberMinOrderByAggregateInput
  }

  export type groupmemberScalarWhereWithAggregatesInput = {
    AND?: groupmemberScalarWhereWithAggregatesInput | groupmemberScalarWhereWithAggregatesInput[]
    OR?: groupmemberScalarWhereWithAggregatesInput[]
    NOT?: groupmemberScalarWhereWithAggregatesInput | groupmemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"groupmember"> | string
    groupId?: StringWithAggregatesFilter<"groupmember"> | string
    userId?: StringWithAggregatesFilter<"groupmember"> | string
    role?: Enumgroupmember_roleWithAggregatesFilter<"groupmember"> | $Enums.groupmember_role
    addedAt?: DateTimeWithAggregatesFilter<"groupmember"> | Date | string
  }

  export type groupmessageWhereInput = {
    AND?: groupmessageWhereInput | groupmessageWhereInput[]
    OR?: groupmessageWhereInput[]
    NOT?: groupmessageWhereInput | groupmessageWhereInput[]
    id?: StringFilter<"groupmessage"> | string
    groupId?: StringFilter<"groupmessage"> | string
    senderId?: StringFilter<"groupmessage"> | string
    senderName?: StringFilter<"groupmessage"> | string
    senderProfileImageUrl?: StringNullableFilter<"groupmessage"> | string | null
    text?: StringNullableFilter<"groupmessage"> | string | null
    mediaUrl?: StringNullableFilter<"groupmessage"> | string | null
    mediaType?: Enumgroupmessage_mediaTypeNullableFilter<"groupmessage"> | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFilter<"groupmessage"> | Date | string
    group?: XOR<GroupRelationFilter, groupWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type groupmessageOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderProfileImageUrl?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    group?: groupOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type groupmessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: groupmessageWhereInput | groupmessageWhereInput[]
    OR?: groupmessageWhereInput[]
    NOT?: groupmessageWhereInput | groupmessageWhereInput[]
    groupId?: StringFilter<"groupmessage"> | string
    senderId?: StringFilter<"groupmessage"> | string
    senderName?: StringFilter<"groupmessage"> | string
    senderProfileImageUrl?: StringNullableFilter<"groupmessage"> | string | null
    text?: StringNullableFilter<"groupmessage"> | string | null
    mediaUrl?: StringNullableFilter<"groupmessage"> | string | null
    mediaType?: Enumgroupmessage_mediaTypeNullableFilter<"groupmessage"> | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFilter<"groupmessage"> | Date | string
    group?: XOR<GroupRelationFilter, groupWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type groupmessageOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderProfileImageUrl?: SortOrderInput | SortOrder
    text?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    mediaType?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: groupmessageCountOrderByAggregateInput
    _max?: groupmessageMaxOrderByAggregateInput
    _min?: groupmessageMinOrderByAggregateInput
  }

  export type groupmessageScalarWhereWithAggregatesInput = {
    AND?: groupmessageScalarWhereWithAggregatesInput | groupmessageScalarWhereWithAggregatesInput[]
    OR?: groupmessageScalarWhereWithAggregatesInput[]
    NOT?: groupmessageScalarWhereWithAggregatesInput | groupmessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"groupmessage"> | string
    groupId?: StringWithAggregatesFilter<"groupmessage"> | string
    senderId?: StringWithAggregatesFilter<"groupmessage"> | string
    senderName?: StringWithAggregatesFilter<"groupmessage"> | string
    senderProfileImageUrl?: StringNullableWithAggregatesFilter<"groupmessage"> | string | null
    text?: StringNullableWithAggregatesFilter<"groupmessage"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"groupmessage"> | string | null
    mediaType?: Enumgroupmessage_mediaTypeNullableWithAggregatesFilter<"groupmessage"> | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeWithAggregatesFilter<"groupmessage"> | Date | string
  }

  export type historychapterWhereInput = {
    AND?: historychapterWhereInput | historychapterWhereInput[]
    OR?: historychapterWhereInput[]
    NOT?: historychapterWhereInput | historychapterWhereInput[]
    id?: StringFilter<"historychapter"> | string
    chapterNumber?: IntFilter<"historychapter"> | number
    title?: StringFilter<"historychapter"> | string
    content?: StringFilter<"historychapter"> | string
    status?: Enumhistorychapter_statusFilter<"historychapter"> | $Enums.historychapter_status
    imageUrl?: StringNullableFilter<"historychapter"> | string | null
    summary?: StringNullableFilter<"historychapter"> | string | null
    authorId?: StringNullableFilter<"historychapter"> | string | null
    authorName?: StringNullableFilter<"historychapter"> | string | null
    createdAt?: DateTimeFilter<"historychapter"> | Date | string
    updatedAt?: DateTimeFilter<"historychapter"> | Date | string
    lastPublishedAt?: DateTimeNullableFilter<"historychapter"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"historychapter"> | string | null
    postedByOwnerName?: StringNullableFilter<"historychapter"> | string | null
    likes?: IntFilter<"historychapter"> | number
    comment?: CommentListRelationFilter
  }

  export type historychapterOrderByWithRelationInput = {
    id?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    authorName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPublishedAt?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    likes?: SortOrder
    comment?: commentOrderByRelationAggregateInput
  }

  export type historychapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: historychapterWhereInput | historychapterWhereInput[]
    OR?: historychapterWhereInput[]
    NOT?: historychapterWhereInput | historychapterWhereInput[]
    chapterNumber?: IntFilter<"historychapter"> | number
    title?: StringFilter<"historychapter"> | string
    content?: StringFilter<"historychapter"> | string
    status?: Enumhistorychapter_statusFilter<"historychapter"> | $Enums.historychapter_status
    imageUrl?: StringNullableFilter<"historychapter"> | string | null
    summary?: StringNullableFilter<"historychapter"> | string | null
    authorId?: StringNullableFilter<"historychapter"> | string | null
    authorName?: StringNullableFilter<"historychapter"> | string | null
    createdAt?: DateTimeFilter<"historychapter"> | Date | string
    updatedAt?: DateTimeFilter<"historychapter"> | Date | string
    lastPublishedAt?: DateTimeNullableFilter<"historychapter"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"historychapter"> | string | null
    postedByOwnerName?: StringNullableFilter<"historychapter"> | string | null
    likes?: IntFilter<"historychapter"> | number
    comment?: CommentListRelationFilter
  }, "id">

  export type historychapterOrderByWithAggregationInput = {
    id?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    authorName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPublishedAt?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    likes?: SortOrder
    _count?: historychapterCountOrderByAggregateInput
    _avg?: historychapterAvgOrderByAggregateInput
    _max?: historychapterMaxOrderByAggregateInput
    _min?: historychapterMinOrderByAggregateInput
    _sum?: historychapterSumOrderByAggregateInput
  }

  export type historychapterScalarWhereWithAggregatesInput = {
    AND?: historychapterScalarWhereWithAggregatesInput | historychapterScalarWhereWithAggregatesInput[]
    OR?: historychapterScalarWhereWithAggregatesInput[]
    NOT?: historychapterScalarWhereWithAggregatesInput | historychapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"historychapter"> | string
    chapterNumber?: IntWithAggregatesFilter<"historychapter"> | number
    title?: StringWithAggregatesFilter<"historychapter"> | string
    content?: StringWithAggregatesFilter<"historychapter"> | string
    status?: Enumhistorychapter_statusWithAggregatesFilter<"historychapter"> | $Enums.historychapter_status
    imageUrl?: StringNullableWithAggregatesFilter<"historychapter"> | string | null
    summary?: StringNullableWithAggregatesFilter<"historychapter"> | string | null
    authorId?: StringNullableWithAggregatesFilter<"historychapter"> | string | null
    authorName?: StringNullableWithAggregatesFilter<"historychapter"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"historychapter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"historychapter"> | Date | string
    lastPublishedAt?: DateTimeNullableWithAggregatesFilter<"historychapter"> | Date | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"historychapter"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"historychapter"> | string | null
    likes?: IntWithAggregatesFilter<"historychapter"> | number
  }

  export type historymilestoneWhereInput = {
    AND?: historymilestoneWhereInput | historymilestoneWhereInput[]
    OR?: historymilestoneWhereInput[]
    NOT?: historymilestoneWhereInput | historymilestoneWhereInput[]
    id?: StringFilter<"historymilestone"> | string
    year?: StringFilter<"historymilestone"> | string
    title?: StringFilter<"historymilestone"> | string
    description?: StringFilter<"historymilestone"> | string
    imageUrl?: StringNullableFilter<"historymilestone"> | string | null
    createdAt?: DateTimeFilter<"historymilestone"> | Date | string
    updatedAt?: DateTimeFilter<"historymilestone"> | Date | string
    postedByOwnerId?: StringNullableFilter<"historymilestone"> | string | null
    postedByOwnerName?: StringNullableFilter<"historymilestone"> | string | null
  }

  export type historymilestoneOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
  }

  export type historymilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: historymilestoneWhereInput | historymilestoneWhereInput[]
    OR?: historymilestoneWhereInput[]
    NOT?: historymilestoneWhereInput | historymilestoneWhereInput[]
    year?: StringFilter<"historymilestone"> | string
    title?: StringFilter<"historymilestone"> | string
    description?: StringFilter<"historymilestone"> | string
    imageUrl?: StringNullableFilter<"historymilestone"> | string | null
    createdAt?: DateTimeFilter<"historymilestone"> | Date | string
    updatedAt?: DateTimeFilter<"historymilestone"> | Date | string
    postedByOwnerId?: StringNullableFilter<"historymilestone"> | string | null
    postedByOwnerName?: StringNullableFilter<"historymilestone"> | string | null
  }, "id">

  export type historymilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    _count?: historymilestoneCountOrderByAggregateInput
    _max?: historymilestoneMaxOrderByAggregateInput
    _min?: historymilestoneMinOrderByAggregateInput
  }

  export type historymilestoneScalarWhereWithAggregatesInput = {
    AND?: historymilestoneScalarWhereWithAggregatesInput | historymilestoneScalarWhereWithAggregatesInput[]
    OR?: historymilestoneScalarWhereWithAggregatesInput[]
    NOT?: historymilestoneScalarWhereWithAggregatesInput | historymilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"historymilestone"> | string
    year?: StringWithAggregatesFilter<"historymilestone"> | string
    title?: StringWithAggregatesFilter<"historymilestone"> | string
    description?: StringWithAggregatesFilter<"historymilestone"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"historymilestone"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"historymilestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"historymilestone"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"historymilestone"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"historymilestone"> | string | null
  }

  export type homeslideWhereInput = {
    AND?: homeslideWhereInput | homeslideWhereInput[]
    OR?: homeslideWhereInput[]
    NOT?: homeslideWhereInput | homeslideWhereInput[]
    id?: StringFilter<"homeslide"> | string
    title?: StringFilter<"homeslide"> | string
    description?: StringFilter<"homeslide"> | string
    imageUrl?: StringFilter<"homeslide"> | string
    ctaText?: StringFilter<"homeslide"> | string
    linkPath?: StringFilter<"homeslide"> | string
    order?: IntFilter<"homeslide"> | number
    isActive?: BoolFilter<"homeslide"> | boolean
    createdAt?: DateTimeFilter<"homeslide"> | Date | string
    updatedAt?: DateTimeFilter<"homeslide"> | Date | string
    postedByOwnerId?: StringNullableFilter<"homeslide"> | string | null
    postedByOwnerName?: StringNullableFilter<"homeslide"> | string | null
  }

  export type homeslideOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ctaText?: SortOrder
    linkPath?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
  }

  export type homeslideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: homeslideWhereInput | homeslideWhereInput[]
    OR?: homeslideWhereInput[]
    NOT?: homeslideWhereInput | homeslideWhereInput[]
    title?: StringFilter<"homeslide"> | string
    description?: StringFilter<"homeslide"> | string
    imageUrl?: StringFilter<"homeslide"> | string
    ctaText?: StringFilter<"homeslide"> | string
    linkPath?: StringFilter<"homeslide"> | string
    order?: IntFilter<"homeslide"> | number
    isActive?: BoolFilter<"homeslide"> | boolean
    createdAt?: DateTimeFilter<"homeslide"> | Date | string
    updatedAt?: DateTimeFilter<"homeslide"> | Date | string
    postedByOwnerId?: StringNullableFilter<"homeslide"> | string | null
    postedByOwnerName?: StringNullableFilter<"homeslide"> | string | null
  }, "id">

  export type homeslideOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ctaText?: SortOrder
    linkPath?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    _count?: homeslideCountOrderByAggregateInput
    _avg?: homeslideAvgOrderByAggregateInput
    _max?: homeslideMaxOrderByAggregateInput
    _min?: homeslideMinOrderByAggregateInput
    _sum?: homeslideSumOrderByAggregateInput
  }

  export type homeslideScalarWhereWithAggregatesInput = {
    AND?: homeslideScalarWhereWithAggregatesInput | homeslideScalarWhereWithAggregatesInput[]
    OR?: homeslideScalarWhereWithAggregatesInput[]
    NOT?: homeslideScalarWhereWithAggregatesInput | homeslideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"homeslide"> | string
    title?: StringWithAggregatesFilter<"homeslide"> | string
    description?: StringWithAggregatesFilter<"homeslide"> | string
    imageUrl?: StringWithAggregatesFilter<"homeslide"> | string
    ctaText?: StringWithAggregatesFilter<"homeslide"> | string
    linkPath?: StringWithAggregatesFilter<"homeslide"> | string
    order?: IntWithAggregatesFilter<"homeslide"> | number
    isActive?: BoolWithAggregatesFilter<"homeslide"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"homeslide"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"homeslide"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"homeslide"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"homeslide"> | string | null
  }

  export type keypersonWhereInput = {
    AND?: keypersonWhereInput | keypersonWhereInput[]
    OR?: keypersonWhereInput[]
    NOT?: keypersonWhereInput | keypersonWhereInput[]
    id?: StringFilter<"keyperson"> | string
    name?: StringFilter<"keyperson"> | string
    role?: StringFilter<"keyperson"> | string
    imageUrl?: StringNullableFilter<"keyperson"> | string | null
    bio?: StringFilter<"keyperson"> | string
    createdAt?: DateTimeFilter<"keyperson"> | Date | string
    updatedAt?: DateTimeFilter<"keyperson"> | Date | string
    postedByOwnerId?: StringNullableFilter<"keyperson"> | string | null
    postedByOwnerName?: StringNullableFilter<"keyperson"> | string | null
  }

  export type keypersonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
  }

  export type keypersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: keypersonWhereInput | keypersonWhereInput[]
    OR?: keypersonWhereInput[]
    NOT?: keypersonWhereInput | keypersonWhereInput[]
    name?: StringFilter<"keyperson"> | string
    role?: StringFilter<"keyperson"> | string
    imageUrl?: StringNullableFilter<"keyperson"> | string | null
    bio?: StringFilter<"keyperson"> | string
    createdAt?: DateTimeFilter<"keyperson"> | Date | string
    updatedAt?: DateTimeFilter<"keyperson"> | Date | string
    postedByOwnerId?: StringNullableFilter<"keyperson"> | string | null
    postedByOwnerName?: StringNullableFilter<"keyperson"> | string | null
  }, "id">

  export type keypersonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    _count?: keypersonCountOrderByAggregateInput
    _max?: keypersonMaxOrderByAggregateInput
    _min?: keypersonMinOrderByAggregateInput
  }

  export type keypersonScalarWhereWithAggregatesInput = {
    AND?: keypersonScalarWhereWithAggregatesInput | keypersonScalarWhereWithAggregatesInput[]
    OR?: keypersonScalarWhereWithAggregatesInput[]
    NOT?: keypersonScalarWhereWithAggregatesInput | keypersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"keyperson"> | string
    name?: StringWithAggregatesFilter<"keyperson"> | string
    role?: StringWithAggregatesFilter<"keyperson"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"keyperson"> | string | null
    bio?: StringWithAggregatesFilter<"keyperson"> | string
    createdAt?: DateTimeWithAggregatesFilter<"keyperson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"keyperson"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"keyperson"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"keyperson"> | string | null
  }

  export type meetingdecisionpointWhereInput = {
    AND?: meetingdecisionpointWhereInput | meetingdecisionpointWhereInput[]
    OR?: meetingdecisionpointWhereInput[]
    NOT?: meetingdecisionpointWhereInput | meetingdecisionpointWhereInput[]
    id?: StringFilter<"meetingdecisionpoint"> | string
    description?: StringFilter<"meetingdecisionpoint"> | string
    proposedBy?: StringNullableFilter<"meetingdecisionpoint"> | string | null
    status?: Enummeetingdecisionpoint_statusFilter<"meetingdecisionpoint"> | $Enums.meetingdecisionpoint_status
    followUpNotes?: StringNullableFilter<"meetingdecisionpoint"> | string | null
    resolutionDate?: DateTimeNullableFilter<"meetingdecisionpoint"> | Date | string | null
    meetingLogId?: StringFilter<"meetingdecisionpoint"> | string
    meetinglog?: XOR<MeetinglogRelationFilter, meetinglogWhereInput>
  }

  export type meetingdecisionpointOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    proposedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    resolutionDate?: SortOrderInput | SortOrder
    meetingLogId?: SortOrder
    meetinglog?: meetinglogOrderByWithRelationInput
  }

  export type meetingdecisionpointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: meetingdecisionpointWhereInput | meetingdecisionpointWhereInput[]
    OR?: meetingdecisionpointWhereInput[]
    NOT?: meetingdecisionpointWhereInput | meetingdecisionpointWhereInput[]
    description?: StringFilter<"meetingdecisionpoint"> | string
    proposedBy?: StringNullableFilter<"meetingdecisionpoint"> | string | null
    status?: Enummeetingdecisionpoint_statusFilter<"meetingdecisionpoint"> | $Enums.meetingdecisionpoint_status
    followUpNotes?: StringNullableFilter<"meetingdecisionpoint"> | string | null
    resolutionDate?: DateTimeNullableFilter<"meetingdecisionpoint"> | Date | string | null
    meetingLogId?: StringFilter<"meetingdecisionpoint"> | string
    meetinglog?: XOR<MeetinglogRelationFilter, meetinglogWhereInput>
  }, "id">

  export type meetingdecisionpointOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    proposedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    followUpNotes?: SortOrderInput | SortOrder
    resolutionDate?: SortOrderInput | SortOrder
    meetingLogId?: SortOrder
    _count?: meetingdecisionpointCountOrderByAggregateInput
    _max?: meetingdecisionpointMaxOrderByAggregateInput
    _min?: meetingdecisionpointMinOrderByAggregateInput
  }

  export type meetingdecisionpointScalarWhereWithAggregatesInput = {
    AND?: meetingdecisionpointScalarWhereWithAggregatesInput | meetingdecisionpointScalarWhereWithAggregatesInput[]
    OR?: meetingdecisionpointScalarWhereWithAggregatesInput[]
    NOT?: meetingdecisionpointScalarWhereWithAggregatesInput | meetingdecisionpointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"meetingdecisionpoint"> | string
    description?: StringWithAggregatesFilter<"meetingdecisionpoint"> | string
    proposedBy?: StringNullableWithAggregatesFilter<"meetingdecisionpoint"> | string | null
    status?: Enummeetingdecisionpoint_statusWithAggregatesFilter<"meetingdecisionpoint"> | $Enums.meetingdecisionpoint_status
    followUpNotes?: StringNullableWithAggregatesFilter<"meetingdecisionpoint"> | string | null
    resolutionDate?: DateTimeNullableWithAggregatesFilter<"meetingdecisionpoint"> | Date | string | null
    meetingLogId?: StringWithAggregatesFilter<"meetingdecisionpoint"> | string
  }

  export type meetinglogWhereInput = {
    AND?: meetinglogWhereInput | meetinglogWhereInput[]
    OR?: meetinglogWhereInput[]
    NOT?: meetinglogWhereInput | meetinglogWhereInput[]
    id?: StringFilter<"meetinglog"> | string
    meetingDate?: DateTimeFilter<"meetinglog"> | Date | string
    title?: StringFilter<"meetinglog"> | string
    meetingType?: Enummeetinglog_meetingTypeNullableFilter<"meetinglog"> | $Enums.meetinglog_meetingType | null
    attendees?: StringFilter<"meetinglog"> | string
    agenda?: StringFilter<"meetinglog"> | string
    minutes?: StringFilter<"meetinglog"> | string
    actionItems?: StringNullableFilter<"meetinglog"> | string | null
    status?: Enummeetinglog_statusNullableFilter<"meetinglog"> | $Enums.meetinglog_status | null
    imageUrl?: StringNullableFilter<"meetinglog"> | string | null
    postedByOwnerId?: StringNullableFilter<"meetinglog"> | string | null
    postedByOwnerName?: StringNullableFilter<"meetinglog"> | string | null
    createdAt?: DateTimeFilter<"meetinglog"> | Date | string
    updatedAt?: DateTimeFilter<"meetinglog"> | Date | string
    meetingdecisionpoint?: MeetingdecisionpointListRelationFilter
  }

  export type meetinglogOrderByWithRelationInput = {
    id?: SortOrder
    meetingDate?: SortOrder
    title?: SortOrder
    meetingType?: SortOrderInput | SortOrder
    attendees?: SortOrder
    agenda?: SortOrder
    minutes?: SortOrder
    actionItems?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meetingdecisionpoint?: meetingdecisionpointOrderByRelationAggregateInput
  }

  export type meetinglogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: meetinglogWhereInput | meetinglogWhereInput[]
    OR?: meetinglogWhereInput[]
    NOT?: meetinglogWhereInput | meetinglogWhereInput[]
    meetingDate?: DateTimeFilter<"meetinglog"> | Date | string
    title?: StringFilter<"meetinglog"> | string
    meetingType?: Enummeetinglog_meetingTypeNullableFilter<"meetinglog"> | $Enums.meetinglog_meetingType | null
    attendees?: StringFilter<"meetinglog"> | string
    agenda?: StringFilter<"meetinglog"> | string
    minutes?: StringFilter<"meetinglog"> | string
    actionItems?: StringNullableFilter<"meetinglog"> | string | null
    status?: Enummeetinglog_statusNullableFilter<"meetinglog"> | $Enums.meetinglog_status | null
    imageUrl?: StringNullableFilter<"meetinglog"> | string | null
    postedByOwnerId?: StringNullableFilter<"meetinglog"> | string | null
    postedByOwnerName?: StringNullableFilter<"meetinglog"> | string | null
    createdAt?: DateTimeFilter<"meetinglog"> | Date | string
    updatedAt?: DateTimeFilter<"meetinglog"> | Date | string
    meetingdecisionpoint?: MeetingdecisionpointListRelationFilter
  }, "id">

  export type meetinglogOrderByWithAggregationInput = {
    id?: SortOrder
    meetingDate?: SortOrder
    title?: SortOrder
    meetingType?: SortOrderInput | SortOrder
    attendees?: SortOrder
    agenda?: SortOrder
    minutes?: SortOrder
    actionItems?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: meetinglogCountOrderByAggregateInput
    _max?: meetinglogMaxOrderByAggregateInput
    _min?: meetinglogMinOrderByAggregateInput
  }

  export type meetinglogScalarWhereWithAggregatesInput = {
    AND?: meetinglogScalarWhereWithAggregatesInput | meetinglogScalarWhereWithAggregatesInput[]
    OR?: meetinglogScalarWhereWithAggregatesInput[]
    NOT?: meetinglogScalarWhereWithAggregatesInput | meetinglogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"meetinglog"> | string
    meetingDate?: DateTimeWithAggregatesFilter<"meetinglog"> | Date | string
    title?: StringWithAggregatesFilter<"meetinglog"> | string
    meetingType?: Enummeetinglog_meetingTypeNullableWithAggregatesFilter<"meetinglog"> | $Enums.meetinglog_meetingType | null
    attendees?: StringWithAggregatesFilter<"meetinglog"> | string
    agenda?: StringWithAggregatesFilter<"meetinglog"> | string
    minutes?: StringWithAggregatesFilter<"meetinglog"> | string
    actionItems?: StringNullableWithAggregatesFilter<"meetinglog"> | string | null
    status?: Enummeetinglog_statusNullableWithAggregatesFilter<"meetinglog"> | $Enums.meetinglog_status | null
    imageUrl?: StringNullableWithAggregatesFilter<"meetinglog"> | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"meetinglog"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"meetinglog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"meetinglog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"meetinglog"> | Date | string
  }

  export type ministryWhereInput = {
    AND?: ministryWhereInput | ministryWhereInput[]
    OR?: ministryWhereInput[]
    NOT?: ministryWhereInput | ministryWhereInput[]
    id?: StringFilter<"ministry"> | string
    title?: StringFilter<"ministry"> | string
    description?: StringFilter<"ministry"> | string
    imageUrl?: StringNullableFilter<"ministry"> | string | null
    linkPath?: StringFilter<"ministry"> | string
    category?: Enumministry_categoryNullableFilter<"ministry"> | $Enums.ministry_category | null
    postedByOwnerId?: StringNullableFilter<"ministry"> | string | null
    postedByOwnerName?: StringNullableFilter<"ministry"> | string | null
    createdAt?: DateTimeFilter<"ministry"> | Date | string
    updatedAt?: DateTimeFilter<"ministry"> | Date | string
    leader?: StringNullableFilter<"ministry"> | string | null
    meetingTime?: StringNullableFilter<"ministry"> | string | null
    ministryjoinrequest?: MinistryjoinrequestListRelationFilter
  }

  export type ministryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leader?: SortOrderInput | SortOrder
    meetingTime?: SortOrderInput | SortOrder
    ministryjoinrequest?: ministryjoinrequestOrderByRelationAggregateInput
  }

  export type ministryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ministryWhereInput | ministryWhereInput[]
    OR?: ministryWhereInput[]
    NOT?: ministryWhereInput | ministryWhereInput[]
    title?: StringFilter<"ministry"> | string
    description?: StringFilter<"ministry"> | string
    imageUrl?: StringNullableFilter<"ministry"> | string | null
    linkPath?: StringFilter<"ministry"> | string
    category?: Enumministry_categoryNullableFilter<"ministry"> | $Enums.ministry_category | null
    postedByOwnerId?: StringNullableFilter<"ministry"> | string | null
    postedByOwnerName?: StringNullableFilter<"ministry"> | string | null
    createdAt?: DateTimeFilter<"ministry"> | Date | string
    updatedAt?: DateTimeFilter<"ministry"> | Date | string
    leader?: StringNullableFilter<"ministry"> | string | null
    meetingTime?: StringNullableFilter<"ministry"> | string | null
    ministryjoinrequest?: MinistryjoinrequestListRelationFilter
  }, "id">

  export type ministryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leader?: SortOrderInput | SortOrder
    meetingTime?: SortOrderInput | SortOrder
    _count?: ministryCountOrderByAggregateInput
    _max?: ministryMaxOrderByAggregateInput
    _min?: ministryMinOrderByAggregateInput
  }

  export type ministryScalarWhereWithAggregatesInput = {
    AND?: ministryScalarWhereWithAggregatesInput | ministryScalarWhereWithAggregatesInput[]
    OR?: ministryScalarWhereWithAggregatesInput[]
    NOT?: ministryScalarWhereWithAggregatesInput | ministryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ministry"> | string
    title?: StringWithAggregatesFilter<"ministry"> | string
    description?: StringWithAggregatesFilter<"ministry"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"ministry"> | string | null
    linkPath?: StringWithAggregatesFilter<"ministry"> | string
    category?: Enumministry_categoryNullableWithAggregatesFilter<"ministry"> | $Enums.ministry_category | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"ministry"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"ministry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ministry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ministry"> | Date | string
    leader?: StringNullableWithAggregatesFilter<"ministry"> | string | null
    meetingTime?: StringNullableWithAggregatesFilter<"ministry"> | string | null
  }

  export type ministryjoinrequestWhereInput = {
    AND?: ministryjoinrequestWhereInput | ministryjoinrequestWhereInput[]
    OR?: ministryjoinrequestWhereInput[]
    NOT?: ministryjoinrequestWhereInput | ministryjoinrequestWhereInput[]
    id?: StringFilter<"ministryjoinrequest"> | string
    userId?: StringFilter<"ministryjoinrequest"> | string
    userName?: StringFilter<"ministryjoinrequest"> | string
    userEmail?: StringFilter<"ministryjoinrequest"> | string
    ministryId?: StringFilter<"ministryjoinrequest"> | string
    ministryName?: StringFilter<"ministryjoinrequest"> | string
    ministryGuidelines?: StringFilter<"ministryjoinrequest"> | string
    requestDate?: DateTimeFilter<"ministryjoinrequest"> | Date | string
    message?: StringFilter<"ministryjoinrequest"> | string
    status?: Enumministryjoinrequest_statusFilter<"ministryjoinrequest"> | $Enums.ministryjoinrequest_status
    processedDate?: DateTimeNullableFilter<"ministryjoinrequest"> | Date | string | null
    adminNotes?: StringNullableFilter<"ministryjoinrequest"> | string | null
    ministry?: XOR<MinistryRelationFilter, ministryWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type ministryjoinrequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ministryId?: SortOrder
    ministryName?: SortOrder
    ministryGuidelines?: SortOrder
    requestDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    processedDate?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    ministry?: ministryOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type ministryjoinrequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ministryjoinrequestWhereInput | ministryjoinrequestWhereInput[]
    OR?: ministryjoinrequestWhereInput[]
    NOT?: ministryjoinrequestWhereInput | ministryjoinrequestWhereInput[]
    userId?: StringFilter<"ministryjoinrequest"> | string
    userName?: StringFilter<"ministryjoinrequest"> | string
    userEmail?: StringFilter<"ministryjoinrequest"> | string
    ministryId?: StringFilter<"ministryjoinrequest"> | string
    ministryName?: StringFilter<"ministryjoinrequest"> | string
    ministryGuidelines?: StringFilter<"ministryjoinrequest"> | string
    requestDate?: DateTimeFilter<"ministryjoinrequest"> | Date | string
    message?: StringFilter<"ministryjoinrequest"> | string
    status?: Enumministryjoinrequest_statusFilter<"ministryjoinrequest"> | $Enums.ministryjoinrequest_status
    processedDate?: DateTimeNullableFilter<"ministryjoinrequest"> | Date | string | null
    adminNotes?: StringNullableFilter<"ministryjoinrequest"> | string | null
    ministry?: XOR<MinistryRelationFilter, ministryWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type ministryjoinrequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ministryId?: SortOrder
    ministryName?: SortOrder
    ministryGuidelines?: SortOrder
    requestDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    processedDate?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    _count?: ministryjoinrequestCountOrderByAggregateInput
    _max?: ministryjoinrequestMaxOrderByAggregateInput
    _min?: ministryjoinrequestMinOrderByAggregateInput
  }

  export type ministryjoinrequestScalarWhereWithAggregatesInput = {
    AND?: ministryjoinrequestScalarWhereWithAggregatesInput | ministryjoinrequestScalarWhereWithAggregatesInput[]
    OR?: ministryjoinrequestScalarWhereWithAggregatesInput[]
    NOT?: ministryjoinrequestScalarWhereWithAggregatesInput | ministryjoinrequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    userId?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    userName?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    userEmail?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    ministryId?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    ministryName?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    ministryGuidelines?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    requestDate?: DateTimeWithAggregatesFilter<"ministryjoinrequest"> | Date | string
    message?: StringWithAggregatesFilter<"ministryjoinrequest"> | string
    status?: Enumministryjoinrequest_statusWithAggregatesFilter<"ministryjoinrequest"> | $Enums.ministryjoinrequest_status
    processedDate?: DateTimeNullableWithAggregatesFilter<"ministryjoinrequest"> | Date | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"ministryjoinrequest"> | string | null
  }

  export type monthlythemeimageWhereInput = {
    AND?: monthlythemeimageWhereInput | monthlythemeimageWhereInput[]
    OR?: monthlythemeimageWhereInput[]
    NOT?: monthlythemeimageWhereInput | monthlythemeimageWhereInput[]
    id?: StringFilter<"monthlythemeimage"> | string
    year?: IntFilter<"monthlythemeimage"> | number
    month?: IntFilter<"monthlythemeimage"> | number
    imageUrls?: JsonFilter<"monthlythemeimage">
    quoteOrCaption?: StringNullableFilter<"monthlythemeimage"> | string | null
    createdAt?: DateTimeFilter<"monthlythemeimage"> | Date | string
    updatedAt?: DateTimeFilter<"monthlythemeimage"> | Date | string
    postedByOwnerId?: StringNullableFilter<"monthlythemeimage"> | string | null
    postedByOwnerName?: StringNullableFilter<"monthlythemeimage"> | string | null
  }

  export type monthlythemeimageOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    imageUrls?: SortOrder
    quoteOrCaption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
  }

  export type monthlythemeimageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    year_month?: monthlythemeimageYearMonthCompoundUniqueInput
    AND?: monthlythemeimageWhereInput | monthlythemeimageWhereInput[]
    OR?: monthlythemeimageWhereInput[]
    NOT?: monthlythemeimageWhereInput | monthlythemeimageWhereInput[]
    year?: IntFilter<"monthlythemeimage"> | number
    month?: IntFilter<"monthlythemeimage"> | number
    imageUrls?: JsonFilter<"monthlythemeimage">
    quoteOrCaption?: StringNullableFilter<"monthlythemeimage"> | string | null
    createdAt?: DateTimeFilter<"monthlythemeimage"> | Date | string
    updatedAt?: DateTimeFilter<"monthlythemeimage"> | Date | string
    postedByOwnerId?: StringNullableFilter<"monthlythemeimage"> | string | null
    postedByOwnerName?: StringNullableFilter<"monthlythemeimage"> | string | null
  }, "id" | "year_month">

  export type monthlythemeimageOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    imageUrls?: SortOrder
    quoteOrCaption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    _count?: monthlythemeimageCountOrderByAggregateInput
    _avg?: monthlythemeimageAvgOrderByAggregateInput
    _max?: monthlythemeimageMaxOrderByAggregateInput
    _min?: monthlythemeimageMinOrderByAggregateInput
    _sum?: monthlythemeimageSumOrderByAggregateInput
  }

  export type monthlythemeimageScalarWhereWithAggregatesInput = {
    AND?: monthlythemeimageScalarWhereWithAggregatesInput | monthlythemeimageScalarWhereWithAggregatesInput[]
    OR?: monthlythemeimageScalarWhereWithAggregatesInput[]
    NOT?: monthlythemeimageScalarWhereWithAggregatesInput | monthlythemeimageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"monthlythemeimage"> | string
    year?: IntWithAggregatesFilter<"monthlythemeimage"> | number
    month?: IntWithAggregatesFilter<"monthlythemeimage"> | number
    imageUrls?: JsonWithAggregatesFilter<"monthlythemeimage">
    quoteOrCaption?: StringNullableWithAggregatesFilter<"monthlythemeimage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"monthlythemeimage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"monthlythemeimage"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"monthlythemeimage"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"monthlythemeimage"> | string | null
  }

  export type newsitemWhereInput = {
    AND?: newsitemWhereInput | newsitemWhereInput[]
    OR?: newsitemWhereInput[]
    NOT?: newsitemWhereInput | newsitemWhereInput[]
    id?: StringFilter<"newsitem"> | string
    title?: StringFilter<"newsitem"> | string
    description?: StringFilter<"newsitem"> | string
    imageUrl?: StringNullableFilter<"newsitem"> | string | null
    linkPath?: StringFilter<"newsitem"> | string
    category?: Enumnewsitem_categoryNullableFilter<"newsitem"> | $Enums.newsitem_category | null
    date?: DateTimeNullableFilter<"newsitem"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"newsitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"newsitem"> | string | null
    createdAt?: DateTimeFilter<"newsitem"> | Date | string
    updatedAt?: DateTimeFilter<"newsitem"> | Date | string
    videoUrl?: StringNullableFilter<"newsitem"> | string | null
    audioUrl?: StringNullableFilter<"newsitem"> | string | null
    likes?: IntFilter<"newsitem"> | number
    comment?: CommentListRelationFilter
  }

  export type newsitemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    likes?: SortOrder
    comment?: commentOrderByRelationAggregateInput
  }

  export type newsitemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: newsitemWhereInput | newsitemWhereInput[]
    OR?: newsitemWhereInput[]
    NOT?: newsitemWhereInput | newsitemWhereInput[]
    title?: StringFilter<"newsitem"> | string
    description?: StringFilter<"newsitem"> | string
    imageUrl?: StringNullableFilter<"newsitem"> | string | null
    linkPath?: StringFilter<"newsitem"> | string
    category?: Enumnewsitem_categoryNullableFilter<"newsitem"> | $Enums.newsitem_category | null
    date?: DateTimeNullableFilter<"newsitem"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"newsitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"newsitem"> | string | null
    createdAt?: DateTimeFilter<"newsitem"> | Date | string
    updatedAt?: DateTimeFilter<"newsitem"> | Date | string
    videoUrl?: StringNullableFilter<"newsitem"> | string | null
    audioUrl?: StringNullableFilter<"newsitem"> | string | null
    likes?: IntFilter<"newsitem"> | number
    comment?: CommentListRelationFilter
  }, "id">

  export type newsitemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    likes?: SortOrder
    _count?: newsitemCountOrderByAggregateInput
    _avg?: newsitemAvgOrderByAggregateInput
    _max?: newsitemMaxOrderByAggregateInput
    _min?: newsitemMinOrderByAggregateInput
    _sum?: newsitemSumOrderByAggregateInput
  }

  export type newsitemScalarWhereWithAggregatesInput = {
    AND?: newsitemScalarWhereWithAggregatesInput | newsitemScalarWhereWithAggregatesInput[]
    OR?: newsitemScalarWhereWithAggregatesInput[]
    NOT?: newsitemScalarWhereWithAggregatesInput | newsitemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"newsitem"> | string
    title?: StringWithAggregatesFilter<"newsitem"> | string
    description?: StringWithAggregatesFilter<"newsitem"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"newsitem"> | string | null
    linkPath?: StringWithAggregatesFilter<"newsitem"> | string
    category?: Enumnewsitem_categoryNullableWithAggregatesFilter<"newsitem"> | $Enums.newsitem_category | null
    date?: DateTimeNullableWithAggregatesFilter<"newsitem"> | Date | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"newsitem"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"newsitem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"newsitem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"newsitem"> | Date | string
    videoUrl?: StringNullableWithAggregatesFilter<"newsitem"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"newsitem"> | string | null
    likes?: IntWithAggregatesFilter<"newsitem"> | number
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: StringFilter<"notification"> | string
    targetUserId?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    link?: StringNullableFilter<"notification"> | string | null
    timestamp?: DateTimeFilter<"notification"> | Date | string
    read?: BoolFilter<"notification"> | boolean
    type?: Enumnotification_typeFilter<"notification"> | $Enums.notification_type
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    type?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    targetUserId?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    link?: StringNullableFilter<"notification"> | string | null
    timestamp?: DateTimeFilter<"notification"> | Date | string
    read?: BoolFilter<"notification"> | boolean
    type?: Enumnotification_typeFilter<"notification"> | $Enums.notification_type
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    type?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification"> | string
    targetUserId?: StringWithAggregatesFilter<"notification"> | string
    message?: StringWithAggregatesFilter<"notification"> | string
    link?: StringNullableWithAggregatesFilter<"notification"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"notification"> | Date | string
    read?: BoolWithAggregatesFilter<"notification"> | boolean
    type?: Enumnotification_typeWithAggregatesFilter<"notification"> | $Enums.notification_type
  }

  export type prayerWhereInput = {
    AND?: prayerWhereInput | prayerWhereInput[]
    OR?: prayerWhereInput[]
    NOT?: prayerWhereInput | prayerWhereInput[]
    id?: StringFilter<"prayer"> | string
    userId?: StringFilter<"prayer"> | string
    userName?: StringFilter<"prayer"> | string
    timestamp?: DateTimeFilter<"prayer"> | Date | string
    prayerRequestId?: StringFilter<"prayer"> | string
    prayerrequest?: XOR<PrayerrequestRelationFilter, prayerrequestWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type prayerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    prayerRequestId?: SortOrder
    prayerrequest?: prayerrequestOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type prayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_prayerRequestId?: prayerUserIdPrayerRequestIdCompoundUniqueInput
    AND?: prayerWhereInput | prayerWhereInput[]
    OR?: prayerWhereInput[]
    NOT?: prayerWhereInput | prayerWhereInput[]
    userId?: StringFilter<"prayer"> | string
    userName?: StringFilter<"prayer"> | string
    timestamp?: DateTimeFilter<"prayer"> | Date | string
    prayerRequestId?: StringFilter<"prayer"> | string
    prayerrequest?: XOR<PrayerrequestRelationFilter, prayerrequestWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "userId_prayerRequestId">

  export type prayerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    prayerRequestId?: SortOrder
    _count?: prayerCountOrderByAggregateInput
    _max?: prayerMaxOrderByAggregateInput
    _min?: prayerMinOrderByAggregateInput
  }

  export type prayerScalarWhereWithAggregatesInput = {
    AND?: prayerScalarWhereWithAggregatesInput | prayerScalarWhereWithAggregatesInput[]
    OR?: prayerScalarWhereWithAggregatesInput[]
    NOT?: prayerScalarWhereWithAggregatesInput | prayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"prayer"> | string
    userId?: StringWithAggregatesFilter<"prayer"> | string
    userName?: StringWithAggregatesFilter<"prayer"> | string
    timestamp?: DateTimeWithAggregatesFilter<"prayer"> | Date | string
    prayerRequestId?: StringWithAggregatesFilter<"prayer"> | string
  }

  export type prayerrequestWhereInput = {
    AND?: prayerrequestWhereInput | prayerrequestWhereInput[]
    OR?: prayerrequestWhereInput[]
    NOT?: prayerrequestWhereInput | prayerrequestWhereInput[]
    id?: StringFilter<"prayerrequest"> | string
    userId?: StringNullableFilter<"prayerrequest"> | string | null
    userName?: StringNullableFilter<"prayerrequest"> | string | null
    userProfileImageUrl?: StringNullableFilter<"prayerrequest"> | string | null
    title?: StringFilter<"prayerrequest"> | string
    requestText?: StringFilter<"prayerrequest"> | string
    visibility?: Enumprayerrequest_visibilityFilter<"prayerrequest"> | $Enums.prayerrequest_visibility
    category?: Enumprayerrequest_categoryNullableFilter<"prayerrequest"> | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFilter<"prayerrequest"> | $Enums.prayerrequest_status
    submittedAt?: DateTimeFilter<"prayerrequest"> | Date | string
    lastPrayedAt?: DateTimeNullableFilter<"prayerrequest"> | Date | string | null
    adminNotes?: StringNullableFilter<"prayerrequest"> | string | null
    postedByOwnerId?: StringNullableFilter<"prayerrequest"> | string | null
    postedByOwnerName?: StringNullableFilter<"prayerrequest"> | string | null
    createdAt?: DateTimeFilter<"prayerrequest"> | Date | string
    updatedAt?: DateTimeFilter<"prayerrequest"> | Date | string
    mediaUrls?: JsonNullableFilter<"prayerrequest">
    location?: StringNullableFilter<"prayerrequest"> | string | null
    taggedFriends?: StringNullableFilter<"prayerrequest"> | string | null
    feelingActivity?: StringNullableFilter<"prayerrequest"> | string | null
    backgroundTheme?: StringNullableFilter<"prayerrequest"> | string | null
    comment?: CommentListRelationFilter
    prayer?: PrayerListRelationFilter
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type prayerrequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userProfileImageUrl?: SortOrderInput | SortOrder
    title?: SortOrder
    requestText?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastPrayedAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    taggedFriends?: SortOrderInput | SortOrder
    feelingActivity?: SortOrderInput | SortOrder
    backgroundTheme?: SortOrderInput | SortOrder
    comment?: commentOrderByRelationAggregateInput
    prayer?: prayerOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
  }

  export type prayerrequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: prayerrequestWhereInput | prayerrequestWhereInput[]
    OR?: prayerrequestWhereInput[]
    NOT?: prayerrequestWhereInput | prayerrequestWhereInput[]
    userId?: StringNullableFilter<"prayerrequest"> | string | null
    userName?: StringNullableFilter<"prayerrequest"> | string | null
    userProfileImageUrl?: StringNullableFilter<"prayerrequest"> | string | null
    title?: StringFilter<"prayerrequest"> | string
    requestText?: StringFilter<"prayerrequest"> | string
    visibility?: Enumprayerrequest_visibilityFilter<"prayerrequest"> | $Enums.prayerrequest_visibility
    category?: Enumprayerrequest_categoryNullableFilter<"prayerrequest"> | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFilter<"prayerrequest"> | $Enums.prayerrequest_status
    submittedAt?: DateTimeFilter<"prayerrequest"> | Date | string
    lastPrayedAt?: DateTimeNullableFilter<"prayerrequest"> | Date | string | null
    adminNotes?: StringNullableFilter<"prayerrequest"> | string | null
    postedByOwnerId?: StringNullableFilter<"prayerrequest"> | string | null
    postedByOwnerName?: StringNullableFilter<"prayerrequest"> | string | null
    createdAt?: DateTimeFilter<"prayerrequest"> | Date | string
    updatedAt?: DateTimeFilter<"prayerrequest"> | Date | string
    mediaUrls?: JsonNullableFilter<"prayerrequest">
    location?: StringNullableFilter<"prayerrequest"> | string | null
    taggedFriends?: StringNullableFilter<"prayerrequest"> | string | null
    feelingActivity?: StringNullableFilter<"prayerrequest"> | string | null
    backgroundTheme?: StringNullableFilter<"prayerrequest"> | string | null
    comment?: CommentListRelationFilter
    prayer?: PrayerListRelationFilter
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type prayerrequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    userProfileImageUrl?: SortOrderInput | SortOrder
    title?: SortOrder
    requestText?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastPrayedAt?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    taggedFriends?: SortOrderInput | SortOrder
    feelingActivity?: SortOrderInput | SortOrder
    backgroundTheme?: SortOrderInput | SortOrder
    _count?: prayerrequestCountOrderByAggregateInput
    _max?: prayerrequestMaxOrderByAggregateInput
    _min?: prayerrequestMinOrderByAggregateInput
  }

  export type prayerrequestScalarWhereWithAggregatesInput = {
    AND?: prayerrequestScalarWhereWithAggregatesInput | prayerrequestScalarWhereWithAggregatesInput[]
    OR?: prayerrequestScalarWhereWithAggregatesInput[]
    NOT?: prayerrequestScalarWhereWithAggregatesInput | prayerrequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"prayerrequest"> | string
    userId?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    userName?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    userProfileImageUrl?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    title?: StringWithAggregatesFilter<"prayerrequest"> | string
    requestText?: StringWithAggregatesFilter<"prayerrequest"> | string
    visibility?: Enumprayerrequest_visibilityWithAggregatesFilter<"prayerrequest"> | $Enums.prayerrequest_visibility
    category?: Enumprayerrequest_categoryNullableWithAggregatesFilter<"prayerrequest"> | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusWithAggregatesFilter<"prayerrequest"> | $Enums.prayerrequest_status
    submittedAt?: DateTimeWithAggregatesFilter<"prayerrequest"> | Date | string
    lastPrayedAt?: DateTimeNullableWithAggregatesFilter<"prayerrequest"> | Date | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"prayerrequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"prayerrequest"> | Date | string
    mediaUrls?: JsonNullableWithAggregatesFilter<"prayerrequest">
    location?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    taggedFriends?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    feelingActivity?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
    backgroundTheme?: StringNullableWithAggregatesFilter<"prayerrequest"> | string | null
  }

  export type responsibilityWhereInput = {
    AND?: responsibilityWhereInput | responsibilityWhereInput[]
    OR?: responsibilityWhereInput[]
    NOT?: responsibilityWhereInput | responsibilityWhereInput[]
    id?: StringFilter<"responsibility"> | string
    role?: StringFilter<"responsibility"> | string
    assignedTo?: StringFilter<"responsibility"> | string
    rosterItemId?: StringNullableFilter<"responsibility"> | string | null
    generatedScheduleId?: StringNullableFilter<"responsibility"> | string | null
    generatedscheduleitem?: XOR<GeneratedscheduleitemNullableRelationFilter, generatedscheduleitemWhereInput> | null
    fellowshiprosteritem?: XOR<FellowshiprosteritemNullableRelationFilter, fellowshiprosteritemWhereInput> | null
  }

  export type responsibilityOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    assignedTo?: SortOrder
    rosterItemId?: SortOrderInput | SortOrder
    generatedScheduleId?: SortOrderInput | SortOrder
    generatedscheduleitem?: generatedscheduleitemOrderByWithRelationInput
    fellowshiprosteritem?: fellowshiprosteritemOrderByWithRelationInput
  }

  export type responsibilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: responsibilityWhereInput | responsibilityWhereInput[]
    OR?: responsibilityWhereInput[]
    NOT?: responsibilityWhereInput | responsibilityWhereInput[]
    role?: StringFilter<"responsibility"> | string
    assignedTo?: StringFilter<"responsibility"> | string
    rosterItemId?: StringNullableFilter<"responsibility"> | string | null
    generatedScheduleId?: StringNullableFilter<"responsibility"> | string | null
    generatedscheduleitem?: XOR<GeneratedscheduleitemNullableRelationFilter, generatedscheduleitemWhereInput> | null
    fellowshiprosteritem?: XOR<FellowshiprosteritemNullableRelationFilter, fellowshiprosteritemWhereInput> | null
  }, "id">

  export type responsibilityOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    assignedTo?: SortOrder
    rosterItemId?: SortOrderInput | SortOrder
    generatedScheduleId?: SortOrderInput | SortOrder
    _count?: responsibilityCountOrderByAggregateInput
    _max?: responsibilityMaxOrderByAggregateInput
    _min?: responsibilityMinOrderByAggregateInput
  }

  export type responsibilityScalarWhereWithAggregatesInput = {
    AND?: responsibilityScalarWhereWithAggregatesInput | responsibilityScalarWhereWithAggregatesInput[]
    OR?: responsibilityScalarWhereWithAggregatesInput[]
    NOT?: responsibilityScalarWhereWithAggregatesInput | responsibilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"responsibility"> | string
    role?: StringWithAggregatesFilter<"responsibility"> | string
    assignedTo?: StringWithAggregatesFilter<"responsibility"> | string
    rosterItemId?: StringNullableWithAggregatesFilter<"responsibility"> | string | null
    generatedScheduleId?: StringNullableWithAggregatesFilter<"responsibility"> | string | null
  }

  export type sermonWhereInput = {
    AND?: sermonWhereInput | sermonWhereInput[]
    OR?: sermonWhereInput[]
    NOT?: sermonWhereInput | sermonWhereInput[]
    id?: StringFilter<"sermon"> | string
    title?: StringFilter<"sermon"> | string
    description?: StringFilter<"sermon"> | string
    imageUrl?: StringNullableFilter<"sermon"> | string | null
    linkPath?: StringFilter<"sermon"> | string
    category?: Enumsermon_categoryNullableFilter<"sermon"> | $Enums.sermon_category | null
    date?: DateTimeNullableFilter<"sermon"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"sermon"> | string | null
    postedByOwnerName?: StringNullableFilter<"sermon"> | string | null
    createdAt?: DateTimeFilter<"sermon"> | Date | string
    updatedAt?: DateTimeFilter<"sermon"> | Date | string
    speaker?: StringNullableFilter<"sermon"> | string | null
    scripture?: StringNullableFilter<"sermon"> | string | null
    videoUrl?: StringNullableFilter<"sermon"> | string | null
    audioUrl?: StringNullableFilter<"sermon"> | string | null
    fullContent?: StringNullableFilter<"sermon"> | string | null
    likes?: IntFilter<"sermon"> | number
    comment?: CommentListRelationFilter
  }

  export type sermonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    speaker?: SortOrderInput | SortOrder
    scripture?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fullContent?: SortOrderInput | SortOrder
    likes?: SortOrder
    comment?: commentOrderByRelationAggregateInput
  }

  export type sermonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sermonWhereInput | sermonWhereInput[]
    OR?: sermonWhereInput[]
    NOT?: sermonWhereInput | sermonWhereInput[]
    title?: StringFilter<"sermon"> | string
    description?: StringFilter<"sermon"> | string
    imageUrl?: StringNullableFilter<"sermon"> | string | null
    linkPath?: StringFilter<"sermon"> | string
    category?: Enumsermon_categoryNullableFilter<"sermon"> | $Enums.sermon_category | null
    date?: DateTimeNullableFilter<"sermon"> | Date | string | null
    postedByOwnerId?: StringNullableFilter<"sermon"> | string | null
    postedByOwnerName?: StringNullableFilter<"sermon"> | string | null
    createdAt?: DateTimeFilter<"sermon"> | Date | string
    updatedAt?: DateTimeFilter<"sermon"> | Date | string
    speaker?: StringNullableFilter<"sermon"> | string | null
    scripture?: StringNullableFilter<"sermon"> | string | null
    videoUrl?: StringNullableFilter<"sermon"> | string | null
    audioUrl?: StringNullableFilter<"sermon"> | string | null
    fullContent?: StringNullableFilter<"sermon"> | string | null
    likes?: IntFilter<"sermon"> | number
    comment?: CommentListRelationFilter
  }, "id">

  export type sermonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    linkPath?: SortOrder
    category?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    speaker?: SortOrderInput | SortOrder
    scripture?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    fullContent?: SortOrderInput | SortOrder
    likes?: SortOrder
    _count?: sermonCountOrderByAggregateInput
    _avg?: sermonAvgOrderByAggregateInput
    _max?: sermonMaxOrderByAggregateInput
    _min?: sermonMinOrderByAggregateInput
    _sum?: sermonSumOrderByAggregateInput
  }

  export type sermonScalarWhereWithAggregatesInput = {
    AND?: sermonScalarWhereWithAggregatesInput | sermonScalarWhereWithAggregatesInput[]
    OR?: sermonScalarWhereWithAggregatesInput[]
    NOT?: sermonScalarWhereWithAggregatesInput | sermonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sermon"> | string
    title?: StringWithAggregatesFilter<"sermon"> | string
    description?: StringWithAggregatesFilter<"sermon"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    linkPath?: StringWithAggregatesFilter<"sermon"> | string
    category?: Enumsermon_categoryNullableWithAggregatesFilter<"sermon"> | $Enums.sermon_category | null
    date?: DateTimeNullableWithAggregatesFilter<"sermon"> | Date | string | null
    postedByOwnerId?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"sermon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"sermon"> | Date | string
    speaker?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    scripture?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    fullContent?: StringNullableWithAggregatesFilter<"sermon"> | string | null
    likes?: IntWithAggregatesFilter<"sermon"> | number
  }

  export type testimonialWhereInput = {
    AND?: testimonialWhereInput | testimonialWhereInput[]
    OR?: testimonialWhereInput[]
    NOT?: testimonialWhereInput | testimonialWhereInput[]
    id?: StringFilter<"testimonial"> | string
    userId?: StringFilter<"testimonial"> | string
    userName?: StringFilter<"testimonial"> | string
    userProfileImageUrl?: StringNullableFilter<"testimonial"> | string | null
    title?: StringFilter<"testimonial"> | string
    contentText?: StringFilter<"testimonial"> | string
    visibility?: Enumtestimonial_visibilityFilter<"testimonial"> | $Enums.testimonial_visibility
    submittedAt?: DateTimeFilter<"testimonial"> | Date | string
    postedByOwnerId?: StringNullableFilter<"testimonial"> | string | null
    postedByOwnerName?: StringNullableFilter<"testimonial"> | string | null
    createdAt?: DateTimeFilter<"testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"testimonial"> | Date | string
    mediaUrls?: JsonNullableFilter<"testimonial">
    location?: StringNullableFilter<"testimonial"> | string | null
    taggedFriends?: StringNullableFilter<"testimonial"> | string | null
    feelingActivity?: StringNullableFilter<"testimonial"> | string | null
    backgroundTheme?: StringNullableFilter<"testimonial"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type testimonialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrderInput | SortOrder
    title?: SortOrder
    contentText?: SortOrder
    visibility?: SortOrder
    submittedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    taggedFriends?: SortOrderInput | SortOrder
    feelingActivity?: SortOrderInput | SortOrder
    backgroundTheme?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type testimonialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: testimonialWhereInput | testimonialWhereInput[]
    OR?: testimonialWhereInput[]
    NOT?: testimonialWhereInput | testimonialWhereInput[]
    userId?: StringFilter<"testimonial"> | string
    userName?: StringFilter<"testimonial"> | string
    userProfileImageUrl?: StringNullableFilter<"testimonial"> | string | null
    title?: StringFilter<"testimonial"> | string
    contentText?: StringFilter<"testimonial"> | string
    visibility?: Enumtestimonial_visibilityFilter<"testimonial"> | $Enums.testimonial_visibility
    submittedAt?: DateTimeFilter<"testimonial"> | Date | string
    postedByOwnerId?: StringNullableFilter<"testimonial"> | string | null
    postedByOwnerName?: StringNullableFilter<"testimonial"> | string | null
    createdAt?: DateTimeFilter<"testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"testimonial"> | Date | string
    mediaUrls?: JsonNullableFilter<"testimonial">
    location?: StringNullableFilter<"testimonial"> | string | null
    taggedFriends?: StringNullableFilter<"testimonial"> | string | null
    feelingActivity?: StringNullableFilter<"testimonial"> | string | null
    backgroundTheme?: StringNullableFilter<"testimonial"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type testimonialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrderInput | SortOrder
    title?: SortOrder
    contentText?: SortOrder
    visibility?: SortOrder
    submittedAt?: SortOrder
    postedByOwnerId?: SortOrderInput | SortOrder
    postedByOwnerName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaUrls?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    taggedFriends?: SortOrderInput | SortOrder
    feelingActivity?: SortOrderInput | SortOrder
    backgroundTheme?: SortOrderInput | SortOrder
    _count?: testimonialCountOrderByAggregateInput
    _max?: testimonialMaxOrderByAggregateInput
    _min?: testimonialMinOrderByAggregateInput
  }

  export type testimonialScalarWhereWithAggregatesInput = {
    AND?: testimonialScalarWhereWithAggregatesInput | testimonialScalarWhereWithAggregatesInput[]
    OR?: testimonialScalarWhereWithAggregatesInput[]
    NOT?: testimonialScalarWhereWithAggregatesInput | testimonialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"testimonial"> | string
    userId?: StringWithAggregatesFilter<"testimonial"> | string
    userName?: StringWithAggregatesFilter<"testimonial"> | string
    userProfileImageUrl?: StringNullableWithAggregatesFilter<"testimonial"> | string | null
    title?: StringWithAggregatesFilter<"testimonial"> | string
    contentText?: StringWithAggregatesFilter<"testimonial"> | string
    visibility?: Enumtestimonial_visibilityWithAggregatesFilter<"testimonial"> | $Enums.testimonial_visibility
    submittedAt?: DateTimeWithAggregatesFilter<"testimonial"> | Date | string
    postedByOwnerId?: StringNullableWithAggregatesFilter<"testimonial"> | string | null
    postedByOwnerName?: StringNullableWithAggregatesFilter<"testimonial"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"testimonial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"testimonial"> | Date | string
    mediaUrls?: JsonNullableWithAggregatesFilter<"testimonial">
    location?: StringNullableWithAggregatesFilter<"testimonial"> | string | null
    taggedFriends?: StringNullableWithAggregatesFilter<"testimonial"> | string | null
    feelingActivity?: StringNullableWithAggregatesFilter<"testimonial"> | string | null
    backgroundTheme?: StringNullableWithAggregatesFilter<"testimonial"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    passwordHash?: StringNullableFilter<"user"> | string | null
    id?: StringFilter<"user"> | string
    username?: StringFilter<"user"> | string
    fullName?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    countryCode?: StringNullableFilter<"user"> | string | null
    phone?: StringNullableFilter<"user"> | string | null
    role?: Enumuser_roleFilter<"user"> | $Enums.user_role
    profileImageUrl?: StringNullableFilter<"user"> | string | null
    coverPhotoUrl?: StringNullableFilter<"user"> | string | null
    bio?: StringNullableFilter<"user"> | string | null
    hometown?: StringNullableFilter<"user"> | string | null
    currentCity?: StringNullableFilter<"user"> | string | null
    work?: StringNullableFilter<"user"> | string | null
    education?: StringNullableFilter<"user"> | string | null
    relationshipStatus?: Enumuser_relationshipStatusNullableFilter<"user"> | $Enums.user_relationshipStatus | null
    interests?: StringNullableFilter<"user"> | string | null
    favoriteScripture?: StringNullableFilter<"user"> | string | null
    receiveContentUpdateNotifications?: BoolFilter<"user"> | boolean
    receivePrayerRequestNotifications?: BoolFilter<"user"> | boolean
    receiveTestimonialNotifications?: BoolFilter<"user"> | boolean
    receiveFriendActivityNotifications?: BoolFilter<"user"> | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFilter<"user"> | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFilter<"user"> | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFilter<"user"> | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFilter<"user"> | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    adminactionlog?: AdminactionlogListRelationFilter
    churchmember?: XOR<ChurchmemberNullableRelationFilter, churchmemberWhereInput> | null
    comment?: CommentListRelationFilter
    friendship_friendship_addresseeIdTouser?: FriendshipListRelationFilter
    friendship_friendship_requesterIdTouser?: FriendshipListRelationFilter
    frontendactivitylog?: FrontendactivitylogListRelationFilter
    groupmember?: GroupmemberListRelationFilter
    groupmessage?: GroupmessageListRelationFilter
    ministryjoinrequest?: MinistryjoinrequestListRelationFilter
    notification?: NotificationListRelationFilter
    prayer?: PrayerListRelationFilter
    prayerrequest?: PrayerrequestListRelationFilter
    testimonial?: TestimonialListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    password?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    countryCode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    coverPhotoUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    hometown?: SortOrderInput | SortOrder
    currentCity?: SortOrderInput | SortOrder
    work?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    relationshipStatus?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    favoriteScripture?: SortOrderInput | SortOrder
    receiveContentUpdateNotifications?: SortOrder
    receivePrayerRequestNotifications?: SortOrder
    receiveTestimonialNotifications?: SortOrder
    receiveFriendActivityNotifications?: SortOrder
    friendsListPrivacy?: SortOrder
    profileInSearchPrivacy?: SortOrder
    friendRequestPrivacy?: SortOrder
    groupInvitePrivacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adminactionlog?: adminactionlogOrderByRelationAggregateInput
    churchmember?: churchmemberOrderByWithRelationInput
    comment?: commentOrderByRelationAggregateInput
    friendship_friendship_addresseeIdTouser?: friendshipOrderByRelationAggregateInput
    friendship_friendship_requesterIdTouser?: friendshipOrderByRelationAggregateInput
    frontendactivitylog?: frontendactivitylogOrderByRelationAggregateInput
    groupmember?: groupmemberOrderByRelationAggregateInput
    groupmessage?: groupmessageOrderByRelationAggregateInput
    ministryjoinrequest?: ministryjoinrequestOrderByRelationAggregateInput
    notification?: notificationOrderByRelationAggregateInput
    prayer?: prayerOrderByRelationAggregateInput
    prayerrequest?: prayerrequestOrderByRelationAggregateInput
    testimonial?: testimonialOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    passwordHash?: StringNullableFilter<"user"> | string | null
    fullName?: StringFilter<"user"> | string
    countryCode?: StringNullableFilter<"user"> | string | null
    phone?: StringNullableFilter<"user"> | string | null
    role?: Enumuser_roleFilter<"user"> | $Enums.user_role
    profileImageUrl?: StringNullableFilter<"user"> | string | null
    coverPhotoUrl?: StringNullableFilter<"user"> | string | null
    bio?: StringNullableFilter<"user"> | string | null
    hometown?: StringNullableFilter<"user"> | string | null
    currentCity?: StringNullableFilter<"user"> | string | null
    work?: StringNullableFilter<"user"> | string | null
    education?: StringNullableFilter<"user"> | string | null
    relationshipStatus?: Enumuser_relationshipStatusNullableFilter<"user"> | $Enums.user_relationshipStatus | null
    interests?: StringNullableFilter<"user"> | string | null
    favoriteScripture?: StringNullableFilter<"user"> | string | null
    receiveContentUpdateNotifications?: BoolFilter<"user"> | boolean
    receivePrayerRequestNotifications?: BoolFilter<"user"> | boolean
    receiveTestimonialNotifications?: BoolFilter<"user"> | boolean
    receiveFriendActivityNotifications?: BoolFilter<"user"> | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFilter<"user"> | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFilter<"user"> | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFilter<"user"> | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFilter<"user"> | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    adminactionlog?: AdminactionlogListRelationFilter
    churchmember?: XOR<ChurchmemberNullableRelationFilter, churchmemberWhereInput> | null
    comment?: CommentListRelationFilter
    friendship_friendship_addresseeIdTouser?: FriendshipListRelationFilter
    friendship_friendship_requesterIdTouser?: FriendshipListRelationFilter
    frontendactivitylog?: FrontendactivitylogListRelationFilter
    groupmember?: GroupmemberListRelationFilter
    groupmessage?: GroupmessageListRelationFilter
    ministryjoinrequest?: MinistryjoinrequestListRelationFilter
    notification?: NotificationListRelationFilter
    prayer?: PrayerListRelationFilter
    prayerrequest?: PrayerrequestListRelationFilter
    testimonial?: TestimonialListRelationFilter
  }, "id" | "username" | "email">

  export type userOrderByWithAggregationInput = {
    password?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    countryCode?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    coverPhotoUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    hometown?: SortOrderInput | SortOrder
    currentCity?: SortOrderInput | SortOrder
    work?: SortOrderInput | SortOrder
    education?: SortOrderInput | SortOrder
    relationshipStatus?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    favoriteScripture?: SortOrderInput | SortOrder
    receiveContentUpdateNotifications?: SortOrder
    receivePrayerRequestNotifications?: SortOrder
    receiveTestimonialNotifications?: SortOrder
    receiveFriendActivityNotifications?: SortOrder
    friendsListPrivacy?: SortOrder
    profileInSearchPrivacy?: SortOrder
    friendRequestPrivacy?: SortOrder
    groupInvitePrivacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    password?: StringWithAggregatesFilter<"user"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"user"> | string | null
    id?: StringWithAggregatesFilter<"user"> | string
    username?: StringWithAggregatesFilter<"user"> | string
    fullName?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    countryCode?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone?: StringNullableWithAggregatesFilter<"user"> | string | null
    role?: Enumuser_roleWithAggregatesFilter<"user"> | $Enums.user_role
    profileImageUrl?: StringNullableWithAggregatesFilter<"user"> | string | null
    coverPhotoUrl?: StringNullableWithAggregatesFilter<"user"> | string | null
    bio?: StringNullableWithAggregatesFilter<"user"> | string | null
    hometown?: StringNullableWithAggregatesFilter<"user"> | string | null
    currentCity?: StringNullableWithAggregatesFilter<"user"> | string | null
    work?: StringNullableWithAggregatesFilter<"user"> | string | null
    education?: StringNullableWithAggregatesFilter<"user"> | string | null
    relationshipStatus?: Enumuser_relationshipStatusNullableWithAggregatesFilter<"user"> | $Enums.user_relationshipStatus | null
    interests?: StringNullableWithAggregatesFilter<"user"> | string | null
    favoriteScripture?: StringNullableWithAggregatesFilter<"user"> | string | null
    receiveContentUpdateNotifications?: BoolWithAggregatesFilter<"user"> | boolean
    receivePrayerRequestNotifications?: BoolWithAggregatesFilter<"user"> | boolean
    receiveTestimonialNotifications?: BoolWithAggregatesFilter<"user"> | boolean
    receiveFriendActivityNotifications?: BoolWithAggregatesFilter<"user"> | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyWithAggregatesFilter<"user"> | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolWithAggregatesFilter<"user"> | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyWithAggregatesFilter<"user"> | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyWithAggregatesFilter<"user"> | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type aboutsectionCreateInput = {
    id: string
    title: string
    content: string
    imageUrl?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    isCoreSection: boolean
    displayOrder: number
    createdAt?: Date | string
  }

  export type aboutsectionUncheckedCreateInput = {
    id: string
    title: string
    content: string
    imageUrl?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    isCoreSection: boolean
    displayOrder: number
    createdAt?: Date | string
  }

  export type aboutsectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    isCoreSection?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aboutsectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    isCoreSection?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aboutsectionCreateManyInput = {
    id: string
    title: string
    content: string
    imageUrl?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    isCoreSection: boolean
    displayOrder: number
    createdAt?: Date | string
  }

  export type aboutsectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    isCoreSection?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aboutsectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    isCoreSection?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type adminactionlogCreateInput = {
    id: string
    timestamp?: Date | string
    adminName: string
    action: string
    targetId?: string | null
    details?: string | null
    user: userCreateNestedOneWithoutAdminactionlogInput
  }

  export type adminactionlogUncheckedCreateInput = {
    id: string
    timestamp?: Date | string
    adminId: string
    adminName: string
    action: string
    targetId?: string | null
    details?: string | null
  }

  export type adminactionlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutAdminactionlogNestedInput
  }

  export type adminactionlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    adminName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adminactionlogCreateManyInput = {
    id: string
    timestamp?: Date | string
    adminId: string
    adminName: string
    action: string
    targetId?: string | null
    details?: string | null
  }

  export type adminactionlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adminactionlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminId?: StringFieldUpdateOperationsInput | string
    adminName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type advertisementCreateInput = {
    id: string
    name: string
    adType: $Enums.advertisement_adType
    imageUrl?: string | null
    videoUrl?: string | null
    linkUrl?: string | null
    altText?: string | null
    placements: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive: boolean
    displayOrder?: number | null
    adSizeKey?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type advertisementUncheckedCreateInput = {
    id: string
    name: string
    adType: $Enums.advertisement_adType
    imageUrl?: string | null
    videoUrl?: string | null
    linkUrl?: string | null
    altText?: string | null
    placements: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive: boolean
    displayOrder?: number | null
    adSizeKey?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type advertisementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adType?: Enumadvertisement_adTypeFieldUpdateOperationsInput | $Enums.advertisement_adType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    placements?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    adSizeKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type advertisementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adType?: Enumadvertisement_adTypeFieldUpdateOperationsInput | $Enums.advertisement_adType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    placements?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    adSizeKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type advertisementCreateManyInput = {
    id: string
    name: string
    adType: $Enums.advertisement_adType
    imageUrl?: string | null
    videoUrl?: string | null
    linkUrl?: string | null
    altText?: string | null
    placements: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive: boolean
    displayOrder?: number | null
    adSizeKey?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type advertisementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adType?: Enumadvertisement_adTypeFieldUpdateOperationsInput | $Enums.advertisement_adType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    placements?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    adSizeKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type advertisementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adType?: Enumadvertisement_adTypeFieldUpdateOperationsInput | $Enums.advertisement_adType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    placements?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    adSizeKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blogpostCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.blogpost_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    likes?: number
    audioUrl?: string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    videoUrl?: string | null
    comment?: commentCreateNestedManyWithoutBlogpostInput
  }

  export type blogpostUncheckedCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.blogpost_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    likes?: number
    audioUrl?: string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    videoUrl?: string | null
    comment?: commentUncheckedCreateNestedManyWithoutBlogpostInput
  }

  export type blogpostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumblogpost_categoryFieldUpdateOperationsInput | $Enums.blogpost_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUpdateManyWithoutBlogpostNestedInput
  }

  export type blogpostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumblogpost_categoryFieldUpdateOperationsInput | $Enums.blogpost_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUncheckedUpdateManyWithoutBlogpostNestedInput
  }

  export type blogpostCreateManyInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.blogpost_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    likes?: number
    audioUrl?: string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    videoUrl?: string | null
  }

  export type blogpostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumblogpost_categoryFieldUpdateOperationsInput | $Enums.blogpost_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blogpostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumblogpost_categoryFieldUpdateOperationsInput | $Enums.blogpost_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type branchchurchCreateInput = {
    id: string
    name: string
    address: string
    pastorName?: string | null
    phone?: string | null
    email?: string | null
    serviceTimes: string
    mapEmbedUrl?: string | null
    imageUrl?: string | null
    description?: string | null
    establishedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type branchchurchUncheckedCreateInput = {
    id: string
    name: string
    address: string
    pastorName?: string | null
    phone?: string | null
    email?: string | null
    serviceTimes: string
    mapEmbedUrl?: string | null
    imageUrl?: string | null
    description?: string | null
    establishedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type branchchurchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pastorName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTimes?: StringFieldUpdateOperationsInput | string
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type branchchurchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pastorName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTimes?: StringFieldUpdateOperationsInput | string
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type branchchurchCreateManyInput = {
    id: string
    name: string
    address: string
    pastorName?: string | null
    phone?: string | null
    email?: string | null
    serviceTimes: string
    mapEmbedUrl?: string | null
    imageUrl?: string | null
    description?: string | null
    establishedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type branchchurchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pastorName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTimes?: StringFieldUpdateOperationsInput | string
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type branchchurchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    pastorName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    serviceTimes?: StringFieldUpdateOperationsInput | string
    mapEmbedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    establishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type churchmemberCreateInput = {
    id: string
    fullName: string
    username?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    address?: string | null
    memberSince: Date | string
    dateOfBirth?: Date | string | null
    baptismDate?: Date | string | null
    familyMembers?: string | null
    notes?: string | null
    isActiveMember: boolean
    profileImageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    user?: userCreateNestedOneWithoutChurchmemberInput
  }

  export type churchmemberUncheckedCreateInput = {
    id: string
    userId?: string | null
    fullName: string
    username?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    address?: string | null
    memberSince: Date | string
    dateOfBirth?: Date | string | null
    baptismDate?: Date | string | null
    familyMembers?: string | null
    notes?: string | null
    isActiveMember: boolean
    profileImageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type churchmemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baptismDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMembers?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActiveMember?: BoolFieldUpdateOperationsInput | boolean
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutChurchmemberNestedInput
  }

  export type churchmemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baptismDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMembers?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActiveMember?: BoolFieldUpdateOperationsInput | boolean
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type churchmemberCreateManyInput = {
    id: string
    userId?: string | null
    fullName: string
    username?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    address?: string | null
    memberSince: Date | string
    dateOfBirth?: Date | string | null
    baptismDate?: Date | string | null
    familyMembers?: string | null
    notes?: string | null
    isActiveMember: boolean
    profileImageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type churchmemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baptismDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMembers?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActiveMember?: BoolFieldUpdateOperationsInput | boolean
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type churchmemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baptismDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMembers?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActiveMember?: BoolFieldUpdateOperationsInput | boolean
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type collectionrecordCreateInput = {
    id: string
    collectorName: string
    collectionDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.collectionrecord_purpose
    source?: string | null
    notes?: string | null
    recordedAt?: Date | string
    recordedByOwnerId?: string | null
    recordedByOwnerName?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    countedBy?: string | null
    isDeposited?: boolean
    depositDate?: Date | string | null
    bankDepositReference?: string | null
    donordetail?: donordetailCreateNestedManyWithoutCollectionrecordInput
  }

  export type collectionrecordUncheckedCreateInput = {
    id: string
    collectorName: string
    collectionDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.collectionrecord_purpose
    source?: string | null
    notes?: string | null
    recordedAt?: Date | string
    recordedByOwnerId?: string | null
    recordedByOwnerName?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    countedBy?: string | null
    isDeposited?: boolean
    depositDate?: Date | string | null
    bankDepositReference?: string | null
    donordetail?: donordetailUncheckedCreateNestedManyWithoutCollectionrecordInput
  }

  export type collectionrecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectorName?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFieldUpdateOperationsInput | $Enums.collectionrecord_purpose
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeposited?: BoolFieldUpdateOperationsInput | boolean
    depositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankDepositReference?: NullableStringFieldUpdateOperationsInput | string | null
    donordetail?: donordetailUpdateManyWithoutCollectionrecordNestedInput
  }

  export type collectionrecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectorName?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFieldUpdateOperationsInput | $Enums.collectionrecord_purpose
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeposited?: BoolFieldUpdateOperationsInput | boolean
    depositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankDepositReference?: NullableStringFieldUpdateOperationsInput | string | null
    donordetail?: donordetailUncheckedUpdateManyWithoutCollectionrecordNestedInput
  }

  export type collectionrecordCreateManyInput = {
    id: string
    collectorName: string
    collectionDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.collectionrecord_purpose
    source?: string | null
    notes?: string | null
    recordedAt?: Date | string
    recordedByOwnerId?: string | null
    recordedByOwnerName?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    countedBy?: string | null
    isDeposited?: boolean
    depositDate?: Date | string | null
    bankDepositReference?: string | null
  }

  export type collectionrecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectorName?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFieldUpdateOperationsInput | $Enums.collectionrecord_purpose
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeposited?: BoolFieldUpdateOperationsInput | boolean
    depositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankDepositReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectionrecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectorName?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFieldUpdateOperationsInput | $Enums.collectionrecord_purpose
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeposited?: BoolFieldUpdateOperationsInput | boolean
    depositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankDepositReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentCreateInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    blogpost?: blogpostCreateNestedOneWithoutCommentInput
    eventitem?: eventitemCreateNestedOneWithoutCommentInput
    historychapter?: historychapterCreateNestedOneWithoutCommentInput
    newsitem?: newsitemCreateNestedOneWithoutCommentInput
    prayerrequest?: prayerrequestCreateNestedOneWithoutCommentInput
    sermon?: sermonCreateNestedOneWithoutCommentInput
    user: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogpost?: blogpostUpdateOneWithoutCommentNestedInput
    eventitem?: eventitemUpdateOneWithoutCommentNestedInput
    historychapter?: historychapterUpdateOneWithoutCommentNestedInput
    newsitem?: newsitemUpdateOneWithoutCommentNestedInput
    prayerrequest?: prayerrequestUpdateOneWithoutCommentNestedInput
    sermon?: sermonUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneRequiredWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentCreateManyInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactmessageCreateInput = {
    id: string
    name: string
    email: string
    subject: string
    message: string
    submittedAt?: Date | string
    status?: $Enums.contactmessage_status
    repliedAt?: Date | string | null
    replyNote?: string | null
  }

  export type contactmessageUncheckedCreateInput = {
    id: string
    name: string
    email: string
    subject: string
    message: string
    submittedAt?: Date | string
    status?: $Enums.contactmessage_status
    repliedAt?: Date | string | null
    replyNote?: string | null
  }

  export type contactmessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumcontactmessage_statusFieldUpdateOperationsInput | $Enums.contactmessage_status
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactmessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumcontactmessage_statusFieldUpdateOperationsInput | $Enums.contactmessage_status
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactmessageCreateManyInput = {
    id: string
    name: string
    email: string
    subject: string
    message: string
    submittedAt?: Date | string
    status?: $Enums.contactmessage_status
    repliedAt?: Date | string | null
    replyNote?: string | null
  }

  export type contactmessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumcontactmessage_statusFieldUpdateOperationsInput | $Enums.contactmessage_status
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactmessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumcontactmessage_statusFieldUpdateOperationsInput | $Enums.contactmessage_status
    repliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replyNote?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type decisionlogCreateInput = {
    id: string
    decisionDate: Date | string
    title: string
    description: string
    madeBy: string
    status?: $Enums.decisionlog_status | null
    followUpActions?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type decisionlogUncheckedCreateInput = {
    id: string
    decisionDate: Date | string
    title: string
    description: string
    madeBy: string
    status?: $Enums.decisionlog_status | null
    followUpActions?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type decisionlogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    madeBy?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumdecisionlog_statusFieldUpdateOperationsInput | $Enums.decisionlog_status | null
    followUpActions?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type decisionlogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    madeBy?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumdecisionlog_statusFieldUpdateOperationsInput | $Enums.decisionlog_status | null
    followUpActions?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type decisionlogCreateManyInput = {
    id: string
    decisionDate: Date | string
    title: string
    description: string
    madeBy: string
    status?: $Enums.decisionlog_status | null
    followUpActions?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type decisionlogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    madeBy?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumdecisionlog_statusFieldUpdateOperationsInput | $Enums.decisionlog_status | null
    followUpActions?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type decisionlogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    decisionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    madeBy?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumdecisionlog_statusFieldUpdateOperationsInput | $Enums.decisionlog_status | null
    followUpActions?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type directmediaitemCreateInput = {
    id: string
    title: string
    description?: string | null
    url: string
    mediaType: $Enums.directmediaitem_mediaType
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    uploadDate?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    updatedAt: Date | string
  }

  export type directmediaitemUncheckedCreateInput = {
    id: string
    title: string
    description?: string | null
    url: string
    mediaType: $Enums.directmediaitem_mediaType
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    uploadDate?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    updatedAt: Date | string
  }

  export type directmediaitemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: Enumdirectmediaitem_mediaTypeFieldUpdateOperationsInput | $Enums.directmediaitem_mediaType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type directmediaitemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: Enumdirectmediaitem_mediaTypeFieldUpdateOperationsInput | $Enums.directmediaitem_mediaType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type directmediaitemCreateManyInput = {
    id: string
    title: string
    description?: string | null
    url: string
    mediaType: $Enums.directmediaitem_mediaType
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    uploadDate?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    updatedAt: Date | string
  }

  export type directmediaitemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: Enumdirectmediaitem_mediaTypeFieldUpdateOperationsInput | $Enums.directmediaitem_mediaType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type directmediaitemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    mediaType?: Enumdirectmediaitem_mediaTypeFieldUpdateOperationsInput | $Enums.directmediaitem_mediaType
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type donatepagecontentCreateInput = {
    id?: string
    headerTitle: string
    headerSubtitle: string
    headerImageUrl: string
    localDonationsTitle: string
    bankName: string
    accountName: string
    accountNumber: string
    branch: string
    bankQrImageUrl?: string | null
    eSewaId: string
    eSewaQrImageUrl?: string | null
    localDonationsNote: string
    internationalDonationsTitle: string
    internationalDonationsContent: string
    internationalDonationsContactEmail: string
    internationalQrImageUrl?: string | null
    receiptVerses?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type donatepagecontentUncheckedCreateInput = {
    id?: string
    headerTitle: string
    headerSubtitle: string
    headerImageUrl: string
    localDonationsTitle: string
    bankName: string
    accountName: string
    accountNumber: string
    branch: string
    bankQrImageUrl?: string | null
    eSewaId: string
    eSewaQrImageUrl?: string | null
    localDonationsNote: string
    internationalDonationsTitle: string
    internationalDonationsContent: string
    internationalDonationsContactEmail: string
    internationalQrImageUrl?: string | null
    receiptVerses?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type donatepagecontentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerTitle?: StringFieldUpdateOperationsInput | string
    headerSubtitle?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: StringFieldUpdateOperationsInput | string
    localDonationsTitle?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bankQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eSewaId?: StringFieldUpdateOperationsInput | string
    eSewaQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localDonationsNote?: StringFieldUpdateOperationsInput | string
    internationalDonationsTitle?: StringFieldUpdateOperationsInput | string
    internationalDonationsContent?: StringFieldUpdateOperationsInput | string
    internationalDonationsContactEmail?: StringFieldUpdateOperationsInput | string
    internationalQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptVerses?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donatepagecontentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerTitle?: StringFieldUpdateOperationsInput | string
    headerSubtitle?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: StringFieldUpdateOperationsInput | string
    localDonationsTitle?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bankQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eSewaId?: StringFieldUpdateOperationsInput | string
    eSewaQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localDonationsNote?: StringFieldUpdateOperationsInput | string
    internationalDonationsTitle?: StringFieldUpdateOperationsInput | string
    internationalDonationsContent?: StringFieldUpdateOperationsInput | string
    internationalDonationsContactEmail?: StringFieldUpdateOperationsInput | string
    internationalQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptVerses?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donatepagecontentCreateManyInput = {
    id?: string
    headerTitle: string
    headerSubtitle: string
    headerImageUrl: string
    localDonationsTitle: string
    bankName: string
    accountName: string
    accountNumber: string
    branch: string
    bankQrImageUrl?: string | null
    eSewaId: string
    eSewaQrImageUrl?: string | null
    localDonationsNote: string
    internationalDonationsTitle: string
    internationalDonationsContent: string
    internationalDonationsContactEmail: string
    internationalQrImageUrl?: string | null
    receiptVerses?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type donatepagecontentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerTitle?: StringFieldUpdateOperationsInput | string
    headerSubtitle?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: StringFieldUpdateOperationsInput | string
    localDonationsTitle?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bankQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eSewaId?: StringFieldUpdateOperationsInput | string
    eSewaQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localDonationsNote?: StringFieldUpdateOperationsInput | string
    internationalDonationsTitle?: StringFieldUpdateOperationsInput | string
    internationalDonationsContent?: StringFieldUpdateOperationsInput | string
    internationalDonationsContactEmail?: StringFieldUpdateOperationsInput | string
    internationalQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptVerses?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donatepagecontentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    headerTitle?: StringFieldUpdateOperationsInput | string
    headerSubtitle?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: StringFieldUpdateOperationsInput | string
    localDonationsTitle?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bankQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    eSewaId?: StringFieldUpdateOperationsInput | string
    eSewaQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localDonationsNote?: StringFieldUpdateOperationsInput | string
    internationalDonationsTitle?: StringFieldUpdateOperationsInput | string
    internationalDonationsContent?: StringFieldUpdateOperationsInput | string
    internationalDonationsContactEmail?: StringFieldUpdateOperationsInput | string
    internationalQrImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    receiptVerses?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donationrecordCreateInput = {
    id: string
    donorName: string
    donorEmail: string
    donorPhone?: string | null
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.donationrecord_purpose
    donationDate: Date | string
    transactionTimestamp?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    paymentMethod?: $Enums.donationrecord_paymentMethod | null
    transactionReference?: string | null
    notes?: string | null
    isReceiptSent: boolean
  }

  export type donationrecordUncheckedCreateInput = {
    id: string
    donorName: string
    donorEmail: string
    donorPhone?: string | null
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.donationrecord_purpose
    donationDate: Date | string
    transactionTimestamp?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    paymentMethod?: $Enums.donationrecord_paymentMethod | null
    transactionReference?: string | null
    notes?: string | null
    isReceiptSent: boolean
  }

  export type donationrecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    donorEmail?: StringFieldUpdateOperationsInput | string
    donorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumdonationrecord_purposeFieldUpdateOperationsInput | $Enums.donationrecord_purpose
    donationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumdonationrecord_paymentMethodFieldUpdateOperationsInput | $Enums.donationrecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isReceiptSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type donationrecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    donorEmail?: StringFieldUpdateOperationsInput | string
    donorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumdonationrecord_purposeFieldUpdateOperationsInput | $Enums.donationrecord_purpose
    donationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumdonationrecord_paymentMethodFieldUpdateOperationsInput | $Enums.donationrecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isReceiptSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type donationrecordCreateManyInput = {
    id: string
    donorName: string
    donorEmail: string
    donorPhone?: string | null
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.donationrecord_purpose
    donationDate: Date | string
    transactionTimestamp?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    paymentMethod?: $Enums.donationrecord_paymentMethod | null
    transactionReference?: string | null
    notes?: string | null
    isReceiptSent: boolean
  }

  export type donationrecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    donorEmail?: StringFieldUpdateOperationsInput | string
    donorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumdonationrecord_purposeFieldUpdateOperationsInput | $Enums.donationrecord_purpose
    donationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumdonationrecord_paymentMethodFieldUpdateOperationsInput | $Enums.donationrecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isReceiptSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type donationrecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    donorEmail?: StringFieldUpdateOperationsInput | string
    donorPhone?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumdonationrecord_purposeFieldUpdateOperationsInput | $Enums.donationrecord_purpose
    donationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableEnumdonationrecord_paymentMethodFieldUpdateOperationsInput | $Enums.donationrecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isReceiptSent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type donordetailCreateInput = {
    id: string
    donorName: string
    amount: Decimal | DecimalJsLike | number | string
    address?: string | null
    contact?: string | null
    collectionrecord: collectionrecordCreateNestedOneWithoutDonordetailInput
  }

  export type donordetailUncheckedCreateInput = {
    id: string
    donorName: string
    amount: Decimal | DecimalJsLike | number | string
    address?: string | null
    contact?: string | null
    collectionRecordId: string
  }

  export type donordetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    collectionrecord?: collectionrecordUpdateOneRequiredWithoutDonordetailNestedInput
  }

  export type donordetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    collectionRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type donordetailCreateManyInput = {
    id: string
    donorName: string
    amount: Decimal | DecimalJsLike | number | string
    address?: string | null
    contact?: string | null
    collectionRecordId: string
  }

  export type donordetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donordetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    collectionRecordId?: StringFieldUpdateOperationsInput | string
  }

  export type eventitemCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.eventitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    location?: string | null
    time?: string | null
    expectations?: string | null
    guests?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    registrationLink?: string | null
    capacity?: number | null
    isFeeRequired?: boolean
    feeAmount?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
    comment?: commentCreateNestedManyWithoutEventitemInput
  }

  export type eventitemUncheckedCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.eventitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    location?: string | null
    time?: string | null
    expectations?: string | null
    guests?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    registrationLink?: string | null
    capacity?: number | null
    isFeeRequired?: boolean
    feeAmount?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
    comment?: commentUncheckedCreateNestedManyWithoutEventitemInput
  }

  export type eventitemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumeventitem_categoryFieldUpdateOperationsInput | $Enums.eventitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    guests?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isFeeRequired?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUpdateManyWithoutEventitemNestedInput
  }

  export type eventitemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumeventitem_categoryFieldUpdateOperationsInput | $Enums.eventitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    guests?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isFeeRequired?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUncheckedUpdateManyWithoutEventitemNestedInput
  }

  export type eventitemCreateManyInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.eventitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    location?: string | null
    time?: string | null
    expectations?: string | null
    guests?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    registrationLink?: string | null
    capacity?: number | null
    isFeeRequired?: boolean
    feeAmount?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
  }

  export type eventitemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumeventitem_categoryFieldUpdateOperationsInput | $Enums.eventitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    guests?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isFeeRequired?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type eventitemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumeventitem_categoryFieldUpdateOperationsInput | $Enums.eventitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    guests?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isFeeRequired?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type expenserecordCreateInput = {
    id: string
    expenseDate: Date | string
    category: $Enums.expenserecord_category
    description: string
    amount: Decimal | DecimalJsLike | number | string
    payee?: string | null
    paymentMethod?: $Enums.expenserecord_paymentMethod | null
    transactionReference?: string | null
    receiptUrl?: string | null
    approvedBy?: string | null
    notes?: string | null
    source?: string | null
    location?: string | null
    status?: $Enums.expenserecord_status | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type expenserecordUncheckedCreateInput = {
    id: string
    expenseDate: Date | string
    category: $Enums.expenserecord_category
    description: string
    amount: Decimal | DecimalJsLike | number | string
    payee?: string | null
    paymentMethod?: $Enums.expenserecord_paymentMethod | null
    transactionReference?: string | null
    receiptUrl?: string | null
    approvedBy?: string | null
    notes?: string | null
    source?: string | null
    location?: string | null
    status?: $Enums.expenserecord_status | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type expenserecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: Enumexpenserecord_categoryFieldUpdateOperationsInput | $Enums.expenserecord_category
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payee?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumexpenserecord_paymentMethodFieldUpdateOperationsInput | $Enums.expenserecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumexpenserecord_statusFieldUpdateOperationsInput | $Enums.expenserecord_status | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type expenserecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: Enumexpenserecord_categoryFieldUpdateOperationsInput | $Enums.expenserecord_category
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payee?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumexpenserecord_paymentMethodFieldUpdateOperationsInput | $Enums.expenserecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumexpenserecord_statusFieldUpdateOperationsInput | $Enums.expenserecord_status | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type expenserecordCreateManyInput = {
    id: string
    expenseDate: Date | string
    category: $Enums.expenserecord_category
    description: string
    amount: Decimal | DecimalJsLike | number | string
    payee?: string | null
    paymentMethod?: $Enums.expenserecord_paymentMethod | null
    transactionReference?: string | null
    receiptUrl?: string | null
    approvedBy?: string | null
    notes?: string | null
    source?: string | null
    location?: string | null
    status?: $Enums.expenserecord_status | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type expenserecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: Enumexpenserecord_categoryFieldUpdateOperationsInput | $Enums.expenserecord_category
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payee?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumexpenserecord_paymentMethodFieldUpdateOperationsInput | $Enums.expenserecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumexpenserecord_statusFieldUpdateOperationsInput | $Enums.expenserecord_status | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type expenserecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: Enumexpenserecord_categoryFieldUpdateOperationsInput | $Enums.expenserecord_category
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payee?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableEnumexpenserecord_paymentMethodFieldUpdateOperationsInput | $Enums.expenserecord_paymentMethod | null
    transactionReference?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumexpenserecord_statusFieldUpdateOperationsInput | $Enums.expenserecord_status | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fellowshiprosteritemCreateInput = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    isTemplate?: boolean
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    generatedscheduleitem?: generatedscheduleitemCreateNestedManyWithoutFellowshiprosteritemInput
    responsibility?: responsibilityCreateNestedManyWithoutFellowshiprosteritemInput
  }

  export type fellowshiprosteritemUncheckedCreateInput = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    isTemplate?: boolean
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    generatedscheduleitem?: generatedscheduleitemUncheckedCreateNestedManyWithoutFellowshiprosteritemInput
    responsibility?: responsibilityUncheckedCreateNestedManyWithoutFellowshiprosteritemInput
  }

  export type fellowshiprosteritemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedscheduleitem?: generatedscheduleitemUpdateManyWithoutFellowshiprosteritemNestedInput
    responsibility?: responsibilityUpdateManyWithoutFellowshiprosteritemNestedInput
  }

  export type fellowshiprosteritemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedscheduleitem?: generatedscheduleitemUncheckedUpdateManyWithoutFellowshiprosteritemNestedInput
    responsibility?: responsibilityUncheckedUpdateManyWithoutFellowshiprosteritemNestedInput
  }

  export type fellowshiprosteritemCreateManyInput = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    isTemplate?: boolean
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type fellowshiprosteritemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fellowshiprosteritemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type friendshipCreateInput = {
    id: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
    user_friendship_addresseeIdTouser: userCreateNestedOneWithoutFriendship_friendship_addresseeIdTouserInput
    user_friendship_requesterIdTouser: userCreateNestedOneWithoutFriendship_friendship_requesterIdTouserInput
  }

  export type friendshipUncheckedCreateInput = {
    id: string
    requesterId: string
    addresseeId: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type friendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_friendship_addresseeIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_addresseeIdTouserNestedInput
    user_friendship_requesterIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_requesterIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type friendshipCreateManyInput = {
    id: string
    requesterId: string
    addresseeId: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type friendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type friendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frontendactivitylogCreateInput = {
    id: string
    timestamp?: Date | string
    description: string
    type: string
    itemId?: string | null
    itemType?: string | null
    user?: userCreateNestedOneWithoutFrontendactivitylogInput
  }

  export type frontendactivitylogUncheckedCreateInput = {
    id: string
    timestamp?: Date | string
    userId?: string | null
    description: string
    type: string
    itemId?: string | null
    itemType?: string | null
  }

  export type frontendactivitylogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutFrontendactivitylogNestedInput
  }

  export type frontendactivitylogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type frontendactivitylogCreateManyInput = {
    id: string
    timestamp?: Date | string
    userId?: string | null
    description: string
    type: string
    itemId?: string | null
    itemType?: string | null
  }

  export type frontendactivitylogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type frontendactivitylogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type generatedscheduleitemCreateInput = {
    id: string
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    fellowshiprosteritem?: fellowshiprosteritemCreateNestedOneWithoutGeneratedscheduleitemInput
    responsibility?: responsibilityCreateNestedManyWithoutGeneratedscheduleitemInput
  }

  export type generatedscheduleitemUncheckedCreateInput = {
    id: string
    basedOnRosterItemId?: string | null
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    responsibility?: responsibilityUncheckedCreateNestedManyWithoutGeneratedscheduleitemInput
  }

  export type generatedscheduleitemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fellowshiprosteritem?: fellowshiprosteritemUpdateOneWithoutGeneratedscheduleitemNestedInput
    responsibility?: responsibilityUpdateManyWithoutGeneratedscheduleitemNestedInput
  }

  export type generatedscheduleitemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basedOnRosterItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibility?: responsibilityUncheckedUpdateManyWithoutGeneratedscheduleitemNestedInput
  }

  export type generatedscheduleitemCreateManyInput = {
    id: string
    basedOnRosterItemId?: string | null
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type generatedscheduleitemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type generatedscheduleitemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    basedOnRosterItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupCreateInput = {
    id: string
    name: string
    creatorId: string
    groupImageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    editSettings?: $Enums.group_editSettings
    sendMessage?: $Enums.group_sendMessage
    addMembers?: $Enums.group_addMembers
    approveMembers?: $Enums.group_approveMembers
    groupmember?: groupmemberCreateNestedManyWithoutGroupInput
    groupmessage?: groupmessageCreateNestedManyWithoutGroupInput
  }

  export type groupUncheckedCreateInput = {
    id: string
    name: string
    creatorId: string
    groupImageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    editSettings?: $Enums.group_editSettings
    sendMessage?: $Enums.group_sendMessage
    addMembers?: $Enums.group_addMembers
    approveMembers?: $Enums.group_approveMembers
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutGroupInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type groupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
    groupmember?: groupmemberUpdateManyWithoutGroupNestedInput
    groupmessage?: groupmessageUpdateManyWithoutGroupNestedInput
  }

  export type groupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
    groupmember?: groupmemberUncheckedUpdateManyWithoutGroupNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type groupCreateManyInput = {
    id: string
    name: string
    creatorId: string
    groupImageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    editSettings?: $Enums.group_editSettings
    sendMessage?: $Enums.group_sendMessage
    addMembers?: $Enums.group_addMembers
    approveMembers?: $Enums.group_approveMembers
  }

  export type groupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
  }

  export type groupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
  }

  export type groupmemberCreateInput = {
    id: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
    group: groupCreateNestedOneWithoutGroupmemberInput
    user: userCreateNestedOneWithoutGroupmemberInput
  }

  export type groupmemberUncheckedCreateInput = {
    id: string
    groupId: string
    userId: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
  }

  export type groupmemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: groupUpdateOneRequiredWithoutGroupmemberNestedInput
    user?: userUpdateOneRequiredWithoutGroupmemberNestedInput
  }

  export type groupmemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmemberCreateManyInput = {
    id: string
    groupId: string
    userId: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
  }

  export type groupmemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmessageCreateInput = {
    id: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
    group: groupCreateNestedOneWithoutGroupmessageInput
    user: userCreateNestedOneWithoutGroupmessageInput
  }

  export type groupmessageUncheckedCreateInput = {
    id: string
    groupId: string
    senderId: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
  }

  export type groupmessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: groupUpdateOneRequiredWithoutGroupmessageNestedInput
    user?: userUpdateOneRequiredWithoutGroupmessageNestedInput
  }

  export type groupmessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmessageCreateManyInput = {
    id: string
    groupId: string
    senderId: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
  }

  export type groupmessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historychapterCreateInput = {
    id: string
    chapterNumber: number
    title: string
    content: string
    status: $Enums.historychapter_status
    imageUrl?: string | null
    summary?: string | null
    authorId?: string | null
    authorName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    lastPublishedAt?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    likes?: number
    comment?: commentCreateNestedManyWithoutHistorychapterInput
  }

  export type historychapterUncheckedCreateInput = {
    id: string
    chapterNumber: number
    title: string
    content: string
    status: $Enums.historychapter_status
    imageUrl?: string | null
    summary?: string | null
    authorId?: string | null
    authorName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    lastPublishedAt?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    likes?: number
    comment?: commentUncheckedCreateNestedManyWithoutHistorychapterInput
  }

  export type historychapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: Enumhistorychapter_statusFieldUpdateOperationsInput | $Enums.historychapter_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUpdateManyWithoutHistorychapterNestedInput
  }

  export type historychapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: Enumhistorychapter_statusFieldUpdateOperationsInput | $Enums.historychapter_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUncheckedUpdateManyWithoutHistorychapterNestedInput
  }

  export type historychapterCreateManyInput = {
    id: string
    chapterNumber: number
    title: string
    content: string
    status: $Enums.historychapter_status
    imageUrl?: string | null
    summary?: string | null
    authorId?: string | null
    authorName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    lastPublishedAt?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    likes?: number
  }

  export type historychapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: Enumhistorychapter_statusFieldUpdateOperationsInput | $Enums.historychapter_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type historychapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: Enumhistorychapter_statusFieldUpdateOperationsInput | $Enums.historychapter_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type historymilestoneCreateInput = {
    id: string
    year: string
    title: string
    description: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type historymilestoneUncheckedCreateInput = {
    id: string
    year: string
    title: string
    description: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type historymilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historymilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historymilestoneCreateManyInput = {
    id: string
    year: string
    title: string
    description: string
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type historymilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type historymilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type homeslideCreateInput = {
    id: string
    title: string
    description: string
    imageUrl: string
    ctaText: string
    linkPath: string
    order: number
    isActive: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type homeslideUncheckedCreateInput = {
    id: string
    title: string
    description: string
    imageUrl: string
    ctaText: string
    linkPath: string
    order: number
    isActive: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type homeslideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    ctaText?: StringFieldUpdateOperationsInput | string
    linkPath?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type homeslideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    ctaText?: StringFieldUpdateOperationsInput | string
    linkPath?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type homeslideCreateManyInput = {
    id: string
    title: string
    description: string
    imageUrl: string
    ctaText: string
    linkPath: string
    order: number
    isActive: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type homeslideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    ctaText?: StringFieldUpdateOperationsInput | string
    linkPath?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type homeslideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    ctaText?: StringFieldUpdateOperationsInput | string
    linkPath?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type keypersonCreateInput = {
    id: string
    name: string
    role: string
    imageUrl?: string | null
    bio: string
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type keypersonUncheckedCreateInput = {
    id: string
    name: string
    role: string
    imageUrl?: string | null
    bio: string
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type keypersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type keypersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type keypersonCreateManyInput = {
    id: string
    name: string
    role: string
    imageUrl?: string | null
    bio: string
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type keypersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type keypersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type meetingdecisionpointCreateInput = {
    id: string
    description: string
    proposedBy?: string | null
    status: $Enums.meetingdecisionpoint_status
    followUpNotes?: string | null
    resolutionDate?: Date | string | null
    meetinglog: meetinglogCreateNestedOneWithoutMeetingdecisionpointInput
  }

  export type meetingdecisionpointUncheckedCreateInput = {
    id: string
    description: string
    proposedBy?: string | null
    status: $Enums.meetingdecisionpoint_status
    followUpNotes?: string | null
    resolutionDate?: Date | string | null
    meetingLogId: string
  }

  export type meetingdecisionpointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummeetingdecisionpoint_statusFieldUpdateOperationsInput | $Enums.meetingdecisionpoint_status
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetinglog?: meetinglogUpdateOneRequiredWithoutMeetingdecisionpointNestedInput
  }

  export type meetingdecisionpointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummeetingdecisionpoint_statusFieldUpdateOperationsInput | $Enums.meetingdecisionpoint_status
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingLogId?: StringFieldUpdateOperationsInput | string
  }

  export type meetingdecisionpointCreateManyInput = {
    id: string
    description: string
    proposedBy?: string | null
    status: $Enums.meetingdecisionpoint_status
    followUpNotes?: string | null
    resolutionDate?: Date | string | null
    meetingLogId: string
  }

  export type meetingdecisionpointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummeetingdecisionpoint_statusFieldUpdateOperationsInput | $Enums.meetingdecisionpoint_status
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type meetingdecisionpointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummeetingdecisionpoint_statusFieldUpdateOperationsInput | $Enums.meetingdecisionpoint_status
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meetingLogId?: StringFieldUpdateOperationsInput | string
  }

  export type meetinglogCreateInput = {
    id: string
    meetingDate: Date | string
    title: string
    meetingType?: $Enums.meetinglog_meetingType | null
    attendees: string
    agenda: string
    minutes: string
    actionItems?: string | null
    status?: $Enums.meetinglog_status | null
    imageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    meetingdecisionpoint?: meetingdecisionpointCreateNestedManyWithoutMeetinglogInput
  }

  export type meetinglogUncheckedCreateInput = {
    id: string
    meetingDate: Date | string
    title: string
    meetingType?: $Enums.meetinglog_meetingType | null
    attendees: string
    agenda: string
    minutes: string
    actionItems?: string | null
    status?: $Enums.meetinglog_status | null
    imageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    meetingdecisionpoint?: meetingdecisionpointUncheckedCreateNestedManyWithoutMeetinglogInput
  }

  export type meetinglogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    meetingType?: NullableEnummeetinglog_meetingTypeFieldUpdateOperationsInput | $Enums.meetinglog_meetingType | null
    attendees?: StringFieldUpdateOperationsInput | string
    agenda?: StringFieldUpdateOperationsInput | string
    minutes?: StringFieldUpdateOperationsInput | string
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnummeetinglog_statusFieldUpdateOperationsInput | $Enums.meetinglog_status | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingdecisionpoint?: meetingdecisionpointUpdateManyWithoutMeetinglogNestedInput
  }

  export type meetinglogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    meetingType?: NullableEnummeetinglog_meetingTypeFieldUpdateOperationsInput | $Enums.meetinglog_meetingType | null
    attendees?: StringFieldUpdateOperationsInput | string
    agenda?: StringFieldUpdateOperationsInput | string
    minutes?: StringFieldUpdateOperationsInput | string
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnummeetinglog_statusFieldUpdateOperationsInput | $Enums.meetinglog_status | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingdecisionpoint?: meetingdecisionpointUncheckedUpdateManyWithoutMeetinglogNestedInput
  }

  export type meetinglogCreateManyInput = {
    id: string
    meetingDate: Date | string
    title: string
    meetingType?: $Enums.meetinglog_meetingType | null
    attendees: string
    agenda: string
    minutes: string
    actionItems?: string | null
    status?: $Enums.meetinglog_status | null
    imageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meetinglogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    meetingType?: NullableEnummeetinglog_meetingTypeFieldUpdateOperationsInput | $Enums.meetinglog_meetingType | null
    attendees?: StringFieldUpdateOperationsInput | string
    agenda?: StringFieldUpdateOperationsInput | string
    minutes?: StringFieldUpdateOperationsInput | string
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnummeetinglog_statusFieldUpdateOperationsInput | $Enums.meetinglog_status | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetinglogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    meetingType?: NullableEnummeetinglog_meetingTypeFieldUpdateOperationsInput | $Enums.meetinglog_meetingType | null
    attendees?: StringFieldUpdateOperationsInput | string
    agenda?: StringFieldUpdateOperationsInput | string
    minutes?: StringFieldUpdateOperationsInput | string
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnummeetinglog_statusFieldUpdateOperationsInput | $Enums.meetinglog_status | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ministryCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.ministry_category | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    leader?: string | null
    meetingTime?: string | null
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutMinistryInput
  }

  export type ministryUncheckedCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.ministry_category | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    leader?: string | null
    meetingTime?: string | null
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutMinistryInput
  }

  export type ministryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumministry_categoryFieldUpdateOperationsInput | $Enums.ministry_category | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: NullableStringFieldUpdateOperationsInput | string | null
    meetingTime?: NullableStringFieldUpdateOperationsInput | string | null
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutMinistryNestedInput
  }

  export type ministryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumministry_categoryFieldUpdateOperationsInput | $Enums.ministry_category | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: NullableStringFieldUpdateOperationsInput | string | null
    meetingTime?: NullableStringFieldUpdateOperationsInput | string | null
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutMinistryNestedInput
  }

  export type ministryCreateManyInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.ministry_category | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    leader?: string | null
    meetingTime?: string | null
  }

  export type ministryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumministry_categoryFieldUpdateOperationsInput | $Enums.ministry_category | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: NullableStringFieldUpdateOperationsInput | string | null
    meetingTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ministryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumministry_categoryFieldUpdateOperationsInput | $Enums.ministry_category | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: NullableStringFieldUpdateOperationsInput | string | null
    meetingTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ministryjoinrequestCreateInput = {
    id: string
    userName: string
    userEmail: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
    ministry: ministryCreateNestedOneWithoutMinistryjoinrequestInput
    user: userCreateNestedOneWithoutMinistryjoinrequestInput
  }

  export type ministryjoinrequestUncheckedCreateInput = {
    id: string
    userId: string
    userName: string
    userEmail: string
    ministryId: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
  }

  export type ministryjoinrequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ministry?: ministryUpdateOneRequiredWithoutMinistryjoinrequestNestedInput
    user?: userUpdateOneRequiredWithoutMinistryjoinrequestNestedInput
  }

  export type ministryjoinrequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryId?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ministryjoinrequestCreateManyInput = {
    id: string
    userId: string
    userName: string
    userEmail: string
    ministryId: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
  }

  export type ministryjoinrequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ministryjoinrequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryId?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type monthlythemeimageCreateInput = {
    id: string
    year: number
    month: number
    imageUrls: JsonNullValueInput | InputJsonValue
    quoteOrCaption?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type monthlythemeimageUncheckedCreateInput = {
    id: string
    year: number
    month: number
    imageUrls: JsonNullValueInput | InputJsonValue
    quoteOrCaption?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type monthlythemeimageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    imageUrls?: JsonNullValueInput | InputJsonValue
    quoteOrCaption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type monthlythemeimageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    imageUrls?: JsonNullValueInput | InputJsonValue
    quoteOrCaption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type monthlythemeimageCreateManyInput = {
    id: string
    year: number
    month: number
    imageUrls: JsonNullValueInput | InputJsonValue
    quoteOrCaption?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
  }

  export type monthlythemeimageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    imageUrls?: JsonNullValueInput | InputJsonValue
    quoteOrCaption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type monthlythemeimageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    imageUrls?: JsonNullValueInput | InputJsonValue
    quoteOrCaption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type newsitemCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.newsitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
    comment?: commentCreateNestedManyWithoutNewsitemInput
  }

  export type newsitemUncheckedCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.newsitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
    comment?: commentUncheckedCreateNestedManyWithoutNewsitemInput
  }

  export type newsitemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumnewsitem_categoryFieldUpdateOperationsInput | $Enums.newsitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUpdateManyWithoutNewsitemNestedInput
  }

  export type newsitemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumnewsitem_categoryFieldUpdateOperationsInput | $Enums.newsitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUncheckedUpdateManyWithoutNewsitemNestedInput
  }

  export type newsitemCreateManyInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.newsitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
  }

  export type newsitemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumnewsitem_categoryFieldUpdateOperationsInput | $Enums.newsitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type newsitemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumnewsitem_categoryFieldUpdateOperationsInput | $Enums.newsitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type notificationCreateInput = {
    id: string
    message: string
    link?: string | null
    timestamp?: Date | string
    read?: boolean
    type: $Enums.notification_type
    user: userCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id: string
    targetUserId: string
    message: string
    link?: string | null
    timestamp?: Date | string
    read?: boolean
    type: $Enums.notification_type
  }

  export type notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    user?: userUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
  }

  export type notificationCreateManyInput = {
    id: string
    targetUserId: string
    message: string
    link?: string | null
    timestamp?: Date | string
    read?: boolean
    type: $Enums.notification_type
  }

  export type notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
  }

  export type prayerCreateInput = {
    id: string
    userName: string
    timestamp?: Date | string
    prayerrequest: prayerrequestCreateNestedOneWithoutPrayerInput
    user: userCreateNestedOneWithoutPrayerInput
  }

  export type prayerUncheckedCreateInput = {
    id: string
    userId: string
    userName: string
    timestamp?: Date | string
    prayerRequestId: string
  }

  export type prayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    prayerrequest?: prayerrequestUpdateOneRequiredWithoutPrayerNestedInput
    user?: userUpdateOneRequiredWithoutPrayerNestedInput
  }

  export type prayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    prayerRequestId?: StringFieldUpdateOperationsInput | string
  }

  export type prayerCreateManyInput = {
    id: string
    userId: string
    userName: string
    timestamp?: Date | string
    prayerRequestId: string
  }

  export type prayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    prayerRequestId?: StringFieldUpdateOperationsInput | string
  }

  export type prayerrequestCreateInput = {
    id: string
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    comment?: commentCreateNestedManyWithoutPrayerrequestInput
    prayer?: prayerCreateNestedManyWithoutPrayerrequestInput
    user?: userCreateNestedOneWithoutPrayerrequestInput
  }

  export type prayerrequestUncheckedCreateInput = {
    id: string
    userId?: string | null
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    comment?: commentUncheckedCreateNestedManyWithoutPrayerrequestInput
    prayer?: prayerUncheckedCreateNestedManyWithoutPrayerrequestInput
  }

  export type prayerrequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUpdateManyWithoutPrayerrequestNestedInput
    prayer?: prayerUpdateManyWithoutPrayerrequestNestedInput
    user?: userUpdateOneWithoutPrayerrequestNestedInput
  }

  export type prayerrequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUncheckedUpdateManyWithoutPrayerrequestNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutPrayerrequestNestedInput
  }

  export type prayerrequestCreateManyInput = {
    id: string
    userId?: string | null
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
  }

  export type prayerrequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prayerrequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilityCreateInput = {
    id: string
    role: string
    assignedTo: string
    generatedscheduleitem?: generatedscheduleitemCreateNestedOneWithoutResponsibilityInput
    fellowshiprosteritem?: fellowshiprosteritemCreateNestedOneWithoutResponsibilityInput
  }

  export type responsibilityUncheckedCreateInput = {
    id: string
    role: string
    assignedTo: string
    rosterItemId?: string | null
    generatedScheduleId?: string | null
  }

  export type responsibilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    generatedscheduleitem?: generatedscheduleitemUpdateOneWithoutResponsibilityNestedInput
    fellowshiprosteritem?: fellowshiprosteritemUpdateOneWithoutResponsibilityNestedInput
  }

  export type responsibilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    rosterItemId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilityCreateManyInput = {
    id: string
    role: string
    assignedTo: string
    rosterItemId?: string | null
    generatedScheduleId?: string | null
  }

  export type responsibilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
  }

  export type responsibilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    rosterItemId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sermonCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.sermon_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    speaker?: string | null
    scripture?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fullContent?: string | null
    likes?: number
    comment?: commentCreateNestedManyWithoutSermonInput
  }

  export type sermonUncheckedCreateInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.sermon_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    speaker?: string | null
    scripture?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fullContent?: string | null
    likes?: number
    comment?: commentUncheckedCreateNestedManyWithoutSermonInput
  }

  export type sermonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumsermon_categoryFieldUpdateOperationsInput | $Enums.sermon_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    scripture?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullContent?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUpdateManyWithoutSermonNestedInput
  }

  export type sermonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumsermon_categoryFieldUpdateOperationsInput | $Enums.sermon_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    scripture?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullContent?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    comment?: commentUncheckedUpdateManyWithoutSermonNestedInput
  }

  export type sermonCreateManyInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.sermon_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    speaker?: string | null
    scripture?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fullContent?: string | null
    likes?: number
  }

  export type sermonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumsermon_categoryFieldUpdateOperationsInput | $Enums.sermon_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    scripture?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullContent?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type sermonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumsermon_categoryFieldUpdateOperationsInput | $Enums.sermon_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    scripture?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullContent?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type testimonialCreateInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    title: string
    contentText: string
    visibility: $Enums.testimonial_visibility
    submittedAt?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    user: userCreateNestedOneWithoutTestimonialInput
  }

  export type testimonialUncheckedCreateInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    title: string
    contentText: string
    visibility: $Enums.testimonial_visibility
    submittedAt?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
  }

  export type testimonialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumtestimonial_visibilityFieldUpdateOperationsInput | $Enums.testimonial_visibility
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutTestimonialNestedInput
  }

  export type testimonialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumtestimonial_visibilityFieldUpdateOperationsInput | $Enums.testimonial_visibility
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testimonialCreateManyInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    title: string
    contentText: string
    visibility: $Enums.testimonial_visibility
    submittedAt?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
  }

  export type testimonialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumtestimonial_visibilityFieldUpdateOperationsInput | $Enums.testimonial_visibility
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testimonialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumtestimonial_visibilityFieldUpdateOperationsInput | $Enums.testimonial_visibility
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type aboutsectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    isCoreSection?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type aboutsectionAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type aboutsectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    isCoreSection?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type aboutsectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    isCoreSection?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type aboutsectionSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type adminactionlogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    adminId?: SortOrder
    adminName?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    details?: SortOrder
  }

  export type adminactionlogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    adminId?: SortOrder
    adminName?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    details?: SortOrder
  }

  export type adminactionlogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    adminId?: SortOrder
    adminName?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    details?: SortOrder
  }

  export type Enumadvertisement_adTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.advertisement_adType | Enumadvertisement_adTypeFieldRefInput<$PrismaModel>
    in?: $Enums.advertisement_adType[]
    notIn?: $Enums.advertisement_adType[]
    not?: NestedEnumadvertisement_adTypeFilter<$PrismaModel> | $Enums.advertisement_adType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type advertisementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adType?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    linkUrl?: SortOrder
    altText?: SortOrder
    placements?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    adSizeKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type advertisementAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type advertisementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adType?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    linkUrl?: SortOrder
    altText?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    adSizeKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type advertisementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    adType?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    linkUrl?: SortOrder
    altText?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    displayOrder?: SortOrder
    adSizeKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type advertisementSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type Enumadvertisement_adTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.advertisement_adType | Enumadvertisement_adTypeFieldRefInput<$PrismaModel>
    in?: $Enums.advertisement_adType[]
    notIn?: $Enums.advertisement_adType[]
    not?: NestedEnumadvertisement_adTypeWithAggregatesFilter<$PrismaModel> | $Enums.advertisement_adType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumadvertisement_adTypeFilter<$PrismaModel>
    _max?: NestedEnumadvertisement_adTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enumblogpost_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.blogpost_category | Enumblogpost_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.blogpost_category[] | null
    notIn?: $Enums.blogpost_category[] | null
    not?: NestedEnumblogpost_categoryNullableFilter<$PrismaModel> | $Enums.blogpost_category | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CommentListRelationFilter = {
    every?: commentWhereInput
    some?: commentWhereInput
    none?: commentWhereInput
  }

  export type commentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blogpostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: SortOrder
    audioUrl?: SortOrder
    mediaUrls?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
    videoUrl?: SortOrder
  }

  export type blogpostAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type blogpostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: SortOrder
    audioUrl?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
    videoUrl?: SortOrder
  }

  export type blogpostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    likes?: SortOrder
    audioUrl?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
    videoUrl?: SortOrder
  }

  export type blogpostSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type Enumblogpost_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.blogpost_category | Enumblogpost_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.blogpost_category[] | null
    notIn?: $Enums.blogpost_category[] | null
    not?: NestedEnumblogpost_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.blogpost_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumblogpost_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumblogpost_categoryNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type branchchurchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pastorName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    serviceTimes?: SortOrder
    mapEmbedUrl?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    establishedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type branchchurchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pastorName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    serviceTimes?: SortOrder
    mapEmbedUrl?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    establishedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type branchchurchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    pastorName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    serviceTimes?: SortOrder
    mapEmbedUrl?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    establishedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type churchmemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    address?: SortOrder
    memberSince?: SortOrder
    dateOfBirth?: SortOrder
    baptismDate?: SortOrder
    familyMembers?: SortOrder
    notes?: SortOrder
    isActiveMember?: SortOrder
    profileImageUrl?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type churchmemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    address?: SortOrder
    memberSince?: SortOrder
    dateOfBirth?: SortOrder
    baptismDate?: SortOrder
    familyMembers?: SortOrder
    notes?: SortOrder
    isActiveMember?: SortOrder
    profileImageUrl?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type churchmemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    contactPhone?: SortOrder
    contactEmail?: SortOrder
    address?: SortOrder
    memberSince?: SortOrder
    dateOfBirth?: SortOrder
    baptismDate?: SortOrder
    familyMembers?: SortOrder
    notes?: SortOrder
    isActiveMember?: SortOrder
    profileImageUrl?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Enumcollectionrecord_purposeFilter<$PrismaModel = never> = {
    equals?: $Enums.collectionrecord_purpose | Enumcollectionrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.collectionrecord_purpose[]
    notIn?: $Enums.collectionrecord_purpose[]
    not?: NestedEnumcollectionrecord_purposeFilter<$PrismaModel> | $Enums.collectionrecord_purpose
  }

  export type DonordetailListRelationFilter = {
    every?: donordetailWhereInput
    some?: donordetailWhereInput
    none?: donordetailWhereInput
  }

  export type donordetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collectionrecordCountOrderByAggregateInput = {
    id?: SortOrder
    collectorName?: SortOrder
    collectionDate?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
    recordedByOwnerId?: SortOrder
    recordedByOwnerName?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    countedBy?: SortOrder
    isDeposited?: SortOrder
    depositDate?: SortOrder
    bankDepositReference?: SortOrder
  }

  export type collectionrecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type collectionrecordMaxOrderByAggregateInput = {
    id?: SortOrder
    collectorName?: SortOrder
    collectionDate?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
    recordedByOwnerId?: SortOrder
    recordedByOwnerName?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    countedBy?: SortOrder
    isDeposited?: SortOrder
    depositDate?: SortOrder
    bankDepositReference?: SortOrder
  }

  export type collectionrecordMinOrderByAggregateInput = {
    id?: SortOrder
    collectorName?: SortOrder
    collectionDate?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    recordedAt?: SortOrder
    recordedByOwnerId?: SortOrder
    recordedByOwnerName?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    countedBy?: SortOrder
    isDeposited?: SortOrder
    depositDate?: SortOrder
    bankDepositReference?: SortOrder
  }

  export type collectionrecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Enumcollectionrecord_purposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.collectionrecord_purpose | Enumcollectionrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.collectionrecord_purpose[]
    notIn?: $Enums.collectionrecord_purpose[]
    not?: NestedEnumcollectionrecord_purposeWithAggregatesFilter<$PrismaModel> | $Enums.collectionrecord_purpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcollectionrecord_purposeFilter<$PrismaModel>
    _max?: NestedEnumcollectionrecord_purposeFilter<$PrismaModel>
  }

  export type BlogpostNullableRelationFilter = {
    is?: blogpostWhereInput | null
    isNot?: blogpostWhereInput | null
  }

  export type EventitemNullableRelationFilter = {
    is?: eventitemWhereInput | null
    isNot?: eventitemWhereInput | null
  }

  export type HistorychapterNullableRelationFilter = {
    is?: historychapterWhereInput | null
    isNot?: historychapterWhereInput | null
  }

  export type NewsitemNullableRelationFilter = {
    is?: newsitemWhereInput | null
    isNot?: newsitemWhereInput | null
  }

  export type PrayerrequestNullableRelationFilter = {
    is?: prayerrequestWhereInput | null
    isNot?: prayerrequestWhereInput | null
  }

  export type SermonNullableRelationFilter = {
    is?: sermonWhereInput | null
    isNot?: sermonWhereInput | null
  }

  export type commentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    editedAt?: SortOrder
    sermonId?: SortOrder
    eventId?: SortOrder
    blogPostId?: SortOrder
    newsItemId?: SortOrder
    historyChapterId?: SortOrder
    prayerRequestId?: SortOrder
  }

  export type commentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    editedAt?: SortOrder
    sermonId?: SortOrder
    eventId?: SortOrder
    blogPostId?: SortOrder
    newsItemId?: SortOrder
    historyChapterId?: SortOrder
    prayerRequestId?: SortOrder
  }

  export type commentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    editedAt?: SortOrder
    sermonId?: SortOrder
    eventId?: SortOrder
    blogPostId?: SortOrder
    newsItemId?: SortOrder
    historyChapterId?: SortOrder
    prayerRequestId?: SortOrder
  }

  export type Enumcontactmessage_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.contactmessage_status | Enumcontactmessage_statusFieldRefInput<$PrismaModel>
    in?: $Enums.contactmessage_status[]
    notIn?: $Enums.contactmessage_status[]
    not?: NestedEnumcontactmessage_statusFilter<$PrismaModel> | $Enums.contactmessage_status
  }

  export type contactmessageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    repliedAt?: SortOrder
    replyNote?: SortOrder
  }

  export type contactmessageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    repliedAt?: SortOrder
    replyNote?: SortOrder
  }

  export type contactmessageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    repliedAt?: SortOrder
    replyNote?: SortOrder
  }

  export type Enumcontactmessage_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactmessage_status | Enumcontactmessage_statusFieldRefInput<$PrismaModel>
    in?: $Enums.contactmessage_status[]
    notIn?: $Enums.contactmessage_status[]
    not?: NestedEnumcontactmessage_statusWithAggregatesFilter<$PrismaModel> | $Enums.contactmessage_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactmessage_statusFilter<$PrismaModel>
    _max?: NestedEnumcontactmessage_statusFilter<$PrismaModel>
  }

  export type Enumdecisionlog_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.decisionlog_status | Enumdecisionlog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.decisionlog_status[] | null
    notIn?: $Enums.decisionlog_status[] | null
    not?: NestedEnumdecisionlog_statusNullableFilter<$PrismaModel> | $Enums.decisionlog_status | null
  }

  export type decisionlogCountOrderByAggregateInput = {
    id?: SortOrder
    decisionDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    madeBy?: SortOrder
    status?: SortOrder
    followUpActions?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type decisionlogMaxOrderByAggregateInput = {
    id?: SortOrder
    decisionDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    madeBy?: SortOrder
    status?: SortOrder
    followUpActions?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type decisionlogMinOrderByAggregateInput = {
    id?: SortOrder
    decisionDate?: SortOrder
    title?: SortOrder
    description?: SortOrder
    madeBy?: SortOrder
    status?: SortOrder
    followUpActions?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumdecisionlog_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.decisionlog_status | Enumdecisionlog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.decisionlog_status[] | null
    notIn?: $Enums.decisionlog_status[] | null
    not?: NestedEnumdecisionlog_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.decisionlog_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumdecisionlog_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumdecisionlog_statusNullableFilter<$PrismaModel>
  }

  export type Enumdirectmediaitem_mediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.directmediaitem_mediaType | Enumdirectmediaitem_mediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.directmediaitem_mediaType[]
    notIn?: $Enums.directmediaitem_mediaType[]
    not?: NestedEnumdirectmediaitem_mediaTypeFilter<$PrismaModel> | $Enums.directmediaitem_mediaType
  }

  export type directmediaitemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    uploadDate?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    updatedAt?: SortOrder
  }

  export type directmediaitemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    category?: SortOrder
    uploadDate?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    updatedAt?: SortOrder
  }

  export type directmediaitemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    mediaType?: SortOrder
    category?: SortOrder
    uploadDate?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumdirectmediaitem_mediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.directmediaitem_mediaType | Enumdirectmediaitem_mediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.directmediaitem_mediaType[]
    notIn?: $Enums.directmediaitem_mediaType[]
    not?: NestedEnumdirectmediaitem_mediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.directmediaitem_mediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdirectmediaitem_mediaTypeFilter<$PrismaModel>
    _max?: NestedEnumdirectmediaitem_mediaTypeFilter<$PrismaModel>
  }

  export type donatepagecontentCountOrderByAggregateInput = {
    id?: SortOrder
    headerTitle?: SortOrder
    headerSubtitle?: SortOrder
    headerImageUrl?: SortOrder
    localDonationsTitle?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    branch?: SortOrder
    bankQrImageUrl?: SortOrder
    eSewaId?: SortOrder
    eSewaQrImageUrl?: SortOrder
    localDonationsNote?: SortOrder
    internationalDonationsTitle?: SortOrder
    internationalDonationsContent?: SortOrder
    internationalDonationsContactEmail?: SortOrder
    internationalQrImageUrl?: SortOrder
    receiptVerses?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type donatepagecontentMaxOrderByAggregateInput = {
    id?: SortOrder
    headerTitle?: SortOrder
    headerSubtitle?: SortOrder
    headerImageUrl?: SortOrder
    localDonationsTitle?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    branch?: SortOrder
    bankQrImageUrl?: SortOrder
    eSewaId?: SortOrder
    eSewaQrImageUrl?: SortOrder
    localDonationsNote?: SortOrder
    internationalDonationsTitle?: SortOrder
    internationalDonationsContent?: SortOrder
    internationalDonationsContactEmail?: SortOrder
    internationalQrImageUrl?: SortOrder
    receiptVerses?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type donatepagecontentMinOrderByAggregateInput = {
    id?: SortOrder
    headerTitle?: SortOrder
    headerSubtitle?: SortOrder
    headerImageUrl?: SortOrder
    localDonationsTitle?: SortOrder
    bankName?: SortOrder
    accountName?: SortOrder
    accountNumber?: SortOrder
    branch?: SortOrder
    bankQrImageUrl?: SortOrder
    eSewaId?: SortOrder
    eSewaQrImageUrl?: SortOrder
    localDonationsNote?: SortOrder
    internationalDonationsTitle?: SortOrder
    internationalDonationsContent?: SortOrder
    internationalDonationsContactEmail?: SortOrder
    internationalQrImageUrl?: SortOrder
    receiptVerses?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type Enumdonationrecord_purposeFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_purpose | Enumdonationrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.donationrecord_purpose[]
    notIn?: $Enums.donationrecord_purpose[]
    not?: NestedEnumdonationrecord_purposeFilter<$PrismaModel> | $Enums.donationrecord_purpose
  }

  export type Enumdonationrecord_paymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_paymentMethod | Enumdonationrecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.donationrecord_paymentMethod[] | null
    notIn?: $Enums.donationrecord_paymentMethod[] | null
    not?: NestedEnumdonationrecord_paymentMethodNullableFilter<$PrismaModel> | $Enums.donationrecord_paymentMethod | null
  }

  export type donationrecordCountOrderByAggregateInput = {
    id?: SortOrder
    donorName?: SortOrder
    donorEmail?: SortOrder
    donorPhone?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    donationDate?: SortOrder
    transactionTimestamp?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethod?: SortOrder
    transactionReference?: SortOrder
    notes?: SortOrder
    isReceiptSent?: SortOrder
  }

  export type donationrecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type donationrecordMaxOrderByAggregateInput = {
    id?: SortOrder
    donorName?: SortOrder
    donorEmail?: SortOrder
    donorPhone?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    donationDate?: SortOrder
    transactionTimestamp?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethod?: SortOrder
    transactionReference?: SortOrder
    notes?: SortOrder
    isReceiptSent?: SortOrder
  }

  export type donationrecordMinOrderByAggregateInput = {
    id?: SortOrder
    donorName?: SortOrder
    donorEmail?: SortOrder
    donorPhone?: SortOrder
    amount?: SortOrder
    purpose?: SortOrder
    donationDate?: SortOrder
    transactionTimestamp?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethod?: SortOrder
    transactionReference?: SortOrder
    notes?: SortOrder
    isReceiptSent?: SortOrder
  }

  export type donationrecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Enumdonationrecord_purposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_purpose | Enumdonationrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.donationrecord_purpose[]
    notIn?: $Enums.donationrecord_purpose[]
    not?: NestedEnumdonationrecord_purposeWithAggregatesFilter<$PrismaModel> | $Enums.donationrecord_purpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdonationrecord_purposeFilter<$PrismaModel>
    _max?: NestedEnumdonationrecord_purposeFilter<$PrismaModel>
  }

  export type Enumdonationrecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_paymentMethod | Enumdonationrecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.donationrecord_paymentMethod[] | null
    notIn?: $Enums.donationrecord_paymentMethod[] | null
    not?: NestedEnumdonationrecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.donationrecord_paymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumdonationrecord_paymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumdonationrecord_paymentMethodNullableFilter<$PrismaModel>
  }

  export type CollectionrecordRelationFilter = {
    is?: collectionrecordWhereInput
    isNot?: collectionrecordWhereInput
  }

  export type donordetailCountOrderByAggregateInput = {
    id?: SortOrder
    donorName?: SortOrder
    amount?: SortOrder
    address?: SortOrder
    contact?: SortOrder
    collectionRecordId?: SortOrder
  }

  export type donordetailAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type donordetailMaxOrderByAggregateInput = {
    id?: SortOrder
    donorName?: SortOrder
    amount?: SortOrder
    address?: SortOrder
    contact?: SortOrder
    collectionRecordId?: SortOrder
  }

  export type donordetailMinOrderByAggregateInput = {
    id?: SortOrder
    donorName?: SortOrder
    amount?: SortOrder
    address?: SortOrder
    contact?: SortOrder
    collectionRecordId?: SortOrder
  }

  export type donordetailSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Enumeventitem_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.eventitem_category | Enumeventitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.eventitem_category[] | null
    notIn?: $Enums.eventitem_category[] | null
    not?: NestedEnumeventitem_categoryNullableFilter<$PrismaModel> | $Enums.eventitem_category | null
  }

  export type eventitemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    time?: SortOrder
    expectations?: SortOrder
    guests?: SortOrder
    contactPerson?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    registrationLink?: SortOrder
    capacity?: SortOrder
    isFeeRequired?: SortOrder
    feeAmount?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    likes?: SortOrder
  }

  export type eventitemAvgOrderByAggregateInput = {
    capacity?: SortOrder
    likes?: SortOrder
  }

  export type eventitemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    time?: SortOrder
    expectations?: SortOrder
    guests?: SortOrder
    contactPerson?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    registrationLink?: SortOrder
    capacity?: SortOrder
    isFeeRequired?: SortOrder
    feeAmount?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    likes?: SortOrder
  }

  export type eventitemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    time?: SortOrder
    expectations?: SortOrder
    guests?: SortOrder
    contactPerson?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    registrationLink?: SortOrder
    capacity?: SortOrder
    isFeeRequired?: SortOrder
    feeAmount?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    likes?: SortOrder
  }

  export type eventitemSumOrderByAggregateInput = {
    capacity?: SortOrder
    likes?: SortOrder
  }

  export type Enumeventitem_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.eventitem_category | Enumeventitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.eventitem_category[] | null
    notIn?: $Enums.eventitem_category[] | null
    not?: NestedEnumeventitem_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.eventitem_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumeventitem_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumeventitem_categoryNullableFilter<$PrismaModel>
  }

  export type Enumexpenserecord_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_category | Enumexpenserecord_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.expenserecord_category[]
    notIn?: $Enums.expenserecord_category[]
    not?: NestedEnumexpenserecord_categoryFilter<$PrismaModel> | $Enums.expenserecord_category
  }

  export type Enumexpenserecord_paymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_paymentMethod | Enumexpenserecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_paymentMethod[] | null
    notIn?: $Enums.expenserecord_paymentMethod[] | null
    not?: NestedEnumexpenserecord_paymentMethodNullableFilter<$PrismaModel> | $Enums.expenserecord_paymentMethod | null
  }

  export type Enumexpenserecord_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_status | Enumexpenserecord_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_status[] | null
    notIn?: $Enums.expenserecord_status[] | null
    not?: NestedEnumexpenserecord_statusNullableFilter<$PrismaModel> | $Enums.expenserecord_status | null
  }

  export type expenserecordCountOrderByAggregateInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    payee?: SortOrder
    paymentMethod?: SortOrder
    transactionReference?: SortOrder
    receiptUrl?: SortOrder
    approvedBy?: SortOrder
    notes?: SortOrder
    source?: SortOrder
    location?: SortOrder
    status?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type expenserecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type expenserecordMaxOrderByAggregateInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    payee?: SortOrder
    paymentMethod?: SortOrder
    transactionReference?: SortOrder
    receiptUrl?: SortOrder
    approvedBy?: SortOrder
    notes?: SortOrder
    source?: SortOrder
    location?: SortOrder
    status?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type expenserecordMinOrderByAggregateInput = {
    id?: SortOrder
    expenseDate?: SortOrder
    category?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    payee?: SortOrder
    paymentMethod?: SortOrder
    transactionReference?: SortOrder
    receiptUrl?: SortOrder
    approvedBy?: SortOrder
    notes?: SortOrder
    source?: SortOrder
    location?: SortOrder
    status?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type expenserecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Enumexpenserecord_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_category | Enumexpenserecord_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.expenserecord_category[]
    notIn?: $Enums.expenserecord_category[]
    not?: NestedEnumexpenserecord_categoryWithAggregatesFilter<$PrismaModel> | $Enums.expenserecord_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumexpenserecord_categoryFilter<$PrismaModel>
    _max?: NestedEnumexpenserecord_categoryFilter<$PrismaModel>
  }

  export type Enumexpenserecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_paymentMethod | Enumexpenserecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_paymentMethod[] | null
    notIn?: $Enums.expenserecord_paymentMethod[] | null
    not?: NestedEnumexpenserecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.expenserecord_paymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumexpenserecord_paymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumexpenserecord_paymentMethodNullableFilter<$PrismaModel>
  }

  export type Enumexpenserecord_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_status | Enumexpenserecord_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_status[] | null
    notIn?: $Enums.expenserecord_status[] | null
    not?: NestedEnumexpenserecord_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.expenserecord_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumexpenserecord_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumexpenserecord_statusNullableFilter<$PrismaModel>
  }

  export type Enumfellowshiprosteritem_rosterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.fellowshiprosteritem_rosterType | Enumfellowshiprosteritem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.fellowshiprosteritem_rosterType[]
    notIn?: $Enums.fellowshiprosteritem_rosterType[]
    not?: NestedEnumfellowshiprosteritem_rosterTypeFilter<$PrismaModel> | $Enums.fellowshiprosteritem_rosterType
  }

  export type GeneratedscheduleitemListRelationFilter = {
    every?: generatedscheduleitemWhereInput
    some?: generatedscheduleitemWhereInput
    none?: generatedscheduleitemWhereInput
  }

  export type ResponsibilityListRelationFilter = {
    every?: responsibilityWhereInput
    some?: responsibilityWhereInput
    none?: responsibilityWhereInput
  }

  export type generatedscheduleitemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type responsibilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fellowshiprosteritemCountOrderByAggregateInput = {
    id?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    assignedDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrder
    contactNumber?: SortOrder
    additionalNotesOrProgramDetails?: SortOrder
    isTemplate?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fellowshiprosteritemMaxOrderByAggregateInput = {
    id?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    assignedDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrder
    contactNumber?: SortOrder
    additionalNotesOrProgramDetails?: SortOrder
    isTemplate?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type fellowshiprosteritemMinOrderByAggregateInput = {
    id?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    assignedDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrder
    contactNumber?: SortOrder
    additionalNotesOrProgramDetails?: SortOrder
    isTemplate?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumfellowshiprosteritem_rosterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.fellowshiprosteritem_rosterType | Enumfellowshiprosteritem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.fellowshiprosteritem_rosterType[]
    notIn?: $Enums.fellowshiprosteritem_rosterType[]
    not?: NestedEnumfellowshiprosteritem_rosterTypeWithAggregatesFilter<$PrismaModel> | $Enums.fellowshiprosteritem_rosterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfellowshiprosteritem_rosterTypeFilter<$PrismaModel>
    _max?: NestedEnumfellowshiprosteritem_rosterTypeFilter<$PrismaModel>
  }

  export type Enumfriendship_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.friendship_status | Enumfriendship_statusFieldRefInput<$PrismaModel>
    in?: $Enums.friendship_status[]
    notIn?: $Enums.friendship_status[]
    not?: NestedEnumfriendship_statusFilter<$PrismaModel> | $Enums.friendship_status
  }

  export type friendshipRequesterIdAddresseeIdCompoundUniqueInput = {
    requesterId: string
    addresseeId: string
  }

  export type friendshipCountOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type friendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type friendshipMinOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumfriendship_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.friendship_status | Enumfriendship_statusFieldRefInput<$PrismaModel>
    in?: $Enums.friendship_status[]
    notIn?: $Enums.friendship_status[]
    not?: NestedEnumfriendship_statusWithAggregatesFilter<$PrismaModel> | $Enums.friendship_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfriendship_statusFilter<$PrismaModel>
    _max?: NestedEnumfriendship_statusFilter<$PrismaModel>
  }

  export type frontendactivitylogCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
  }

  export type frontendactivitylogMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
  }

  export type frontendactivitylogMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    itemType?: SortOrder
  }

  export type Enumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedscheduleitem_rosterType | Enumgeneratedscheduleitem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedscheduleitem_rosterType[]
    notIn?: $Enums.generatedscheduleitem_rosterType[]
    not?: NestedEnumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel> | $Enums.generatedscheduleitem_rosterType
  }

  export type FellowshiprosteritemNullableRelationFilter = {
    is?: fellowshiprosteritemWhereInput | null
    isNot?: fellowshiprosteritemWhereInput | null
  }

  export type generatedscheduleitemCountOrderByAggregateInput = {
    id?: SortOrder
    basedOnRosterItemId?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    scheduledDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrder
    contactNumber?: SortOrder
    additionalNotesOrProgramDetails?: SortOrder
    generatedAt?: SortOrder
    isPublishedAsEvent?: SortOrder
    publishedEventId?: SortOrder
    adminNotes?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type generatedscheduleitemMaxOrderByAggregateInput = {
    id?: SortOrder
    basedOnRosterItemId?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    scheduledDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrder
    contactNumber?: SortOrder
    additionalNotesOrProgramDetails?: SortOrder
    generatedAt?: SortOrder
    isPublishedAsEvent?: SortOrder
    publishedEventId?: SortOrder
    adminNotes?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type generatedscheduleitemMinOrderByAggregateInput = {
    id?: SortOrder
    basedOnRosterItemId?: SortOrder
    rosterType?: SortOrder
    groupNameOrEventTitle?: SortOrder
    scheduledDate?: SortOrder
    timeSlot?: SortOrder
    location?: SortOrder
    contactNumber?: SortOrder
    additionalNotesOrProgramDetails?: SortOrder
    generatedAt?: SortOrder
    isPublishedAsEvent?: SortOrder
    publishedEventId?: SortOrder
    adminNotes?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumgeneratedscheduleitem_rosterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedscheduleitem_rosterType | Enumgeneratedscheduleitem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedscheduleitem_rosterType[]
    notIn?: $Enums.generatedscheduleitem_rosterType[]
    not?: NestedEnumgeneratedscheduleitem_rosterTypeWithAggregatesFilter<$PrismaModel> | $Enums.generatedscheduleitem_rosterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel>
    _max?: NestedEnumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel>
  }

  export type Enumgroup_editSettingsFilter<$PrismaModel = never> = {
    equals?: $Enums.group_editSettings | Enumgroup_editSettingsFieldRefInput<$PrismaModel>
    in?: $Enums.group_editSettings[]
    notIn?: $Enums.group_editSettings[]
    not?: NestedEnumgroup_editSettingsFilter<$PrismaModel> | $Enums.group_editSettings
  }

  export type Enumgroup_sendMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.group_sendMessage | Enumgroup_sendMessageFieldRefInput<$PrismaModel>
    in?: $Enums.group_sendMessage[]
    notIn?: $Enums.group_sendMessage[]
    not?: NestedEnumgroup_sendMessageFilter<$PrismaModel> | $Enums.group_sendMessage
  }

  export type Enumgroup_addMembersFilter<$PrismaModel = never> = {
    equals?: $Enums.group_addMembers | Enumgroup_addMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_addMembers[]
    notIn?: $Enums.group_addMembers[]
    not?: NestedEnumgroup_addMembersFilter<$PrismaModel> | $Enums.group_addMembers
  }

  export type Enumgroup_approveMembersFilter<$PrismaModel = never> = {
    equals?: $Enums.group_approveMembers | Enumgroup_approveMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_approveMembers[]
    notIn?: $Enums.group_approveMembers[]
    not?: NestedEnumgroup_approveMembersFilter<$PrismaModel> | $Enums.group_approveMembers
  }

  export type GroupmemberListRelationFilter = {
    every?: groupmemberWhereInput
    some?: groupmemberWhereInput
    none?: groupmemberWhereInput
  }

  export type GroupmessageListRelationFilter = {
    every?: groupmessageWhereInput
    some?: groupmessageWhereInput
    none?: groupmessageWhereInput
  }

  export type groupmemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groupmessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    groupImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editSettings?: SortOrder
    sendMessage?: SortOrder
    addMembers?: SortOrder
    approveMembers?: SortOrder
  }

  export type groupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    groupImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editSettings?: SortOrder
    sendMessage?: SortOrder
    addMembers?: SortOrder
    approveMembers?: SortOrder
  }

  export type groupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creatorId?: SortOrder
    groupImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    editSettings?: SortOrder
    sendMessage?: SortOrder
    addMembers?: SortOrder
    approveMembers?: SortOrder
  }

  export type Enumgroup_editSettingsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_editSettings | Enumgroup_editSettingsFieldRefInput<$PrismaModel>
    in?: $Enums.group_editSettings[]
    notIn?: $Enums.group_editSettings[]
    not?: NestedEnumgroup_editSettingsWithAggregatesFilter<$PrismaModel> | $Enums.group_editSettings
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_editSettingsFilter<$PrismaModel>
    _max?: NestedEnumgroup_editSettingsFilter<$PrismaModel>
  }

  export type Enumgroup_sendMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_sendMessage | Enumgroup_sendMessageFieldRefInput<$PrismaModel>
    in?: $Enums.group_sendMessage[]
    notIn?: $Enums.group_sendMessage[]
    not?: NestedEnumgroup_sendMessageWithAggregatesFilter<$PrismaModel> | $Enums.group_sendMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_sendMessageFilter<$PrismaModel>
    _max?: NestedEnumgroup_sendMessageFilter<$PrismaModel>
  }

  export type Enumgroup_addMembersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_addMembers | Enumgroup_addMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_addMembers[]
    notIn?: $Enums.group_addMembers[]
    not?: NestedEnumgroup_addMembersWithAggregatesFilter<$PrismaModel> | $Enums.group_addMembers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_addMembersFilter<$PrismaModel>
    _max?: NestedEnumgroup_addMembersFilter<$PrismaModel>
  }

  export type Enumgroup_approveMembersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_approveMembers | Enumgroup_approveMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_approveMembers[]
    notIn?: $Enums.group_approveMembers[]
    not?: NestedEnumgroup_approveMembersWithAggregatesFilter<$PrismaModel> | $Enums.group_approveMembers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_approveMembersFilter<$PrismaModel>
    _max?: NestedEnumgroup_approveMembersFilter<$PrismaModel>
  }

  export type Enumgroupmember_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmember_role | Enumgroupmember_roleFieldRefInput<$PrismaModel>
    in?: $Enums.groupmember_role[]
    notIn?: $Enums.groupmember_role[]
    not?: NestedEnumgroupmember_roleFilter<$PrismaModel> | $Enums.groupmember_role
  }

  export type GroupRelationFilter = {
    is?: groupWhereInput
    isNot?: groupWhereInput
  }

  export type groupmemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type groupmemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    addedAt?: SortOrder
  }

  export type groupmemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    addedAt?: SortOrder
  }

  export type groupmemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    addedAt?: SortOrder
  }

  export type Enumgroupmember_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmember_role | Enumgroupmember_roleFieldRefInput<$PrismaModel>
    in?: $Enums.groupmember_role[]
    notIn?: $Enums.groupmember_role[]
    not?: NestedEnumgroupmember_roleWithAggregatesFilter<$PrismaModel> | $Enums.groupmember_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroupmember_roleFilter<$PrismaModel>
    _max?: NestedEnumgroupmember_roleFilter<$PrismaModel>
  }

  export type Enumgroupmessage_mediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmessage_mediaType | Enumgroupmessage_mediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.groupmessage_mediaType[] | null
    notIn?: $Enums.groupmessage_mediaType[] | null
    not?: NestedEnumgroupmessage_mediaTypeNullableFilter<$PrismaModel> | $Enums.groupmessage_mediaType | null
  }

  export type groupmessageCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderProfileImageUrl?: SortOrder
    text?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    timestamp?: SortOrder
  }

  export type groupmessageMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderProfileImageUrl?: SortOrder
    text?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    timestamp?: SortOrder
  }

  export type groupmessageMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    senderId?: SortOrder
    senderName?: SortOrder
    senderProfileImageUrl?: SortOrder
    text?: SortOrder
    mediaUrl?: SortOrder
    mediaType?: SortOrder
    timestamp?: SortOrder
  }

  export type Enumgroupmessage_mediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmessage_mediaType | Enumgroupmessage_mediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.groupmessage_mediaType[] | null
    notIn?: $Enums.groupmessage_mediaType[] | null
    not?: NestedEnumgroupmessage_mediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.groupmessage_mediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumgroupmessage_mediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumgroupmessage_mediaTypeNullableFilter<$PrismaModel>
  }

  export type Enumhistorychapter_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.historychapter_status | Enumhistorychapter_statusFieldRefInput<$PrismaModel>
    in?: $Enums.historychapter_status[]
    notIn?: $Enums.historychapter_status[]
    not?: NestedEnumhistorychapter_statusFilter<$PrismaModel> | $Enums.historychapter_status
  }

  export type historychapterCountOrderByAggregateInput = {
    id?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    summary?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPublishedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    likes?: SortOrder
  }

  export type historychapterAvgOrderByAggregateInput = {
    chapterNumber?: SortOrder
    likes?: SortOrder
  }

  export type historychapterMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    summary?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPublishedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    likes?: SortOrder
  }

  export type historychapterMinOrderByAggregateInput = {
    id?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    summary?: SortOrder
    authorId?: SortOrder
    authorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastPublishedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    likes?: SortOrder
  }

  export type historychapterSumOrderByAggregateInput = {
    chapterNumber?: SortOrder
    likes?: SortOrder
  }

  export type Enumhistorychapter_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.historychapter_status | Enumhistorychapter_statusFieldRefInput<$PrismaModel>
    in?: $Enums.historychapter_status[]
    notIn?: $Enums.historychapter_status[]
    not?: NestedEnumhistorychapter_statusWithAggregatesFilter<$PrismaModel> | $Enums.historychapter_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhistorychapter_statusFilter<$PrismaModel>
    _max?: NestedEnumhistorychapter_statusFilter<$PrismaModel>
  }

  export type historymilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type historymilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type historymilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type homeslideCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ctaText?: SortOrder
    linkPath?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type homeslideAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type homeslideMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ctaText?: SortOrder
    linkPath?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type homeslideMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    ctaText?: SortOrder
    linkPath?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type homeslideSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type keypersonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type keypersonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type keypersonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    imageUrl?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type Enummeetingdecisionpoint_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.meetingdecisionpoint_status | Enummeetingdecisionpoint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.meetingdecisionpoint_status[]
    notIn?: $Enums.meetingdecisionpoint_status[]
    not?: NestedEnummeetingdecisionpoint_statusFilter<$PrismaModel> | $Enums.meetingdecisionpoint_status
  }

  export type MeetinglogRelationFilter = {
    is?: meetinglogWhereInput
    isNot?: meetinglogWhereInput
  }

  export type meetingdecisionpointCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    proposedBy?: SortOrder
    status?: SortOrder
    followUpNotes?: SortOrder
    resolutionDate?: SortOrder
    meetingLogId?: SortOrder
  }

  export type meetingdecisionpointMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    proposedBy?: SortOrder
    status?: SortOrder
    followUpNotes?: SortOrder
    resolutionDate?: SortOrder
    meetingLogId?: SortOrder
  }

  export type meetingdecisionpointMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    proposedBy?: SortOrder
    status?: SortOrder
    followUpNotes?: SortOrder
    resolutionDate?: SortOrder
    meetingLogId?: SortOrder
  }

  export type Enummeetingdecisionpoint_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meetingdecisionpoint_status | Enummeetingdecisionpoint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.meetingdecisionpoint_status[]
    notIn?: $Enums.meetingdecisionpoint_status[]
    not?: NestedEnummeetingdecisionpoint_statusWithAggregatesFilter<$PrismaModel> | $Enums.meetingdecisionpoint_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeetingdecisionpoint_statusFilter<$PrismaModel>
    _max?: NestedEnummeetingdecisionpoint_statusFilter<$PrismaModel>
  }

  export type Enummeetinglog_meetingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_meetingType | Enummeetinglog_meetingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_meetingType[] | null
    notIn?: $Enums.meetinglog_meetingType[] | null
    not?: NestedEnummeetinglog_meetingTypeNullableFilter<$PrismaModel> | $Enums.meetinglog_meetingType | null
  }

  export type Enummeetinglog_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_status | Enummeetinglog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_status[] | null
    notIn?: $Enums.meetinglog_status[] | null
    not?: NestedEnummeetinglog_statusNullableFilter<$PrismaModel> | $Enums.meetinglog_status | null
  }

  export type MeetingdecisionpointListRelationFilter = {
    every?: meetingdecisionpointWhereInput
    some?: meetingdecisionpointWhereInput
    none?: meetingdecisionpointWhereInput
  }

  export type meetingdecisionpointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type meetinglogCountOrderByAggregateInput = {
    id?: SortOrder
    meetingDate?: SortOrder
    title?: SortOrder
    meetingType?: SortOrder
    attendees?: SortOrder
    agenda?: SortOrder
    minutes?: SortOrder
    actionItems?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meetinglogMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingDate?: SortOrder
    title?: SortOrder
    meetingType?: SortOrder
    attendees?: SortOrder
    agenda?: SortOrder
    minutes?: SortOrder
    actionItems?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meetinglogMinOrderByAggregateInput = {
    id?: SortOrder
    meetingDate?: SortOrder
    title?: SortOrder
    meetingType?: SortOrder
    attendees?: SortOrder
    agenda?: SortOrder
    minutes?: SortOrder
    actionItems?: SortOrder
    status?: SortOrder
    imageUrl?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enummeetinglog_meetingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_meetingType | Enummeetinglog_meetingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_meetingType[] | null
    notIn?: $Enums.meetinglog_meetingType[] | null
    not?: NestedEnummeetinglog_meetingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.meetinglog_meetingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummeetinglog_meetingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnummeetinglog_meetingTypeNullableFilter<$PrismaModel>
  }

  export type Enummeetinglog_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_status | Enummeetinglog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_status[] | null
    notIn?: $Enums.meetinglog_status[] | null
    not?: NestedEnummeetinglog_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.meetinglog_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummeetinglog_statusNullableFilter<$PrismaModel>
    _max?: NestedEnummeetinglog_statusNullableFilter<$PrismaModel>
  }

  export type Enumministry_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ministry_category | Enumministry_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ministry_category[] | null
    notIn?: $Enums.ministry_category[] | null
    not?: NestedEnumministry_categoryNullableFilter<$PrismaModel> | $Enums.ministry_category | null
  }

  export type MinistryjoinrequestListRelationFilter = {
    every?: ministryjoinrequestWhereInput
    some?: ministryjoinrequestWhereInput
    none?: ministryjoinrequestWhereInput
  }

  export type ministryjoinrequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ministryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leader?: SortOrder
    meetingTime?: SortOrder
  }

  export type ministryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leader?: SortOrder
    meetingTime?: SortOrder
  }

  export type ministryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    leader?: SortOrder
    meetingTime?: SortOrder
  }

  export type Enumministry_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ministry_category | Enumministry_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ministry_category[] | null
    notIn?: $Enums.ministry_category[] | null
    not?: NestedEnumministry_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ministry_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumministry_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumministry_categoryNullableFilter<$PrismaModel>
  }

  export type Enumministryjoinrequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.ministryjoinrequest_status | Enumministryjoinrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ministryjoinrequest_status[]
    notIn?: $Enums.ministryjoinrequest_status[]
    not?: NestedEnumministryjoinrequest_statusFilter<$PrismaModel> | $Enums.ministryjoinrequest_status
  }

  export type MinistryRelationFilter = {
    is?: ministryWhereInput
    isNot?: ministryWhereInput
  }

  export type ministryjoinrequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ministryId?: SortOrder
    ministryName?: SortOrder
    ministryGuidelines?: SortOrder
    requestDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    processedDate?: SortOrder
    adminNotes?: SortOrder
  }

  export type ministryjoinrequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ministryId?: SortOrder
    ministryName?: SortOrder
    ministryGuidelines?: SortOrder
    requestDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    processedDate?: SortOrder
    adminNotes?: SortOrder
  }

  export type ministryjoinrequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userEmail?: SortOrder
    ministryId?: SortOrder
    ministryName?: SortOrder
    ministryGuidelines?: SortOrder
    requestDate?: SortOrder
    message?: SortOrder
    status?: SortOrder
    processedDate?: SortOrder
    adminNotes?: SortOrder
  }

  export type Enumministryjoinrequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ministryjoinrequest_status | Enumministryjoinrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ministryjoinrequest_status[]
    notIn?: $Enums.ministryjoinrequest_status[]
    not?: NestedEnumministryjoinrequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.ministryjoinrequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumministryjoinrequest_statusFilter<$PrismaModel>
    _max?: NestedEnumministryjoinrequest_statusFilter<$PrismaModel>
  }

  export type monthlythemeimageYearMonthCompoundUniqueInput = {
    year: number
    month: number
  }

  export type monthlythemeimageCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    imageUrls?: SortOrder
    quoteOrCaption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type monthlythemeimageAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
  }

  export type monthlythemeimageMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    quoteOrCaption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type monthlythemeimageMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    month?: SortOrder
    quoteOrCaption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
  }

  export type monthlythemeimageSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
  }

  export type Enumnewsitem_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.newsitem_category | Enumnewsitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.newsitem_category[] | null
    notIn?: $Enums.newsitem_category[] | null
    not?: NestedEnumnewsitem_categoryNullableFilter<$PrismaModel> | $Enums.newsitem_category | null
  }

  export type newsitemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    likes?: SortOrder
  }

  export type newsitemAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type newsitemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    likes?: SortOrder
  }

  export type newsitemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    likes?: SortOrder
  }

  export type newsitemSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type Enumnewsitem_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.newsitem_category | Enumnewsitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.newsitem_category[] | null
    notIn?: $Enums.newsitem_category[] | null
    not?: NestedEnumnewsitem_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.newsitem_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumnewsitem_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumnewsitem_categoryNullableFilter<$PrismaModel>
  }

  export type Enumnotification_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[]
    notIn?: $Enums.notification_type[]
    not?: NestedEnumnotification_typeFilter<$PrismaModel> | $Enums.notification_type
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    message?: SortOrder
    link?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    type?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    message?: SortOrder
    link?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    type?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    message?: SortOrder
    link?: SortOrder
    timestamp?: SortOrder
    read?: SortOrder
    type?: SortOrder
  }

  export type Enumnotification_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[]
    notIn?: $Enums.notification_type[]
    not?: NestedEnumnotification_typeWithAggregatesFilter<$PrismaModel> | $Enums.notification_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotification_typeFilter<$PrismaModel>
    _max?: NestedEnumnotification_typeFilter<$PrismaModel>
  }

  export type PrayerrequestRelationFilter = {
    is?: prayerrequestWhereInput
    isNot?: prayerrequestWhereInput
  }

  export type prayerUserIdPrayerRequestIdCompoundUniqueInput = {
    userId: string
    prayerRequestId: string
  }

  export type prayerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    prayerRequestId?: SortOrder
  }

  export type prayerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    prayerRequestId?: SortOrder
  }

  export type prayerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    timestamp?: SortOrder
    prayerRequestId?: SortOrder
  }

  export type Enumprayerrequest_visibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_visibility | Enumprayerrequest_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_visibility[]
    notIn?: $Enums.prayerrequest_visibility[]
    not?: NestedEnumprayerrequest_visibilityFilter<$PrismaModel> | $Enums.prayerrequest_visibility
  }

  export type Enumprayerrequest_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_category | Enumprayerrequest_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.prayerrequest_category[] | null
    notIn?: $Enums.prayerrequest_category[] | null
    not?: NestedEnumprayerrequest_categoryNullableFilter<$PrismaModel> | $Enums.prayerrequest_category | null
  }

  export type Enumprayerrequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_status | Enumprayerrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_status[]
    notIn?: $Enums.prayerrequest_status[]
    not?: NestedEnumprayerrequest_statusFilter<$PrismaModel> | $Enums.prayerrequest_status
  }

  export type PrayerListRelationFilter = {
    every?: prayerWhereInput
    some?: prayerWhereInput
    none?: prayerWhereInput
  }

  export type prayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type prayerrequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    title?: SortOrder
    requestText?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastPrayedAt?: SortOrder
    adminNotes?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaUrls?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
  }

  export type prayerrequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    title?: SortOrder
    requestText?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastPrayedAt?: SortOrder
    adminNotes?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
  }

  export type prayerrequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    title?: SortOrder
    requestText?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    lastPrayedAt?: SortOrder
    adminNotes?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
  }

  export type Enumprayerrequest_visibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_visibility | Enumprayerrequest_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_visibility[]
    notIn?: $Enums.prayerrequest_visibility[]
    not?: NestedEnumprayerrequest_visibilityWithAggregatesFilter<$PrismaModel> | $Enums.prayerrequest_visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprayerrequest_visibilityFilter<$PrismaModel>
    _max?: NestedEnumprayerrequest_visibilityFilter<$PrismaModel>
  }

  export type Enumprayerrequest_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_category | Enumprayerrequest_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.prayerrequest_category[] | null
    notIn?: $Enums.prayerrequest_category[] | null
    not?: NestedEnumprayerrequest_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.prayerrequest_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumprayerrequest_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumprayerrequest_categoryNullableFilter<$PrismaModel>
  }

  export type Enumprayerrequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_status | Enumprayerrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_status[]
    notIn?: $Enums.prayerrequest_status[]
    not?: NestedEnumprayerrequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.prayerrequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprayerrequest_statusFilter<$PrismaModel>
    _max?: NestedEnumprayerrequest_statusFilter<$PrismaModel>
  }

  export type GeneratedscheduleitemNullableRelationFilter = {
    is?: generatedscheduleitemWhereInput | null
    isNot?: generatedscheduleitemWhereInput | null
  }

  export type responsibilityCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    assignedTo?: SortOrder
    rosterItemId?: SortOrder
    generatedScheduleId?: SortOrder
  }

  export type responsibilityMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    assignedTo?: SortOrder
    rosterItemId?: SortOrder
    generatedScheduleId?: SortOrder
  }

  export type responsibilityMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    assignedTo?: SortOrder
    rosterItemId?: SortOrder
    generatedScheduleId?: SortOrder
  }

  export type Enumsermon_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.sermon_category | Enumsermon_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.sermon_category[] | null
    notIn?: $Enums.sermon_category[] | null
    not?: NestedEnumsermon_categoryNullableFilter<$PrismaModel> | $Enums.sermon_category | null
  }

  export type sermonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    speaker?: SortOrder
    scripture?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fullContent?: SortOrder
    likes?: SortOrder
  }

  export type sermonAvgOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type sermonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    speaker?: SortOrder
    scripture?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fullContent?: SortOrder
    likes?: SortOrder
  }

  export type sermonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    linkPath?: SortOrder
    category?: SortOrder
    date?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    speaker?: SortOrder
    scripture?: SortOrder
    videoUrl?: SortOrder
    audioUrl?: SortOrder
    fullContent?: SortOrder
    likes?: SortOrder
  }

  export type sermonSumOrderByAggregateInput = {
    likes?: SortOrder
  }

  export type Enumsermon_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sermon_category | Enumsermon_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.sermon_category[] | null
    notIn?: $Enums.sermon_category[] | null
    not?: NestedEnumsermon_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.sermon_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsermon_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumsermon_categoryNullableFilter<$PrismaModel>
  }

  export type Enumtestimonial_visibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.testimonial_visibility | Enumtestimonial_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.testimonial_visibility[]
    notIn?: $Enums.testimonial_visibility[]
    not?: NestedEnumtestimonial_visibilityFilter<$PrismaModel> | $Enums.testimonial_visibility
  }

  export type testimonialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    title?: SortOrder
    contentText?: SortOrder
    visibility?: SortOrder
    submittedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mediaUrls?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
  }

  export type testimonialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    title?: SortOrder
    contentText?: SortOrder
    visibility?: SortOrder
    submittedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
  }

  export type testimonialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userProfileImageUrl?: SortOrder
    title?: SortOrder
    contentText?: SortOrder
    visibility?: SortOrder
    submittedAt?: SortOrder
    postedByOwnerId?: SortOrder
    postedByOwnerName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: SortOrder
    taggedFriends?: SortOrder
    feelingActivity?: SortOrder
    backgroundTheme?: SortOrder
  }

  export type Enumtestimonial_visibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.testimonial_visibility | Enumtestimonial_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.testimonial_visibility[]
    notIn?: $Enums.testimonial_visibility[]
    not?: NestedEnumtestimonial_visibilityWithAggregatesFilter<$PrismaModel> | $Enums.testimonial_visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtestimonial_visibilityFilter<$PrismaModel>
    _max?: NestedEnumtestimonial_visibilityFilter<$PrismaModel>
  }

  export type Enumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type Enumuser_relationshipStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_relationshipStatus | Enumuser_relationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_relationshipStatus[] | null
    notIn?: $Enums.user_relationshipStatus[] | null
    not?: NestedEnumuser_relationshipStatusNullableFilter<$PrismaModel> | $Enums.user_relationshipStatus | null
  }

  export type Enumuser_friendsListPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendsListPrivacy | Enumuser_friendsListPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendsListPrivacy[]
    notIn?: $Enums.user_friendsListPrivacy[]
    not?: NestedEnumuser_friendsListPrivacyFilter<$PrismaModel> | $Enums.user_friendsListPrivacy
  }

  export type Enumuser_friendRequestPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendRequestPrivacy | Enumuser_friendRequestPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendRequestPrivacy[]
    notIn?: $Enums.user_friendRequestPrivacy[]
    not?: NestedEnumuser_friendRequestPrivacyFilter<$PrismaModel> | $Enums.user_friendRequestPrivacy
  }

  export type Enumuser_groupInvitePrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.user_groupInvitePrivacy | Enumuser_groupInvitePrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_groupInvitePrivacy[]
    notIn?: $Enums.user_groupInvitePrivacy[]
    not?: NestedEnumuser_groupInvitePrivacyFilter<$PrismaModel> | $Enums.user_groupInvitePrivacy
  }

  export type AdminactionlogListRelationFilter = {
    every?: adminactionlogWhereInput
    some?: adminactionlogWhereInput
    none?: adminactionlogWhereInput
  }

  export type ChurchmemberNullableRelationFilter = {
    is?: churchmemberWhereInput | null
    isNot?: churchmemberWhereInput | null
  }

  export type FriendshipListRelationFilter = {
    every?: friendshipWhereInput
    some?: friendshipWhereInput
    none?: friendshipWhereInput
  }

  export type FrontendactivitylogListRelationFilter = {
    every?: frontendactivitylogWhereInput
    some?: frontendactivitylogWhereInput
    none?: frontendactivitylogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type PrayerrequestListRelationFilter = {
    every?: prayerrequestWhereInput
    some?: prayerrequestWhereInput
    none?: prayerrequestWhereInput
  }

  export type TestimonialListRelationFilter = {
    every?: testimonialWhereInput
    some?: testimonialWhereInput
    none?: testimonialWhereInput
  }

  export type adminactionlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type friendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type frontendactivitylogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type prayerrequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type testimonialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    password?: SortOrder
    passwordHash?: SortOrder
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    profileImageUrl?: SortOrder
    coverPhotoUrl?: SortOrder
    bio?: SortOrder
    hometown?: SortOrder
    currentCity?: SortOrder
    work?: SortOrder
    education?: SortOrder
    relationshipStatus?: SortOrder
    interests?: SortOrder
    favoriteScripture?: SortOrder
    receiveContentUpdateNotifications?: SortOrder
    receivePrayerRequestNotifications?: SortOrder
    receiveTestimonialNotifications?: SortOrder
    receiveFriendActivityNotifications?: SortOrder
    friendsListPrivacy?: SortOrder
    profileInSearchPrivacy?: SortOrder
    friendRequestPrivacy?: SortOrder
    groupInvitePrivacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    password?: SortOrder
    passwordHash?: SortOrder
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    profileImageUrl?: SortOrder
    coverPhotoUrl?: SortOrder
    bio?: SortOrder
    hometown?: SortOrder
    currentCity?: SortOrder
    work?: SortOrder
    education?: SortOrder
    relationshipStatus?: SortOrder
    interests?: SortOrder
    favoriteScripture?: SortOrder
    receiveContentUpdateNotifications?: SortOrder
    receivePrayerRequestNotifications?: SortOrder
    receiveTestimonialNotifications?: SortOrder
    receiveFriendActivityNotifications?: SortOrder
    friendsListPrivacy?: SortOrder
    profileInSearchPrivacy?: SortOrder
    friendRequestPrivacy?: SortOrder
    groupInvitePrivacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    password?: SortOrder
    passwordHash?: SortOrder
    id?: SortOrder
    username?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    countryCode?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    profileImageUrl?: SortOrder
    coverPhotoUrl?: SortOrder
    bio?: SortOrder
    hometown?: SortOrder
    currentCity?: SortOrder
    work?: SortOrder
    education?: SortOrder
    relationshipStatus?: SortOrder
    interests?: SortOrder
    favoriteScripture?: SortOrder
    receiveContentUpdateNotifications?: SortOrder
    receivePrayerRequestNotifications?: SortOrder
    receiveTestimonialNotifications?: SortOrder
    receiveFriendActivityNotifications?: SortOrder
    friendsListPrivacy?: SortOrder
    profileInSearchPrivacy?: SortOrder
    friendRequestPrivacy?: SortOrder
    groupInvitePrivacy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type Enumuser_relationshipStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_relationshipStatus | Enumuser_relationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_relationshipStatus[] | null
    notIn?: $Enums.user_relationshipStatus[] | null
    not?: NestedEnumuser_relationshipStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_relationshipStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_relationshipStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_relationshipStatusNullableFilter<$PrismaModel>
  }

  export type Enumuser_friendsListPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendsListPrivacy | Enumuser_friendsListPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendsListPrivacy[]
    notIn?: $Enums.user_friendsListPrivacy[]
    not?: NestedEnumuser_friendsListPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.user_friendsListPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_friendsListPrivacyFilter<$PrismaModel>
    _max?: NestedEnumuser_friendsListPrivacyFilter<$PrismaModel>
  }

  export type Enumuser_friendRequestPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendRequestPrivacy | Enumuser_friendRequestPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendRequestPrivacy[]
    notIn?: $Enums.user_friendRequestPrivacy[]
    not?: NestedEnumuser_friendRequestPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.user_friendRequestPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_friendRequestPrivacyFilter<$PrismaModel>
    _max?: NestedEnumuser_friendRequestPrivacyFilter<$PrismaModel>
  }

  export type Enumuser_groupInvitePrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_groupInvitePrivacy | Enumuser_groupInvitePrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_groupInvitePrivacy[]
    notIn?: $Enums.user_groupInvitePrivacy[]
    not?: NestedEnumuser_groupInvitePrivacyWithAggregatesFilter<$PrismaModel> | $Enums.user_groupInvitePrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_groupInvitePrivacyFilter<$PrismaModel>
    _max?: NestedEnumuser_groupInvitePrivacyFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutAdminactionlogInput = {
    create?: XOR<userCreateWithoutAdminactionlogInput, userUncheckedCreateWithoutAdminactionlogInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminactionlogInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutAdminactionlogNestedInput = {
    create?: XOR<userCreateWithoutAdminactionlogInput, userUncheckedCreateWithoutAdminactionlogInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminactionlogInput
    upsert?: userUpsertWithoutAdminactionlogInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAdminactionlogInput, userUpdateWithoutAdminactionlogInput>, userUncheckedUpdateWithoutAdminactionlogInput>
  }

  export type Enumadvertisement_adTypeFieldUpdateOperationsInput = {
    set?: $Enums.advertisement_adType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type commentCreateNestedManyWithoutBlogpostInput = {
    create?: XOR<commentCreateWithoutBlogpostInput, commentUncheckedCreateWithoutBlogpostInput> | commentCreateWithoutBlogpostInput[] | commentUncheckedCreateWithoutBlogpostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutBlogpostInput | commentCreateOrConnectWithoutBlogpostInput[]
    createMany?: commentCreateManyBlogpostInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type commentUncheckedCreateNestedManyWithoutBlogpostInput = {
    create?: XOR<commentCreateWithoutBlogpostInput, commentUncheckedCreateWithoutBlogpostInput> | commentCreateWithoutBlogpostInput[] | commentUncheckedCreateWithoutBlogpostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutBlogpostInput | commentCreateOrConnectWithoutBlogpostInput[]
    createMany?: commentCreateManyBlogpostInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type NullableEnumblogpost_categoryFieldUpdateOperationsInput = {
    set?: $Enums.blogpost_category | null
  }

  export type commentUpdateManyWithoutBlogpostNestedInput = {
    create?: XOR<commentCreateWithoutBlogpostInput, commentUncheckedCreateWithoutBlogpostInput> | commentCreateWithoutBlogpostInput[] | commentUncheckedCreateWithoutBlogpostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutBlogpostInput | commentCreateOrConnectWithoutBlogpostInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutBlogpostInput | commentUpsertWithWhereUniqueWithoutBlogpostInput[]
    createMany?: commentCreateManyBlogpostInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutBlogpostInput | commentUpdateWithWhereUniqueWithoutBlogpostInput[]
    updateMany?: commentUpdateManyWithWhereWithoutBlogpostInput | commentUpdateManyWithWhereWithoutBlogpostInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type commentUncheckedUpdateManyWithoutBlogpostNestedInput = {
    create?: XOR<commentCreateWithoutBlogpostInput, commentUncheckedCreateWithoutBlogpostInput> | commentCreateWithoutBlogpostInput[] | commentUncheckedCreateWithoutBlogpostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutBlogpostInput | commentCreateOrConnectWithoutBlogpostInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutBlogpostInput | commentUpsertWithWhereUniqueWithoutBlogpostInput[]
    createMany?: commentCreateManyBlogpostInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutBlogpostInput | commentUpdateWithWhereUniqueWithoutBlogpostInput[]
    updateMany?: commentUpdateManyWithWhereWithoutBlogpostInput | commentUpdateManyWithWhereWithoutBlogpostInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutChurchmemberInput = {
    create?: XOR<userCreateWithoutChurchmemberInput, userUncheckedCreateWithoutChurchmemberInput>
    connectOrCreate?: userCreateOrConnectWithoutChurchmemberInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutChurchmemberNestedInput = {
    create?: XOR<userCreateWithoutChurchmemberInput, userUncheckedCreateWithoutChurchmemberInput>
    connectOrCreate?: userCreateOrConnectWithoutChurchmemberInput
    upsert?: userUpsertWithoutChurchmemberInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutChurchmemberInput, userUpdateWithoutChurchmemberInput>, userUncheckedUpdateWithoutChurchmemberInput>
  }

  export type donordetailCreateNestedManyWithoutCollectionrecordInput = {
    create?: XOR<donordetailCreateWithoutCollectionrecordInput, donordetailUncheckedCreateWithoutCollectionrecordInput> | donordetailCreateWithoutCollectionrecordInput[] | donordetailUncheckedCreateWithoutCollectionrecordInput[]
    connectOrCreate?: donordetailCreateOrConnectWithoutCollectionrecordInput | donordetailCreateOrConnectWithoutCollectionrecordInput[]
    createMany?: donordetailCreateManyCollectionrecordInputEnvelope
    connect?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
  }

  export type donordetailUncheckedCreateNestedManyWithoutCollectionrecordInput = {
    create?: XOR<donordetailCreateWithoutCollectionrecordInput, donordetailUncheckedCreateWithoutCollectionrecordInput> | donordetailCreateWithoutCollectionrecordInput[] | donordetailUncheckedCreateWithoutCollectionrecordInput[]
    connectOrCreate?: donordetailCreateOrConnectWithoutCollectionrecordInput | donordetailCreateOrConnectWithoutCollectionrecordInput[]
    createMany?: donordetailCreateManyCollectionrecordInputEnvelope
    connect?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Enumcollectionrecord_purposeFieldUpdateOperationsInput = {
    set?: $Enums.collectionrecord_purpose
  }

  export type donordetailUpdateManyWithoutCollectionrecordNestedInput = {
    create?: XOR<donordetailCreateWithoutCollectionrecordInput, donordetailUncheckedCreateWithoutCollectionrecordInput> | donordetailCreateWithoutCollectionrecordInput[] | donordetailUncheckedCreateWithoutCollectionrecordInput[]
    connectOrCreate?: donordetailCreateOrConnectWithoutCollectionrecordInput | donordetailCreateOrConnectWithoutCollectionrecordInput[]
    upsert?: donordetailUpsertWithWhereUniqueWithoutCollectionrecordInput | donordetailUpsertWithWhereUniqueWithoutCollectionrecordInput[]
    createMany?: donordetailCreateManyCollectionrecordInputEnvelope
    set?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    disconnect?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    delete?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    connect?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    update?: donordetailUpdateWithWhereUniqueWithoutCollectionrecordInput | donordetailUpdateWithWhereUniqueWithoutCollectionrecordInput[]
    updateMany?: donordetailUpdateManyWithWhereWithoutCollectionrecordInput | donordetailUpdateManyWithWhereWithoutCollectionrecordInput[]
    deleteMany?: donordetailScalarWhereInput | donordetailScalarWhereInput[]
  }

  export type donordetailUncheckedUpdateManyWithoutCollectionrecordNestedInput = {
    create?: XOR<donordetailCreateWithoutCollectionrecordInput, donordetailUncheckedCreateWithoutCollectionrecordInput> | donordetailCreateWithoutCollectionrecordInput[] | donordetailUncheckedCreateWithoutCollectionrecordInput[]
    connectOrCreate?: donordetailCreateOrConnectWithoutCollectionrecordInput | donordetailCreateOrConnectWithoutCollectionrecordInput[]
    upsert?: donordetailUpsertWithWhereUniqueWithoutCollectionrecordInput | donordetailUpsertWithWhereUniqueWithoutCollectionrecordInput[]
    createMany?: donordetailCreateManyCollectionrecordInputEnvelope
    set?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    disconnect?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    delete?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    connect?: donordetailWhereUniqueInput | donordetailWhereUniqueInput[]
    update?: donordetailUpdateWithWhereUniqueWithoutCollectionrecordInput | donordetailUpdateWithWhereUniqueWithoutCollectionrecordInput[]
    updateMany?: donordetailUpdateManyWithWhereWithoutCollectionrecordInput | donordetailUpdateManyWithWhereWithoutCollectionrecordInput[]
    deleteMany?: donordetailScalarWhereInput | donordetailScalarWhereInput[]
  }

  export type blogpostCreateNestedOneWithoutCommentInput = {
    create?: XOR<blogpostCreateWithoutCommentInput, blogpostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: blogpostCreateOrConnectWithoutCommentInput
    connect?: blogpostWhereUniqueInput
  }

  export type eventitemCreateNestedOneWithoutCommentInput = {
    create?: XOR<eventitemCreateWithoutCommentInput, eventitemUncheckedCreateWithoutCommentInput>
    connectOrCreate?: eventitemCreateOrConnectWithoutCommentInput
    connect?: eventitemWhereUniqueInput
  }

  export type historychapterCreateNestedOneWithoutCommentInput = {
    create?: XOR<historychapterCreateWithoutCommentInput, historychapterUncheckedCreateWithoutCommentInput>
    connectOrCreate?: historychapterCreateOrConnectWithoutCommentInput
    connect?: historychapterWhereUniqueInput
  }

  export type newsitemCreateNestedOneWithoutCommentInput = {
    create?: XOR<newsitemCreateWithoutCommentInput, newsitemUncheckedCreateWithoutCommentInput>
    connectOrCreate?: newsitemCreateOrConnectWithoutCommentInput
    connect?: newsitemWhereUniqueInput
  }

  export type prayerrequestCreateNestedOneWithoutCommentInput = {
    create?: XOR<prayerrequestCreateWithoutCommentInput, prayerrequestUncheckedCreateWithoutCommentInput>
    connectOrCreate?: prayerrequestCreateOrConnectWithoutCommentInput
    connect?: prayerrequestWhereUniqueInput
  }

  export type sermonCreateNestedOneWithoutCommentInput = {
    create?: XOR<sermonCreateWithoutCommentInput, sermonUncheckedCreateWithoutCommentInput>
    connectOrCreate?: sermonCreateOrConnectWithoutCommentInput
    connect?: sermonWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCommentInput = {
    create?: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
    connectOrCreate?: userCreateOrConnectWithoutCommentInput
    connect?: userWhereUniqueInput
  }

  export type blogpostUpdateOneWithoutCommentNestedInput = {
    create?: XOR<blogpostCreateWithoutCommentInput, blogpostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: blogpostCreateOrConnectWithoutCommentInput
    upsert?: blogpostUpsertWithoutCommentInput
    disconnect?: blogpostWhereInput | boolean
    delete?: blogpostWhereInput | boolean
    connect?: blogpostWhereUniqueInput
    update?: XOR<XOR<blogpostUpdateToOneWithWhereWithoutCommentInput, blogpostUpdateWithoutCommentInput>, blogpostUncheckedUpdateWithoutCommentInput>
  }

  export type eventitemUpdateOneWithoutCommentNestedInput = {
    create?: XOR<eventitemCreateWithoutCommentInput, eventitemUncheckedCreateWithoutCommentInput>
    connectOrCreate?: eventitemCreateOrConnectWithoutCommentInput
    upsert?: eventitemUpsertWithoutCommentInput
    disconnect?: eventitemWhereInput | boolean
    delete?: eventitemWhereInput | boolean
    connect?: eventitemWhereUniqueInput
    update?: XOR<XOR<eventitemUpdateToOneWithWhereWithoutCommentInput, eventitemUpdateWithoutCommentInput>, eventitemUncheckedUpdateWithoutCommentInput>
  }

  export type historychapterUpdateOneWithoutCommentNestedInput = {
    create?: XOR<historychapterCreateWithoutCommentInput, historychapterUncheckedCreateWithoutCommentInput>
    connectOrCreate?: historychapterCreateOrConnectWithoutCommentInput
    upsert?: historychapterUpsertWithoutCommentInput
    disconnect?: historychapterWhereInput | boolean
    delete?: historychapterWhereInput | boolean
    connect?: historychapterWhereUniqueInput
    update?: XOR<XOR<historychapterUpdateToOneWithWhereWithoutCommentInput, historychapterUpdateWithoutCommentInput>, historychapterUncheckedUpdateWithoutCommentInput>
  }

  export type newsitemUpdateOneWithoutCommentNestedInput = {
    create?: XOR<newsitemCreateWithoutCommentInput, newsitemUncheckedCreateWithoutCommentInput>
    connectOrCreate?: newsitemCreateOrConnectWithoutCommentInput
    upsert?: newsitemUpsertWithoutCommentInput
    disconnect?: newsitemWhereInput | boolean
    delete?: newsitemWhereInput | boolean
    connect?: newsitemWhereUniqueInput
    update?: XOR<XOR<newsitemUpdateToOneWithWhereWithoutCommentInput, newsitemUpdateWithoutCommentInput>, newsitemUncheckedUpdateWithoutCommentInput>
  }

  export type prayerrequestUpdateOneWithoutCommentNestedInput = {
    create?: XOR<prayerrequestCreateWithoutCommentInput, prayerrequestUncheckedCreateWithoutCommentInput>
    connectOrCreate?: prayerrequestCreateOrConnectWithoutCommentInput
    upsert?: prayerrequestUpsertWithoutCommentInput
    disconnect?: prayerrequestWhereInput | boolean
    delete?: prayerrequestWhereInput | boolean
    connect?: prayerrequestWhereUniqueInput
    update?: XOR<XOR<prayerrequestUpdateToOneWithWhereWithoutCommentInput, prayerrequestUpdateWithoutCommentInput>, prayerrequestUncheckedUpdateWithoutCommentInput>
  }

  export type sermonUpdateOneWithoutCommentNestedInput = {
    create?: XOR<sermonCreateWithoutCommentInput, sermonUncheckedCreateWithoutCommentInput>
    connectOrCreate?: sermonCreateOrConnectWithoutCommentInput
    upsert?: sermonUpsertWithoutCommentInput
    disconnect?: sermonWhereInput | boolean
    delete?: sermonWhereInput | boolean
    connect?: sermonWhereUniqueInput
    update?: XOR<XOR<sermonUpdateToOneWithWhereWithoutCommentInput, sermonUpdateWithoutCommentInput>, sermonUncheckedUpdateWithoutCommentInput>
  }

  export type userUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
    connectOrCreate?: userCreateOrConnectWithoutCommentInput
    upsert?: userUpsertWithoutCommentInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCommentInput, userUpdateWithoutCommentInput>, userUncheckedUpdateWithoutCommentInput>
  }

  export type Enumcontactmessage_statusFieldUpdateOperationsInput = {
    set?: $Enums.contactmessage_status
  }

  export type NullableEnumdecisionlog_statusFieldUpdateOperationsInput = {
    set?: $Enums.decisionlog_status | null
  }

  export type Enumdirectmediaitem_mediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.directmediaitem_mediaType
  }

  export type Enumdonationrecord_purposeFieldUpdateOperationsInput = {
    set?: $Enums.donationrecord_purpose
  }

  export type NullableEnumdonationrecord_paymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.donationrecord_paymentMethod | null
  }

  export type collectionrecordCreateNestedOneWithoutDonordetailInput = {
    create?: XOR<collectionrecordCreateWithoutDonordetailInput, collectionrecordUncheckedCreateWithoutDonordetailInput>
    connectOrCreate?: collectionrecordCreateOrConnectWithoutDonordetailInput
    connect?: collectionrecordWhereUniqueInput
  }

  export type collectionrecordUpdateOneRequiredWithoutDonordetailNestedInput = {
    create?: XOR<collectionrecordCreateWithoutDonordetailInput, collectionrecordUncheckedCreateWithoutDonordetailInput>
    connectOrCreate?: collectionrecordCreateOrConnectWithoutDonordetailInput
    upsert?: collectionrecordUpsertWithoutDonordetailInput
    connect?: collectionrecordWhereUniqueInput
    update?: XOR<XOR<collectionrecordUpdateToOneWithWhereWithoutDonordetailInput, collectionrecordUpdateWithoutDonordetailInput>, collectionrecordUncheckedUpdateWithoutDonordetailInput>
  }

  export type commentCreateNestedManyWithoutEventitemInput = {
    create?: XOR<commentCreateWithoutEventitemInput, commentUncheckedCreateWithoutEventitemInput> | commentCreateWithoutEventitemInput[] | commentUncheckedCreateWithoutEventitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutEventitemInput | commentCreateOrConnectWithoutEventitemInput[]
    createMany?: commentCreateManyEventitemInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type commentUncheckedCreateNestedManyWithoutEventitemInput = {
    create?: XOR<commentCreateWithoutEventitemInput, commentUncheckedCreateWithoutEventitemInput> | commentCreateWithoutEventitemInput[] | commentUncheckedCreateWithoutEventitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutEventitemInput | commentCreateOrConnectWithoutEventitemInput[]
    createMany?: commentCreateManyEventitemInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type NullableEnumeventitem_categoryFieldUpdateOperationsInput = {
    set?: $Enums.eventitem_category | null
  }

  export type commentUpdateManyWithoutEventitemNestedInput = {
    create?: XOR<commentCreateWithoutEventitemInput, commentUncheckedCreateWithoutEventitemInput> | commentCreateWithoutEventitemInput[] | commentUncheckedCreateWithoutEventitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutEventitemInput | commentCreateOrConnectWithoutEventitemInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutEventitemInput | commentUpsertWithWhereUniqueWithoutEventitemInput[]
    createMany?: commentCreateManyEventitemInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutEventitemInput | commentUpdateWithWhereUniqueWithoutEventitemInput[]
    updateMany?: commentUpdateManyWithWhereWithoutEventitemInput | commentUpdateManyWithWhereWithoutEventitemInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type commentUncheckedUpdateManyWithoutEventitemNestedInput = {
    create?: XOR<commentCreateWithoutEventitemInput, commentUncheckedCreateWithoutEventitemInput> | commentCreateWithoutEventitemInput[] | commentUncheckedCreateWithoutEventitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutEventitemInput | commentCreateOrConnectWithoutEventitemInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutEventitemInput | commentUpsertWithWhereUniqueWithoutEventitemInput[]
    createMany?: commentCreateManyEventitemInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutEventitemInput | commentUpdateWithWhereUniqueWithoutEventitemInput[]
    updateMany?: commentUpdateManyWithWhereWithoutEventitemInput | commentUpdateManyWithWhereWithoutEventitemInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type Enumexpenserecord_categoryFieldUpdateOperationsInput = {
    set?: $Enums.expenserecord_category
  }

  export type NullableEnumexpenserecord_paymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.expenserecord_paymentMethod | null
  }

  export type NullableEnumexpenserecord_statusFieldUpdateOperationsInput = {
    set?: $Enums.expenserecord_status | null
  }

  export type generatedscheduleitemCreateNestedManyWithoutFellowshiprosteritemInput = {
    create?: XOR<generatedscheduleitemCreateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput> | generatedscheduleitemCreateWithoutFellowshiprosteritemInput[] | generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput | generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput[]
    createMany?: generatedscheduleitemCreateManyFellowshiprosteritemInputEnvelope
    connect?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
  }

  export type responsibilityCreateNestedManyWithoutFellowshiprosteritemInput = {
    create?: XOR<responsibilityCreateWithoutFellowshiprosteritemInput, responsibilityUncheckedCreateWithoutFellowshiprosteritemInput> | responsibilityCreateWithoutFellowshiprosteritemInput[] | responsibilityUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutFellowshiprosteritemInput | responsibilityCreateOrConnectWithoutFellowshiprosteritemInput[]
    createMany?: responsibilityCreateManyFellowshiprosteritemInputEnvelope
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
  }

  export type generatedscheduleitemUncheckedCreateNestedManyWithoutFellowshiprosteritemInput = {
    create?: XOR<generatedscheduleitemCreateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput> | generatedscheduleitemCreateWithoutFellowshiprosteritemInput[] | generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput | generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput[]
    createMany?: generatedscheduleitemCreateManyFellowshiprosteritemInputEnvelope
    connect?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
  }

  export type responsibilityUncheckedCreateNestedManyWithoutFellowshiprosteritemInput = {
    create?: XOR<responsibilityCreateWithoutFellowshiprosteritemInput, responsibilityUncheckedCreateWithoutFellowshiprosteritemInput> | responsibilityCreateWithoutFellowshiprosteritemInput[] | responsibilityUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutFellowshiprosteritemInput | responsibilityCreateOrConnectWithoutFellowshiprosteritemInput[]
    createMany?: responsibilityCreateManyFellowshiprosteritemInputEnvelope
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
  }

  export type Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput = {
    set?: $Enums.fellowshiprosteritem_rosterType
  }

  export type generatedscheduleitemUpdateManyWithoutFellowshiprosteritemNestedInput = {
    create?: XOR<generatedscheduleitemCreateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput> | generatedscheduleitemCreateWithoutFellowshiprosteritemInput[] | generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput | generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput[]
    upsert?: generatedscheduleitemUpsertWithWhereUniqueWithoutFellowshiprosteritemInput | generatedscheduleitemUpsertWithWhereUniqueWithoutFellowshiprosteritemInput[]
    createMany?: generatedscheduleitemCreateManyFellowshiprosteritemInputEnvelope
    set?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    disconnect?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    delete?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    connect?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    update?: generatedscheduleitemUpdateWithWhereUniqueWithoutFellowshiprosteritemInput | generatedscheduleitemUpdateWithWhereUniqueWithoutFellowshiprosteritemInput[]
    updateMany?: generatedscheduleitemUpdateManyWithWhereWithoutFellowshiprosteritemInput | generatedscheduleitemUpdateManyWithWhereWithoutFellowshiprosteritemInput[]
    deleteMany?: generatedscheduleitemScalarWhereInput | generatedscheduleitemScalarWhereInput[]
  }

  export type responsibilityUpdateManyWithoutFellowshiprosteritemNestedInput = {
    create?: XOR<responsibilityCreateWithoutFellowshiprosteritemInput, responsibilityUncheckedCreateWithoutFellowshiprosteritemInput> | responsibilityCreateWithoutFellowshiprosteritemInput[] | responsibilityUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutFellowshiprosteritemInput | responsibilityCreateOrConnectWithoutFellowshiprosteritemInput[]
    upsert?: responsibilityUpsertWithWhereUniqueWithoutFellowshiprosteritemInput | responsibilityUpsertWithWhereUniqueWithoutFellowshiprosteritemInput[]
    createMany?: responsibilityCreateManyFellowshiprosteritemInputEnvelope
    set?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    disconnect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    delete?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    update?: responsibilityUpdateWithWhereUniqueWithoutFellowshiprosteritemInput | responsibilityUpdateWithWhereUniqueWithoutFellowshiprosteritemInput[]
    updateMany?: responsibilityUpdateManyWithWhereWithoutFellowshiprosteritemInput | responsibilityUpdateManyWithWhereWithoutFellowshiprosteritemInput[]
    deleteMany?: responsibilityScalarWhereInput | responsibilityScalarWhereInput[]
  }

  export type generatedscheduleitemUncheckedUpdateManyWithoutFellowshiprosteritemNestedInput = {
    create?: XOR<generatedscheduleitemCreateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput> | generatedscheduleitemCreateWithoutFellowshiprosteritemInput[] | generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput | generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput[]
    upsert?: generatedscheduleitemUpsertWithWhereUniqueWithoutFellowshiprosteritemInput | generatedscheduleitemUpsertWithWhereUniqueWithoutFellowshiprosteritemInput[]
    createMany?: generatedscheduleitemCreateManyFellowshiprosteritemInputEnvelope
    set?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    disconnect?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    delete?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    connect?: generatedscheduleitemWhereUniqueInput | generatedscheduleitemWhereUniqueInput[]
    update?: generatedscheduleitemUpdateWithWhereUniqueWithoutFellowshiprosteritemInput | generatedscheduleitemUpdateWithWhereUniqueWithoutFellowshiprosteritemInput[]
    updateMany?: generatedscheduleitemUpdateManyWithWhereWithoutFellowshiprosteritemInput | generatedscheduleitemUpdateManyWithWhereWithoutFellowshiprosteritemInput[]
    deleteMany?: generatedscheduleitemScalarWhereInput | generatedscheduleitemScalarWhereInput[]
  }

  export type responsibilityUncheckedUpdateManyWithoutFellowshiprosteritemNestedInput = {
    create?: XOR<responsibilityCreateWithoutFellowshiprosteritemInput, responsibilityUncheckedCreateWithoutFellowshiprosteritemInput> | responsibilityCreateWithoutFellowshiprosteritemInput[] | responsibilityUncheckedCreateWithoutFellowshiprosteritemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutFellowshiprosteritemInput | responsibilityCreateOrConnectWithoutFellowshiprosteritemInput[]
    upsert?: responsibilityUpsertWithWhereUniqueWithoutFellowshiprosteritemInput | responsibilityUpsertWithWhereUniqueWithoutFellowshiprosteritemInput[]
    createMany?: responsibilityCreateManyFellowshiprosteritemInputEnvelope
    set?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    disconnect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    delete?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    update?: responsibilityUpdateWithWhereUniqueWithoutFellowshiprosteritemInput | responsibilityUpdateWithWhereUniqueWithoutFellowshiprosteritemInput[]
    updateMany?: responsibilityUpdateManyWithWhereWithoutFellowshiprosteritemInput | responsibilityUpdateManyWithWhereWithoutFellowshiprosteritemInput[]
    deleteMany?: responsibilityScalarWhereInput | responsibilityScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutFriendship_friendship_addresseeIdTouserInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_addresseeIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_addresseeIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_addresseeIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutFriendship_friendship_requesterIdTouserInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_requesterIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_requesterIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_requesterIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type Enumfriendship_statusFieldUpdateOperationsInput = {
    set?: $Enums.friendship_status
  }

  export type userUpdateOneRequiredWithoutFriendship_friendship_addresseeIdTouserNestedInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_addresseeIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_addresseeIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_addresseeIdTouserInput
    upsert?: userUpsertWithoutFriendship_friendship_addresseeIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFriendship_friendship_addresseeIdTouserInput, userUpdateWithoutFriendship_friendship_addresseeIdTouserInput>, userUncheckedUpdateWithoutFriendship_friendship_addresseeIdTouserInput>
  }

  export type userUpdateOneRequiredWithoutFriendship_friendship_requesterIdTouserNestedInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_requesterIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_requesterIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_requesterIdTouserInput
    upsert?: userUpsertWithoutFriendship_friendship_requesterIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFriendship_friendship_requesterIdTouserInput, userUpdateWithoutFriendship_friendship_requesterIdTouserInput>, userUncheckedUpdateWithoutFriendship_friendship_requesterIdTouserInput>
  }

  export type userCreateNestedOneWithoutFrontendactivitylogInput = {
    create?: XOR<userCreateWithoutFrontendactivitylogInput, userUncheckedCreateWithoutFrontendactivitylogInput>
    connectOrCreate?: userCreateOrConnectWithoutFrontendactivitylogInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutFrontendactivitylogNestedInput = {
    create?: XOR<userCreateWithoutFrontendactivitylogInput, userUncheckedCreateWithoutFrontendactivitylogInput>
    connectOrCreate?: userCreateOrConnectWithoutFrontendactivitylogInput
    upsert?: userUpsertWithoutFrontendactivitylogInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFrontendactivitylogInput, userUpdateWithoutFrontendactivitylogInput>, userUncheckedUpdateWithoutFrontendactivitylogInput>
  }

  export type fellowshiprosteritemCreateNestedOneWithoutGeneratedscheduleitemInput = {
    create?: XOR<fellowshiprosteritemCreateWithoutGeneratedscheduleitemInput, fellowshiprosteritemUncheckedCreateWithoutGeneratedscheduleitemInput>
    connectOrCreate?: fellowshiprosteritemCreateOrConnectWithoutGeneratedscheduleitemInput
    connect?: fellowshiprosteritemWhereUniqueInput
  }

  export type responsibilityCreateNestedManyWithoutGeneratedscheduleitemInput = {
    create?: XOR<responsibilityCreateWithoutGeneratedscheduleitemInput, responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput> | responsibilityCreateWithoutGeneratedscheduleitemInput[] | responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput | responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput[]
    createMany?: responsibilityCreateManyGeneratedscheduleitemInputEnvelope
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
  }

  export type responsibilityUncheckedCreateNestedManyWithoutGeneratedscheduleitemInput = {
    create?: XOR<responsibilityCreateWithoutGeneratedscheduleitemInput, responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput> | responsibilityCreateWithoutGeneratedscheduleitemInput[] | responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput | responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput[]
    createMany?: responsibilityCreateManyGeneratedscheduleitemInputEnvelope
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
  }

  export type Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput = {
    set?: $Enums.generatedscheduleitem_rosterType
  }

  export type fellowshiprosteritemUpdateOneWithoutGeneratedscheduleitemNestedInput = {
    create?: XOR<fellowshiprosteritemCreateWithoutGeneratedscheduleitemInput, fellowshiprosteritemUncheckedCreateWithoutGeneratedscheduleitemInput>
    connectOrCreate?: fellowshiprosteritemCreateOrConnectWithoutGeneratedscheduleitemInput
    upsert?: fellowshiprosteritemUpsertWithoutGeneratedscheduleitemInput
    disconnect?: fellowshiprosteritemWhereInput | boolean
    delete?: fellowshiprosteritemWhereInput | boolean
    connect?: fellowshiprosteritemWhereUniqueInput
    update?: XOR<XOR<fellowshiprosteritemUpdateToOneWithWhereWithoutGeneratedscheduleitemInput, fellowshiprosteritemUpdateWithoutGeneratedscheduleitemInput>, fellowshiprosteritemUncheckedUpdateWithoutGeneratedscheduleitemInput>
  }

  export type responsibilityUpdateManyWithoutGeneratedscheduleitemNestedInput = {
    create?: XOR<responsibilityCreateWithoutGeneratedscheduleitemInput, responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput> | responsibilityCreateWithoutGeneratedscheduleitemInput[] | responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput | responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput[]
    upsert?: responsibilityUpsertWithWhereUniqueWithoutGeneratedscheduleitemInput | responsibilityUpsertWithWhereUniqueWithoutGeneratedscheduleitemInput[]
    createMany?: responsibilityCreateManyGeneratedscheduleitemInputEnvelope
    set?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    disconnect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    delete?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    update?: responsibilityUpdateWithWhereUniqueWithoutGeneratedscheduleitemInput | responsibilityUpdateWithWhereUniqueWithoutGeneratedscheduleitemInput[]
    updateMany?: responsibilityUpdateManyWithWhereWithoutGeneratedscheduleitemInput | responsibilityUpdateManyWithWhereWithoutGeneratedscheduleitemInput[]
    deleteMany?: responsibilityScalarWhereInput | responsibilityScalarWhereInput[]
  }

  export type responsibilityUncheckedUpdateManyWithoutGeneratedscheduleitemNestedInput = {
    create?: XOR<responsibilityCreateWithoutGeneratedscheduleitemInput, responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput> | responsibilityCreateWithoutGeneratedscheduleitemInput[] | responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput[]
    connectOrCreate?: responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput | responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput[]
    upsert?: responsibilityUpsertWithWhereUniqueWithoutGeneratedscheduleitemInput | responsibilityUpsertWithWhereUniqueWithoutGeneratedscheduleitemInput[]
    createMany?: responsibilityCreateManyGeneratedscheduleitemInputEnvelope
    set?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    disconnect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    delete?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    connect?: responsibilityWhereUniqueInput | responsibilityWhereUniqueInput[]
    update?: responsibilityUpdateWithWhereUniqueWithoutGeneratedscheduleitemInput | responsibilityUpdateWithWhereUniqueWithoutGeneratedscheduleitemInput[]
    updateMany?: responsibilityUpdateManyWithWhereWithoutGeneratedscheduleitemInput | responsibilityUpdateManyWithWhereWithoutGeneratedscheduleitemInput[]
    deleteMany?: responsibilityScalarWhereInput | responsibilityScalarWhereInput[]
  }

  export type groupmemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<groupmemberCreateWithoutGroupInput, groupmemberUncheckedCreateWithoutGroupInput> | groupmemberCreateWithoutGroupInput[] | groupmemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutGroupInput | groupmemberCreateOrConnectWithoutGroupInput[]
    createMany?: groupmemberCreateManyGroupInputEnvelope
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
  }

  export type groupmessageCreateNestedManyWithoutGroupInput = {
    create?: XOR<groupmessageCreateWithoutGroupInput, groupmessageUncheckedCreateWithoutGroupInput> | groupmessageCreateWithoutGroupInput[] | groupmessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutGroupInput | groupmessageCreateOrConnectWithoutGroupInput[]
    createMany?: groupmessageCreateManyGroupInputEnvelope
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
  }

  export type groupmemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<groupmemberCreateWithoutGroupInput, groupmemberUncheckedCreateWithoutGroupInput> | groupmemberCreateWithoutGroupInput[] | groupmemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutGroupInput | groupmemberCreateOrConnectWithoutGroupInput[]
    createMany?: groupmemberCreateManyGroupInputEnvelope
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
  }

  export type groupmessageUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<groupmessageCreateWithoutGroupInput, groupmessageUncheckedCreateWithoutGroupInput> | groupmessageCreateWithoutGroupInput[] | groupmessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutGroupInput | groupmessageCreateOrConnectWithoutGroupInput[]
    createMany?: groupmessageCreateManyGroupInputEnvelope
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
  }

  export type Enumgroup_editSettingsFieldUpdateOperationsInput = {
    set?: $Enums.group_editSettings
  }

  export type Enumgroup_sendMessageFieldUpdateOperationsInput = {
    set?: $Enums.group_sendMessage
  }

  export type Enumgroup_addMembersFieldUpdateOperationsInput = {
    set?: $Enums.group_addMembers
  }

  export type Enumgroup_approveMembersFieldUpdateOperationsInput = {
    set?: $Enums.group_approveMembers
  }

  export type groupmemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<groupmemberCreateWithoutGroupInput, groupmemberUncheckedCreateWithoutGroupInput> | groupmemberCreateWithoutGroupInput[] | groupmemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutGroupInput | groupmemberCreateOrConnectWithoutGroupInput[]
    upsert?: groupmemberUpsertWithWhereUniqueWithoutGroupInput | groupmemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: groupmemberCreateManyGroupInputEnvelope
    set?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    disconnect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    delete?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    update?: groupmemberUpdateWithWhereUniqueWithoutGroupInput | groupmemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: groupmemberUpdateManyWithWhereWithoutGroupInput | groupmemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: groupmemberScalarWhereInput | groupmemberScalarWhereInput[]
  }

  export type groupmessageUpdateManyWithoutGroupNestedInput = {
    create?: XOR<groupmessageCreateWithoutGroupInput, groupmessageUncheckedCreateWithoutGroupInput> | groupmessageCreateWithoutGroupInput[] | groupmessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutGroupInput | groupmessageCreateOrConnectWithoutGroupInput[]
    upsert?: groupmessageUpsertWithWhereUniqueWithoutGroupInput | groupmessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: groupmessageCreateManyGroupInputEnvelope
    set?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    disconnect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    delete?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    update?: groupmessageUpdateWithWhereUniqueWithoutGroupInput | groupmessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: groupmessageUpdateManyWithWhereWithoutGroupInput | groupmessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: groupmessageScalarWhereInput | groupmessageScalarWhereInput[]
  }

  export type groupmemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<groupmemberCreateWithoutGroupInput, groupmemberUncheckedCreateWithoutGroupInput> | groupmemberCreateWithoutGroupInput[] | groupmemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutGroupInput | groupmemberCreateOrConnectWithoutGroupInput[]
    upsert?: groupmemberUpsertWithWhereUniqueWithoutGroupInput | groupmemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: groupmemberCreateManyGroupInputEnvelope
    set?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    disconnect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    delete?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    update?: groupmemberUpdateWithWhereUniqueWithoutGroupInput | groupmemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: groupmemberUpdateManyWithWhereWithoutGroupInput | groupmemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: groupmemberScalarWhereInput | groupmemberScalarWhereInput[]
  }

  export type groupmessageUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<groupmessageCreateWithoutGroupInput, groupmessageUncheckedCreateWithoutGroupInput> | groupmessageCreateWithoutGroupInput[] | groupmessageUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutGroupInput | groupmessageCreateOrConnectWithoutGroupInput[]
    upsert?: groupmessageUpsertWithWhereUniqueWithoutGroupInput | groupmessageUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: groupmessageCreateManyGroupInputEnvelope
    set?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    disconnect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    delete?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    update?: groupmessageUpdateWithWhereUniqueWithoutGroupInput | groupmessageUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: groupmessageUpdateManyWithWhereWithoutGroupInput | groupmessageUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: groupmessageScalarWhereInput | groupmessageScalarWhereInput[]
  }

  export type groupCreateNestedOneWithoutGroupmemberInput = {
    create?: XOR<groupCreateWithoutGroupmemberInput, groupUncheckedCreateWithoutGroupmemberInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroupmemberInput
    connect?: groupWhereUniqueInput
  }

  export type userCreateNestedOneWithoutGroupmemberInput = {
    create?: XOR<userCreateWithoutGroupmemberInput, userUncheckedCreateWithoutGroupmemberInput>
    connectOrCreate?: userCreateOrConnectWithoutGroupmemberInput
    connect?: userWhereUniqueInput
  }

  export type Enumgroupmember_roleFieldUpdateOperationsInput = {
    set?: $Enums.groupmember_role
  }

  export type groupUpdateOneRequiredWithoutGroupmemberNestedInput = {
    create?: XOR<groupCreateWithoutGroupmemberInput, groupUncheckedCreateWithoutGroupmemberInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroupmemberInput
    upsert?: groupUpsertWithoutGroupmemberInput
    connect?: groupWhereUniqueInput
    update?: XOR<XOR<groupUpdateToOneWithWhereWithoutGroupmemberInput, groupUpdateWithoutGroupmemberInput>, groupUncheckedUpdateWithoutGroupmemberInput>
  }

  export type userUpdateOneRequiredWithoutGroupmemberNestedInput = {
    create?: XOR<userCreateWithoutGroupmemberInput, userUncheckedCreateWithoutGroupmemberInput>
    connectOrCreate?: userCreateOrConnectWithoutGroupmemberInput
    upsert?: userUpsertWithoutGroupmemberInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGroupmemberInput, userUpdateWithoutGroupmemberInput>, userUncheckedUpdateWithoutGroupmemberInput>
  }

  export type groupCreateNestedOneWithoutGroupmessageInput = {
    create?: XOR<groupCreateWithoutGroupmessageInput, groupUncheckedCreateWithoutGroupmessageInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroupmessageInput
    connect?: groupWhereUniqueInput
  }

  export type userCreateNestedOneWithoutGroupmessageInput = {
    create?: XOR<userCreateWithoutGroupmessageInput, userUncheckedCreateWithoutGroupmessageInput>
    connectOrCreate?: userCreateOrConnectWithoutGroupmessageInput
    connect?: userWhereUniqueInput
  }

  export type NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.groupmessage_mediaType | null
  }

  export type groupUpdateOneRequiredWithoutGroupmessageNestedInput = {
    create?: XOR<groupCreateWithoutGroupmessageInput, groupUncheckedCreateWithoutGroupmessageInput>
    connectOrCreate?: groupCreateOrConnectWithoutGroupmessageInput
    upsert?: groupUpsertWithoutGroupmessageInput
    connect?: groupWhereUniqueInput
    update?: XOR<XOR<groupUpdateToOneWithWhereWithoutGroupmessageInput, groupUpdateWithoutGroupmessageInput>, groupUncheckedUpdateWithoutGroupmessageInput>
  }

  export type userUpdateOneRequiredWithoutGroupmessageNestedInput = {
    create?: XOR<userCreateWithoutGroupmessageInput, userUncheckedCreateWithoutGroupmessageInput>
    connectOrCreate?: userCreateOrConnectWithoutGroupmessageInput
    upsert?: userUpsertWithoutGroupmessageInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGroupmessageInput, userUpdateWithoutGroupmessageInput>, userUncheckedUpdateWithoutGroupmessageInput>
  }

  export type commentCreateNestedManyWithoutHistorychapterInput = {
    create?: XOR<commentCreateWithoutHistorychapterInput, commentUncheckedCreateWithoutHistorychapterInput> | commentCreateWithoutHistorychapterInput[] | commentUncheckedCreateWithoutHistorychapterInput[]
    connectOrCreate?: commentCreateOrConnectWithoutHistorychapterInput | commentCreateOrConnectWithoutHistorychapterInput[]
    createMany?: commentCreateManyHistorychapterInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type commentUncheckedCreateNestedManyWithoutHistorychapterInput = {
    create?: XOR<commentCreateWithoutHistorychapterInput, commentUncheckedCreateWithoutHistorychapterInput> | commentCreateWithoutHistorychapterInput[] | commentUncheckedCreateWithoutHistorychapterInput[]
    connectOrCreate?: commentCreateOrConnectWithoutHistorychapterInput | commentCreateOrConnectWithoutHistorychapterInput[]
    createMany?: commentCreateManyHistorychapterInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type Enumhistorychapter_statusFieldUpdateOperationsInput = {
    set?: $Enums.historychapter_status
  }

  export type commentUpdateManyWithoutHistorychapterNestedInput = {
    create?: XOR<commentCreateWithoutHistorychapterInput, commentUncheckedCreateWithoutHistorychapterInput> | commentCreateWithoutHistorychapterInput[] | commentUncheckedCreateWithoutHistorychapterInput[]
    connectOrCreate?: commentCreateOrConnectWithoutHistorychapterInput | commentCreateOrConnectWithoutHistorychapterInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutHistorychapterInput | commentUpsertWithWhereUniqueWithoutHistorychapterInput[]
    createMany?: commentCreateManyHistorychapterInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutHistorychapterInput | commentUpdateWithWhereUniqueWithoutHistorychapterInput[]
    updateMany?: commentUpdateManyWithWhereWithoutHistorychapterInput | commentUpdateManyWithWhereWithoutHistorychapterInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type commentUncheckedUpdateManyWithoutHistorychapterNestedInput = {
    create?: XOR<commentCreateWithoutHistorychapterInput, commentUncheckedCreateWithoutHistorychapterInput> | commentCreateWithoutHistorychapterInput[] | commentUncheckedCreateWithoutHistorychapterInput[]
    connectOrCreate?: commentCreateOrConnectWithoutHistorychapterInput | commentCreateOrConnectWithoutHistorychapterInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutHistorychapterInput | commentUpsertWithWhereUniqueWithoutHistorychapterInput[]
    createMany?: commentCreateManyHistorychapterInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutHistorychapterInput | commentUpdateWithWhereUniqueWithoutHistorychapterInput[]
    updateMany?: commentUpdateManyWithWhereWithoutHistorychapterInput | commentUpdateManyWithWhereWithoutHistorychapterInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type meetinglogCreateNestedOneWithoutMeetingdecisionpointInput = {
    create?: XOR<meetinglogCreateWithoutMeetingdecisionpointInput, meetinglogUncheckedCreateWithoutMeetingdecisionpointInput>
    connectOrCreate?: meetinglogCreateOrConnectWithoutMeetingdecisionpointInput
    connect?: meetinglogWhereUniqueInput
  }

  export type Enummeetingdecisionpoint_statusFieldUpdateOperationsInput = {
    set?: $Enums.meetingdecisionpoint_status
  }

  export type meetinglogUpdateOneRequiredWithoutMeetingdecisionpointNestedInput = {
    create?: XOR<meetinglogCreateWithoutMeetingdecisionpointInput, meetinglogUncheckedCreateWithoutMeetingdecisionpointInput>
    connectOrCreate?: meetinglogCreateOrConnectWithoutMeetingdecisionpointInput
    upsert?: meetinglogUpsertWithoutMeetingdecisionpointInput
    connect?: meetinglogWhereUniqueInput
    update?: XOR<XOR<meetinglogUpdateToOneWithWhereWithoutMeetingdecisionpointInput, meetinglogUpdateWithoutMeetingdecisionpointInput>, meetinglogUncheckedUpdateWithoutMeetingdecisionpointInput>
  }

  export type meetingdecisionpointCreateNestedManyWithoutMeetinglogInput = {
    create?: XOR<meetingdecisionpointCreateWithoutMeetinglogInput, meetingdecisionpointUncheckedCreateWithoutMeetinglogInput> | meetingdecisionpointCreateWithoutMeetinglogInput[] | meetingdecisionpointUncheckedCreateWithoutMeetinglogInput[]
    connectOrCreate?: meetingdecisionpointCreateOrConnectWithoutMeetinglogInput | meetingdecisionpointCreateOrConnectWithoutMeetinglogInput[]
    createMany?: meetingdecisionpointCreateManyMeetinglogInputEnvelope
    connect?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
  }

  export type meetingdecisionpointUncheckedCreateNestedManyWithoutMeetinglogInput = {
    create?: XOR<meetingdecisionpointCreateWithoutMeetinglogInput, meetingdecisionpointUncheckedCreateWithoutMeetinglogInput> | meetingdecisionpointCreateWithoutMeetinglogInput[] | meetingdecisionpointUncheckedCreateWithoutMeetinglogInput[]
    connectOrCreate?: meetingdecisionpointCreateOrConnectWithoutMeetinglogInput | meetingdecisionpointCreateOrConnectWithoutMeetinglogInput[]
    createMany?: meetingdecisionpointCreateManyMeetinglogInputEnvelope
    connect?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
  }

  export type NullableEnummeetinglog_meetingTypeFieldUpdateOperationsInput = {
    set?: $Enums.meetinglog_meetingType | null
  }

  export type NullableEnummeetinglog_statusFieldUpdateOperationsInput = {
    set?: $Enums.meetinglog_status | null
  }

  export type meetingdecisionpointUpdateManyWithoutMeetinglogNestedInput = {
    create?: XOR<meetingdecisionpointCreateWithoutMeetinglogInput, meetingdecisionpointUncheckedCreateWithoutMeetinglogInput> | meetingdecisionpointCreateWithoutMeetinglogInput[] | meetingdecisionpointUncheckedCreateWithoutMeetinglogInput[]
    connectOrCreate?: meetingdecisionpointCreateOrConnectWithoutMeetinglogInput | meetingdecisionpointCreateOrConnectWithoutMeetinglogInput[]
    upsert?: meetingdecisionpointUpsertWithWhereUniqueWithoutMeetinglogInput | meetingdecisionpointUpsertWithWhereUniqueWithoutMeetinglogInput[]
    createMany?: meetingdecisionpointCreateManyMeetinglogInputEnvelope
    set?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    disconnect?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    delete?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    connect?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    update?: meetingdecisionpointUpdateWithWhereUniqueWithoutMeetinglogInput | meetingdecisionpointUpdateWithWhereUniqueWithoutMeetinglogInput[]
    updateMany?: meetingdecisionpointUpdateManyWithWhereWithoutMeetinglogInput | meetingdecisionpointUpdateManyWithWhereWithoutMeetinglogInput[]
    deleteMany?: meetingdecisionpointScalarWhereInput | meetingdecisionpointScalarWhereInput[]
  }

  export type meetingdecisionpointUncheckedUpdateManyWithoutMeetinglogNestedInput = {
    create?: XOR<meetingdecisionpointCreateWithoutMeetinglogInput, meetingdecisionpointUncheckedCreateWithoutMeetinglogInput> | meetingdecisionpointCreateWithoutMeetinglogInput[] | meetingdecisionpointUncheckedCreateWithoutMeetinglogInput[]
    connectOrCreate?: meetingdecisionpointCreateOrConnectWithoutMeetinglogInput | meetingdecisionpointCreateOrConnectWithoutMeetinglogInput[]
    upsert?: meetingdecisionpointUpsertWithWhereUniqueWithoutMeetinglogInput | meetingdecisionpointUpsertWithWhereUniqueWithoutMeetinglogInput[]
    createMany?: meetingdecisionpointCreateManyMeetinglogInputEnvelope
    set?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    disconnect?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    delete?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    connect?: meetingdecisionpointWhereUniqueInput | meetingdecisionpointWhereUniqueInput[]
    update?: meetingdecisionpointUpdateWithWhereUniqueWithoutMeetinglogInput | meetingdecisionpointUpdateWithWhereUniqueWithoutMeetinglogInput[]
    updateMany?: meetingdecisionpointUpdateManyWithWhereWithoutMeetinglogInput | meetingdecisionpointUpdateManyWithWhereWithoutMeetinglogInput[]
    deleteMany?: meetingdecisionpointScalarWhereInput | meetingdecisionpointScalarWhereInput[]
  }

  export type ministryjoinrequestCreateNestedManyWithoutMinistryInput = {
    create?: XOR<ministryjoinrequestCreateWithoutMinistryInput, ministryjoinrequestUncheckedCreateWithoutMinistryInput> | ministryjoinrequestCreateWithoutMinistryInput[] | ministryjoinrequestUncheckedCreateWithoutMinistryInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutMinistryInput | ministryjoinrequestCreateOrConnectWithoutMinistryInput[]
    createMany?: ministryjoinrequestCreateManyMinistryInputEnvelope
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
  }

  export type ministryjoinrequestUncheckedCreateNestedManyWithoutMinistryInput = {
    create?: XOR<ministryjoinrequestCreateWithoutMinistryInput, ministryjoinrequestUncheckedCreateWithoutMinistryInput> | ministryjoinrequestCreateWithoutMinistryInput[] | ministryjoinrequestUncheckedCreateWithoutMinistryInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutMinistryInput | ministryjoinrequestCreateOrConnectWithoutMinistryInput[]
    createMany?: ministryjoinrequestCreateManyMinistryInputEnvelope
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
  }

  export type NullableEnumministry_categoryFieldUpdateOperationsInput = {
    set?: $Enums.ministry_category | null
  }

  export type ministryjoinrequestUpdateManyWithoutMinistryNestedInput = {
    create?: XOR<ministryjoinrequestCreateWithoutMinistryInput, ministryjoinrequestUncheckedCreateWithoutMinistryInput> | ministryjoinrequestCreateWithoutMinistryInput[] | ministryjoinrequestUncheckedCreateWithoutMinistryInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutMinistryInput | ministryjoinrequestCreateOrConnectWithoutMinistryInput[]
    upsert?: ministryjoinrequestUpsertWithWhereUniqueWithoutMinistryInput | ministryjoinrequestUpsertWithWhereUniqueWithoutMinistryInput[]
    createMany?: ministryjoinrequestCreateManyMinistryInputEnvelope
    set?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    disconnect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    delete?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    update?: ministryjoinrequestUpdateWithWhereUniqueWithoutMinistryInput | ministryjoinrequestUpdateWithWhereUniqueWithoutMinistryInput[]
    updateMany?: ministryjoinrequestUpdateManyWithWhereWithoutMinistryInput | ministryjoinrequestUpdateManyWithWhereWithoutMinistryInput[]
    deleteMany?: ministryjoinrequestScalarWhereInput | ministryjoinrequestScalarWhereInput[]
  }

  export type ministryjoinrequestUncheckedUpdateManyWithoutMinistryNestedInput = {
    create?: XOR<ministryjoinrequestCreateWithoutMinistryInput, ministryjoinrequestUncheckedCreateWithoutMinistryInput> | ministryjoinrequestCreateWithoutMinistryInput[] | ministryjoinrequestUncheckedCreateWithoutMinistryInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutMinistryInput | ministryjoinrequestCreateOrConnectWithoutMinistryInput[]
    upsert?: ministryjoinrequestUpsertWithWhereUniqueWithoutMinistryInput | ministryjoinrequestUpsertWithWhereUniqueWithoutMinistryInput[]
    createMany?: ministryjoinrequestCreateManyMinistryInputEnvelope
    set?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    disconnect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    delete?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    update?: ministryjoinrequestUpdateWithWhereUniqueWithoutMinistryInput | ministryjoinrequestUpdateWithWhereUniqueWithoutMinistryInput[]
    updateMany?: ministryjoinrequestUpdateManyWithWhereWithoutMinistryInput | ministryjoinrequestUpdateManyWithWhereWithoutMinistryInput[]
    deleteMany?: ministryjoinrequestScalarWhereInput | ministryjoinrequestScalarWhereInput[]
  }

  export type ministryCreateNestedOneWithoutMinistryjoinrequestInput = {
    create?: XOR<ministryCreateWithoutMinistryjoinrequestInput, ministryUncheckedCreateWithoutMinistryjoinrequestInput>
    connectOrCreate?: ministryCreateOrConnectWithoutMinistryjoinrequestInput
    connect?: ministryWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMinistryjoinrequestInput = {
    create?: XOR<userCreateWithoutMinistryjoinrequestInput, userUncheckedCreateWithoutMinistryjoinrequestInput>
    connectOrCreate?: userCreateOrConnectWithoutMinistryjoinrequestInput
    connect?: userWhereUniqueInput
  }

  export type Enumministryjoinrequest_statusFieldUpdateOperationsInput = {
    set?: $Enums.ministryjoinrequest_status
  }

  export type ministryUpdateOneRequiredWithoutMinistryjoinrequestNestedInput = {
    create?: XOR<ministryCreateWithoutMinistryjoinrequestInput, ministryUncheckedCreateWithoutMinistryjoinrequestInput>
    connectOrCreate?: ministryCreateOrConnectWithoutMinistryjoinrequestInput
    upsert?: ministryUpsertWithoutMinistryjoinrequestInput
    connect?: ministryWhereUniqueInput
    update?: XOR<XOR<ministryUpdateToOneWithWhereWithoutMinistryjoinrequestInput, ministryUpdateWithoutMinistryjoinrequestInput>, ministryUncheckedUpdateWithoutMinistryjoinrequestInput>
  }

  export type userUpdateOneRequiredWithoutMinistryjoinrequestNestedInput = {
    create?: XOR<userCreateWithoutMinistryjoinrequestInput, userUncheckedCreateWithoutMinistryjoinrequestInput>
    connectOrCreate?: userCreateOrConnectWithoutMinistryjoinrequestInput
    upsert?: userUpsertWithoutMinistryjoinrequestInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMinistryjoinrequestInput, userUpdateWithoutMinistryjoinrequestInput>, userUncheckedUpdateWithoutMinistryjoinrequestInput>
  }

  export type commentCreateNestedManyWithoutNewsitemInput = {
    create?: XOR<commentCreateWithoutNewsitemInput, commentUncheckedCreateWithoutNewsitemInput> | commentCreateWithoutNewsitemInput[] | commentUncheckedCreateWithoutNewsitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutNewsitemInput | commentCreateOrConnectWithoutNewsitemInput[]
    createMany?: commentCreateManyNewsitemInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type commentUncheckedCreateNestedManyWithoutNewsitemInput = {
    create?: XOR<commentCreateWithoutNewsitemInput, commentUncheckedCreateWithoutNewsitemInput> | commentCreateWithoutNewsitemInput[] | commentUncheckedCreateWithoutNewsitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutNewsitemInput | commentCreateOrConnectWithoutNewsitemInput[]
    createMany?: commentCreateManyNewsitemInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type NullableEnumnewsitem_categoryFieldUpdateOperationsInput = {
    set?: $Enums.newsitem_category | null
  }

  export type commentUpdateManyWithoutNewsitemNestedInput = {
    create?: XOR<commentCreateWithoutNewsitemInput, commentUncheckedCreateWithoutNewsitemInput> | commentCreateWithoutNewsitemInput[] | commentUncheckedCreateWithoutNewsitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutNewsitemInput | commentCreateOrConnectWithoutNewsitemInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutNewsitemInput | commentUpsertWithWhereUniqueWithoutNewsitemInput[]
    createMany?: commentCreateManyNewsitemInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutNewsitemInput | commentUpdateWithWhereUniqueWithoutNewsitemInput[]
    updateMany?: commentUpdateManyWithWhereWithoutNewsitemInput | commentUpdateManyWithWhereWithoutNewsitemInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type commentUncheckedUpdateManyWithoutNewsitemNestedInput = {
    create?: XOR<commentCreateWithoutNewsitemInput, commentUncheckedCreateWithoutNewsitemInput> | commentCreateWithoutNewsitemInput[] | commentUncheckedCreateWithoutNewsitemInput[]
    connectOrCreate?: commentCreateOrConnectWithoutNewsitemInput | commentCreateOrConnectWithoutNewsitemInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutNewsitemInput | commentUpsertWithWhereUniqueWithoutNewsitemInput[]
    createMany?: commentCreateManyNewsitemInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutNewsitemInput | commentUpdateWithWhereUniqueWithoutNewsitemInput[]
    updateMany?: commentUpdateManyWithWhereWithoutNewsitemInput | commentUpdateManyWithWhereWithoutNewsitemInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutNotificationInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    connect?: userWhereUniqueInput
  }

  export type Enumnotification_typeFieldUpdateOperationsInput = {
    set?: $Enums.notification_type
  }

  export type userUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    upsert?: userUpsertWithoutNotificationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotificationInput, userUpdateWithoutNotificationInput>, userUncheckedUpdateWithoutNotificationInput>
  }

  export type prayerrequestCreateNestedOneWithoutPrayerInput = {
    create?: XOR<prayerrequestCreateWithoutPrayerInput, prayerrequestUncheckedCreateWithoutPrayerInput>
    connectOrCreate?: prayerrequestCreateOrConnectWithoutPrayerInput
    connect?: prayerrequestWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPrayerInput = {
    create?: XOR<userCreateWithoutPrayerInput, userUncheckedCreateWithoutPrayerInput>
    connectOrCreate?: userCreateOrConnectWithoutPrayerInput
    connect?: userWhereUniqueInput
  }

  export type prayerrequestUpdateOneRequiredWithoutPrayerNestedInput = {
    create?: XOR<prayerrequestCreateWithoutPrayerInput, prayerrequestUncheckedCreateWithoutPrayerInput>
    connectOrCreate?: prayerrequestCreateOrConnectWithoutPrayerInput
    upsert?: prayerrequestUpsertWithoutPrayerInput
    connect?: prayerrequestWhereUniqueInput
    update?: XOR<XOR<prayerrequestUpdateToOneWithWhereWithoutPrayerInput, prayerrequestUpdateWithoutPrayerInput>, prayerrequestUncheckedUpdateWithoutPrayerInput>
  }

  export type userUpdateOneRequiredWithoutPrayerNestedInput = {
    create?: XOR<userCreateWithoutPrayerInput, userUncheckedCreateWithoutPrayerInput>
    connectOrCreate?: userCreateOrConnectWithoutPrayerInput
    upsert?: userUpsertWithoutPrayerInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPrayerInput, userUpdateWithoutPrayerInput>, userUncheckedUpdateWithoutPrayerInput>
  }

  export type commentCreateNestedManyWithoutPrayerrequestInput = {
    create?: XOR<commentCreateWithoutPrayerrequestInput, commentUncheckedCreateWithoutPrayerrequestInput> | commentCreateWithoutPrayerrequestInput[] | commentUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPrayerrequestInput | commentCreateOrConnectWithoutPrayerrequestInput[]
    createMany?: commentCreateManyPrayerrequestInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type prayerCreateNestedManyWithoutPrayerrequestInput = {
    create?: XOR<prayerCreateWithoutPrayerrequestInput, prayerUncheckedCreateWithoutPrayerrequestInput> | prayerCreateWithoutPrayerrequestInput[] | prayerUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutPrayerrequestInput | prayerCreateOrConnectWithoutPrayerrequestInput[]
    createMany?: prayerCreateManyPrayerrequestInputEnvelope
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutPrayerrequestInput = {
    create?: XOR<userCreateWithoutPrayerrequestInput, userUncheckedCreateWithoutPrayerrequestInput>
    connectOrCreate?: userCreateOrConnectWithoutPrayerrequestInput
    connect?: userWhereUniqueInput
  }

  export type commentUncheckedCreateNestedManyWithoutPrayerrequestInput = {
    create?: XOR<commentCreateWithoutPrayerrequestInput, commentUncheckedCreateWithoutPrayerrequestInput> | commentCreateWithoutPrayerrequestInput[] | commentUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPrayerrequestInput | commentCreateOrConnectWithoutPrayerrequestInput[]
    createMany?: commentCreateManyPrayerrequestInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type prayerUncheckedCreateNestedManyWithoutPrayerrequestInput = {
    create?: XOR<prayerCreateWithoutPrayerrequestInput, prayerUncheckedCreateWithoutPrayerrequestInput> | prayerCreateWithoutPrayerrequestInput[] | prayerUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutPrayerrequestInput | prayerCreateOrConnectWithoutPrayerrequestInput[]
    createMany?: prayerCreateManyPrayerrequestInputEnvelope
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
  }

  export type Enumprayerrequest_visibilityFieldUpdateOperationsInput = {
    set?: $Enums.prayerrequest_visibility
  }

  export type NullableEnumprayerrequest_categoryFieldUpdateOperationsInput = {
    set?: $Enums.prayerrequest_category | null
  }

  export type Enumprayerrequest_statusFieldUpdateOperationsInput = {
    set?: $Enums.prayerrequest_status
  }

  export type commentUpdateManyWithoutPrayerrequestNestedInput = {
    create?: XOR<commentCreateWithoutPrayerrequestInput, commentUncheckedCreateWithoutPrayerrequestInput> | commentCreateWithoutPrayerrequestInput[] | commentUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPrayerrequestInput | commentCreateOrConnectWithoutPrayerrequestInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutPrayerrequestInput | commentUpsertWithWhereUniqueWithoutPrayerrequestInput[]
    createMany?: commentCreateManyPrayerrequestInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutPrayerrequestInput | commentUpdateWithWhereUniqueWithoutPrayerrequestInput[]
    updateMany?: commentUpdateManyWithWhereWithoutPrayerrequestInput | commentUpdateManyWithWhereWithoutPrayerrequestInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type prayerUpdateManyWithoutPrayerrequestNestedInput = {
    create?: XOR<prayerCreateWithoutPrayerrequestInput, prayerUncheckedCreateWithoutPrayerrequestInput> | prayerCreateWithoutPrayerrequestInput[] | prayerUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutPrayerrequestInput | prayerCreateOrConnectWithoutPrayerrequestInput[]
    upsert?: prayerUpsertWithWhereUniqueWithoutPrayerrequestInput | prayerUpsertWithWhereUniqueWithoutPrayerrequestInput[]
    createMany?: prayerCreateManyPrayerrequestInputEnvelope
    set?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    disconnect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    delete?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    update?: prayerUpdateWithWhereUniqueWithoutPrayerrequestInput | prayerUpdateWithWhereUniqueWithoutPrayerrequestInput[]
    updateMany?: prayerUpdateManyWithWhereWithoutPrayerrequestInput | prayerUpdateManyWithWhereWithoutPrayerrequestInput[]
    deleteMany?: prayerScalarWhereInput | prayerScalarWhereInput[]
  }

  export type userUpdateOneWithoutPrayerrequestNestedInput = {
    create?: XOR<userCreateWithoutPrayerrequestInput, userUncheckedCreateWithoutPrayerrequestInput>
    connectOrCreate?: userCreateOrConnectWithoutPrayerrequestInput
    upsert?: userUpsertWithoutPrayerrequestInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPrayerrequestInput, userUpdateWithoutPrayerrequestInput>, userUncheckedUpdateWithoutPrayerrequestInput>
  }

  export type commentUncheckedUpdateManyWithoutPrayerrequestNestedInput = {
    create?: XOR<commentCreateWithoutPrayerrequestInput, commentUncheckedCreateWithoutPrayerrequestInput> | commentCreateWithoutPrayerrequestInput[] | commentUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPrayerrequestInput | commentCreateOrConnectWithoutPrayerrequestInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutPrayerrequestInput | commentUpsertWithWhereUniqueWithoutPrayerrequestInput[]
    createMany?: commentCreateManyPrayerrequestInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutPrayerrequestInput | commentUpdateWithWhereUniqueWithoutPrayerrequestInput[]
    updateMany?: commentUpdateManyWithWhereWithoutPrayerrequestInput | commentUpdateManyWithWhereWithoutPrayerrequestInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type prayerUncheckedUpdateManyWithoutPrayerrequestNestedInput = {
    create?: XOR<prayerCreateWithoutPrayerrequestInput, prayerUncheckedCreateWithoutPrayerrequestInput> | prayerCreateWithoutPrayerrequestInput[] | prayerUncheckedCreateWithoutPrayerrequestInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutPrayerrequestInput | prayerCreateOrConnectWithoutPrayerrequestInput[]
    upsert?: prayerUpsertWithWhereUniqueWithoutPrayerrequestInput | prayerUpsertWithWhereUniqueWithoutPrayerrequestInput[]
    createMany?: prayerCreateManyPrayerrequestInputEnvelope
    set?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    disconnect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    delete?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    update?: prayerUpdateWithWhereUniqueWithoutPrayerrequestInput | prayerUpdateWithWhereUniqueWithoutPrayerrequestInput[]
    updateMany?: prayerUpdateManyWithWhereWithoutPrayerrequestInput | prayerUpdateManyWithWhereWithoutPrayerrequestInput[]
    deleteMany?: prayerScalarWhereInput | prayerScalarWhereInput[]
  }

  export type generatedscheduleitemCreateNestedOneWithoutResponsibilityInput = {
    create?: XOR<generatedscheduleitemCreateWithoutResponsibilityInput, generatedscheduleitemUncheckedCreateWithoutResponsibilityInput>
    connectOrCreate?: generatedscheduleitemCreateOrConnectWithoutResponsibilityInput
    connect?: generatedscheduleitemWhereUniqueInput
  }

  export type fellowshiprosteritemCreateNestedOneWithoutResponsibilityInput = {
    create?: XOR<fellowshiprosteritemCreateWithoutResponsibilityInput, fellowshiprosteritemUncheckedCreateWithoutResponsibilityInput>
    connectOrCreate?: fellowshiprosteritemCreateOrConnectWithoutResponsibilityInput
    connect?: fellowshiprosteritemWhereUniqueInput
  }

  export type generatedscheduleitemUpdateOneWithoutResponsibilityNestedInput = {
    create?: XOR<generatedscheduleitemCreateWithoutResponsibilityInput, generatedscheduleitemUncheckedCreateWithoutResponsibilityInput>
    connectOrCreate?: generatedscheduleitemCreateOrConnectWithoutResponsibilityInput
    upsert?: generatedscheduleitemUpsertWithoutResponsibilityInput
    disconnect?: generatedscheduleitemWhereInput | boolean
    delete?: generatedscheduleitemWhereInput | boolean
    connect?: generatedscheduleitemWhereUniqueInput
    update?: XOR<XOR<generatedscheduleitemUpdateToOneWithWhereWithoutResponsibilityInput, generatedscheduleitemUpdateWithoutResponsibilityInput>, generatedscheduleitemUncheckedUpdateWithoutResponsibilityInput>
  }

  export type fellowshiprosteritemUpdateOneWithoutResponsibilityNestedInput = {
    create?: XOR<fellowshiprosteritemCreateWithoutResponsibilityInput, fellowshiprosteritemUncheckedCreateWithoutResponsibilityInput>
    connectOrCreate?: fellowshiprosteritemCreateOrConnectWithoutResponsibilityInput
    upsert?: fellowshiprosteritemUpsertWithoutResponsibilityInput
    disconnect?: fellowshiprosteritemWhereInput | boolean
    delete?: fellowshiprosteritemWhereInput | boolean
    connect?: fellowshiprosteritemWhereUniqueInput
    update?: XOR<XOR<fellowshiprosteritemUpdateToOneWithWhereWithoutResponsibilityInput, fellowshiprosteritemUpdateWithoutResponsibilityInput>, fellowshiprosteritemUncheckedUpdateWithoutResponsibilityInput>
  }

  export type commentCreateNestedManyWithoutSermonInput = {
    create?: XOR<commentCreateWithoutSermonInput, commentUncheckedCreateWithoutSermonInput> | commentCreateWithoutSermonInput[] | commentUncheckedCreateWithoutSermonInput[]
    connectOrCreate?: commentCreateOrConnectWithoutSermonInput | commentCreateOrConnectWithoutSermonInput[]
    createMany?: commentCreateManySermonInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type commentUncheckedCreateNestedManyWithoutSermonInput = {
    create?: XOR<commentCreateWithoutSermonInput, commentUncheckedCreateWithoutSermonInput> | commentCreateWithoutSermonInput[] | commentUncheckedCreateWithoutSermonInput[]
    connectOrCreate?: commentCreateOrConnectWithoutSermonInput | commentCreateOrConnectWithoutSermonInput[]
    createMany?: commentCreateManySermonInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type NullableEnumsermon_categoryFieldUpdateOperationsInput = {
    set?: $Enums.sermon_category | null
  }

  export type commentUpdateManyWithoutSermonNestedInput = {
    create?: XOR<commentCreateWithoutSermonInput, commentUncheckedCreateWithoutSermonInput> | commentCreateWithoutSermonInput[] | commentUncheckedCreateWithoutSermonInput[]
    connectOrCreate?: commentCreateOrConnectWithoutSermonInput | commentCreateOrConnectWithoutSermonInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutSermonInput | commentUpsertWithWhereUniqueWithoutSermonInput[]
    createMany?: commentCreateManySermonInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutSermonInput | commentUpdateWithWhereUniqueWithoutSermonInput[]
    updateMany?: commentUpdateManyWithWhereWithoutSermonInput | commentUpdateManyWithWhereWithoutSermonInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type commentUncheckedUpdateManyWithoutSermonNestedInput = {
    create?: XOR<commentCreateWithoutSermonInput, commentUncheckedCreateWithoutSermonInput> | commentCreateWithoutSermonInput[] | commentUncheckedCreateWithoutSermonInput[]
    connectOrCreate?: commentCreateOrConnectWithoutSermonInput | commentCreateOrConnectWithoutSermonInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutSermonInput | commentUpsertWithWhereUniqueWithoutSermonInput[]
    createMany?: commentCreateManySermonInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutSermonInput | commentUpdateWithWhereUniqueWithoutSermonInput[]
    updateMany?: commentUpdateManyWithWhereWithoutSermonInput | commentUpdateManyWithWhereWithoutSermonInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutTestimonialInput = {
    create?: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
    connectOrCreate?: userCreateOrConnectWithoutTestimonialInput
    connect?: userWhereUniqueInput
  }

  export type Enumtestimonial_visibilityFieldUpdateOperationsInput = {
    set?: $Enums.testimonial_visibility
  }

  export type userUpdateOneRequiredWithoutTestimonialNestedInput = {
    create?: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
    connectOrCreate?: userCreateOrConnectWithoutTestimonialInput
    upsert?: userUpsertWithoutTestimonialInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTestimonialInput, userUpdateWithoutTestimonialInput>, userUncheckedUpdateWithoutTestimonialInput>
  }

  export type adminactionlogCreateNestedManyWithoutUserInput = {
    create?: XOR<adminactionlogCreateWithoutUserInput, adminactionlogUncheckedCreateWithoutUserInput> | adminactionlogCreateWithoutUserInput[] | adminactionlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminactionlogCreateOrConnectWithoutUserInput | adminactionlogCreateOrConnectWithoutUserInput[]
    createMany?: adminactionlogCreateManyUserInputEnvelope
    connect?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
  }

  export type churchmemberCreateNestedOneWithoutUserInput = {
    create?: XOR<churchmemberCreateWithoutUserInput, churchmemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: churchmemberCreateOrConnectWithoutUserInput
    connect?: churchmemberWhereUniqueInput
  }

  export type commentCreateNestedManyWithoutUserInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput> | friendshipCreateWithoutUser_friendship_addresseeIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_addresseeIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput> | friendshipCreateWithoutUser_friendship_requesterIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_requesterIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type frontendactivitylogCreateNestedManyWithoutUserInput = {
    create?: XOR<frontendactivitylogCreateWithoutUserInput, frontendactivitylogUncheckedCreateWithoutUserInput> | frontendactivitylogCreateWithoutUserInput[] | frontendactivitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: frontendactivitylogCreateOrConnectWithoutUserInput | frontendactivitylogCreateOrConnectWithoutUserInput[]
    createMany?: frontendactivitylogCreateManyUserInputEnvelope
    connect?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
  }

  export type groupmemberCreateNestedManyWithoutUserInput = {
    create?: XOR<groupmemberCreateWithoutUserInput, groupmemberUncheckedCreateWithoutUserInput> | groupmemberCreateWithoutUserInput[] | groupmemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutUserInput | groupmemberCreateOrConnectWithoutUserInput[]
    createMany?: groupmemberCreateManyUserInputEnvelope
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
  }

  export type groupmessageCreateNestedManyWithoutUserInput = {
    create?: XOR<groupmessageCreateWithoutUserInput, groupmessageUncheckedCreateWithoutUserInput> | groupmessageCreateWithoutUserInput[] | groupmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutUserInput | groupmessageCreateOrConnectWithoutUserInput[]
    createMany?: groupmessageCreateManyUserInputEnvelope
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
  }

  export type ministryjoinrequestCreateNestedManyWithoutUserInput = {
    create?: XOR<ministryjoinrequestCreateWithoutUserInput, ministryjoinrequestUncheckedCreateWithoutUserInput> | ministryjoinrequestCreateWithoutUserInput[] | ministryjoinrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutUserInput | ministryjoinrequestCreateOrConnectWithoutUserInput[]
    createMany?: ministryjoinrequestCreateManyUserInputEnvelope
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type prayerCreateNestedManyWithoutUserInput = {
    create?: XOR<prayerCreateWithoutUserInput, prayerUncheckedCreateWithoutUserInput> | prayerCreateWithoutUserInput[] | prayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutUserInput | prayerCreateOrConnectWithoutUserInput[]
    createMany?: prayerCreateManyUserInputEnvelope
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
  }

  export type prayerrequestCreateNestedManyWithoutUserInput = {
    create?: XOR<prayerrequestCreateWithoutUserInput, prayerrequestUncheckedCreateWithoutUserInput> | prayerrequestCreateWithoutUserInput[] | prayerrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerrequestCreateOrConnectWithoutUserInput | prayerrequestCreateOrConnectWithoutUserInput[]
    createMany?: prayerrequestCreateManyUserInputEnvelope
    connect?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
  }

  export type testimonialCreateNestedManyWithoutUserInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
  }

  export type adminactionlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<adminactionlogCreateWithoutUserInput, adminactionlogUncheckedCreateWithoutUserInput> | adminactionlogCreateWithoutUserInput[] | adminactionlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminactionlogCreateOrConnectWithoutUserInput | adminactionlogCreateOrConnectWithoutUserInput[]
    createMany?: adminactionlogCreateManyUserInputEnvelope
    connect?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
  }

  export type churchmemberUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<churchmemberCreateWithoutUserInput, churchmemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: churchmemberCreateOrConnectWithoutUserInput
    connect?: churchmemberWhereUniqueInput
  }

  export type commentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput> | friendshipCreateWithoutUser_friendship_addresseeIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_addresseeIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput> | friendshipCreateWithoutUser_friendship_requesterIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_requesterIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type frontendactivitylogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<frontendactivitylogCreateWithoutUserInput, frontendactivitylogUncheckedCreateWithoutUserInput> | frontendactivitylogCreateWithoutUserInput[] | frontendactivitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: frontendactivitylogCreateOrConnectWithoutUserInput | frontendactivitylogCreateOrConnectWithoutUserInput[]
    createMany?: frontendactivitylogCreateManyUserInputEnvelope
    connect?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
  }

  export type groupmemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<groupmemberCreateWithoutUserInput, groupmemberUncheckedCreateWithoutUserInput> | groupmemberCreateWithoutUserInput[] | groupmemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutUserInput | groupmemberCreateOrConnectWithoutUserInput[]
    createMany?: groupmemberCreateManyUserInputEnvelope
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
  }

  export type groupmessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<groupmessageCreateWithoutUserInput, groupmessageUncheckedCreateWithoutUserInput> | groupmessageCreateWithoutUserInput[] | groupmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutUserInput | groupmessageCreateOrConnectWithoutUserInput[]
    createMany?: groupmessageCreateManyUserInputEnvelope
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
  }

  export type ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ministryjoinrequestCreateWithoutUserInput, ministryjoinrequestUncheckedCreateWithoutUserInput> | ministryjoinrequestCreateWithoutUserInput[] | ministryjoinrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutUserInput | ministryjoinrequestCreateOrConnectWithoutUserInput[]
    createMany?: ministryjoinrequestCreateManyUserInputEnvelope
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type prayerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<prayerCreateWithoutUserInput, prayerUncheckedCreateWithoutUserInput> | prayerCreateWithoutUserInput[] | prayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutUserInput | prayerCreateOrConnectWithoutUserInput[]
    createMany?: prayerCreateManyUserInputEnvelope
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
  }

  export type prayerrequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<prayerrequestCreateWithoutUserInput, prayerrequestUncheckedCreateWithoutUserInput> | prayerrequestCreateWithoutUserInput[] | prayerrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerrequestCreateOrConnectWithoutUserInput | prayerrequestCreateOrConnectWithoutUserInput[]
    createMany?: prayerrequestCreateManyUserInputEnvelope
    connect?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
  }

  export type testimonialUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
  }

  export type Enumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role
  }

  export type NullableEnumuser_relationshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.user_relationshipStatus | null
  }

  export type Enumuser_friendsListPrivacyFieldUpdateOperationsInput = {
    set?: $Enums.user_friendsListPrivacy
  }

  export type Enumuser_friendRequestPrivacyFieldUpdateOperationsInput = {
    set?: $Enums.user_friendRequestPrivacy
  }

  export type Enumuser_groupInvitePrivacyFieldUpdateOperationsInput = {
    set?: $Enums.user_groupInvitePrivacy
  }

  export type adminactionlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<adminactionlogCreateWithoutUserInput, adminactionlogUncheckedCreateWithoutUserInput> | adminactionlogCreateWithoutUserInput[] | adminactionlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminactionlogCreateOrConnectWithoutUserInput | adminactionlogCreateOrConnectWithoutUserInput[]
    upsert?: adminactionlogUpsertWithWhereUniqueWithoutUserInput | adminactionlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: adminactionlogCreateManyUserInputEnvelope
    set?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    disconnect?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    delete?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    connect?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    update?: adminactionlogUpdateWithWhereUniqueWithoutUserInput | adminactionlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: adminactionlogUpdateManyWithWhereWithoutUserInput | adminactionlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: adminactionlogScalarWhereInput | adminactionlogScalarWhereInput[]
  }

  export type churchmemberUpdateOneWithoutUserNestedInput = {
    create?: XOR<churchmemberCreateWithoutUserInput, churchmemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: churchmemberCreateOrConnectWithoutUserInput
    upsert?: churchmemberUpsertWithoutUserInput
    disconnect?: churchmemberWhereInput | boolean
    delete?: churchmemberWhereInput | boolean
    connect?: churchmemberWhereUniqueInput
    update?: XOR<XOR<churchmemberUpdateToOneWithWhereWithoutUserInput, churchmemberUpdateWithoutUserInput>, churchmemberUncheckedUpdateWithoutUserInput>
  }

  export type commentUpdateManyWithoutUserNestedInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutUserInput | commentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutUserInput | commentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: commentUpdateManyWithWhereWithoutUserInput | commentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput> | friendshipCreateWithoutUser_friendship_addresseeIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_addresseeIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_addresseeIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_addresseeIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput> | friendshipCreateWithoutUser_friendship_requesterIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_requesterIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_requesterIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_requesterIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type frontendactivitylogUpdateManyWithoutUserNestedInput = {
    create?: XOR<frontendactivitylogCreateWithoutUserInput, frontendactivitylogUncheckedCreateWithoutUserInput> | frontendactivitylogCreateWithoutUserInput[] | frontendactivitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: frontendactivitylogCreateOrConnectWithoutUserInput | frontendactivitylogCreateOrConnectWithoutUserInput[]
    upsert?: frontendactivitylogUpsertWithWhereUniqueWithoutUserInput | frontendactivitylogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: frontendactivitylogCreateManyUserInputEnvelope
    set?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    disconnect?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    delete?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    connect?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    update?: frontendactivitylogUpdateWithWhereUniqueWithoutUserInput | frontendactivitylogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: frontendactivitylogUpdateManyWithWhereWithoutUserInput | frontendactivitylogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: frontendactivitylogScalarWhereInput | frontendactivitylogScalarWhereInput[]
  }

  export type groupmemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<groupmemberCreateWithoutUserInput, groupmemberUncheckedCreateWithoutUserInput> | groupmemberCreateWithoutUserInput[] | groupmemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutUserInput | groupmemberCreateOrConnectWithoutUserInput[]
    upsert?: groupmemberUpsertWithWhereUniqueWithoutUserInput | groupmemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: groupmemberCreateManyUserInputEnvelope
    set?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    disconnect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    delete?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    update?: groupmemberUpdateWithWhereUniqueWithoutUserInput | groupmemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: groupmemberUpdateManyWithWhereWithoutUserInput | groupmemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: groupmemberScalarWhereInput | groupmemberScalarWhereInput[]
  }

  export type groupmessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<groupmessageCreateWithoutUserInput, groupmessageUncheckedCreateWithoutUserInput> | groupmessageCreateWithoutUserInput[] | groupmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutUserInput | groupmessageCreateOrConnectWithoutUserInput[]
    upsert?: groupmessageUpsertWithWhereUniqueWithoutUserInput | groupmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: groupmessageCreateManyUserInputEnvelope
    set?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    disconnect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    delete?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    update?: groupmessageUpdateWithWhereUniqueWithoutUserInput | groupmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: groupmessageUpdateManyWithWhereWithoutUserInput | groupmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: groupmessageScalarWhereInput | groupmessageScalarWhereInput[]
  }

  export type ministryjoinrequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ministryjoinrequestCreateWithoutUserInput, ministryjoinrequestUncheckedCreateWithoutUserInput> | ministryjoinrequestCreateWithoutUserInput[] | ministryjoinrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutUserInput | ministryjoinrequestCreateOrConnectWithoutUserInput[]
    upsert?: ministryjoinrequestUpsertWithWhereUniqueWithoutUserInput | ministryjoinrequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ministryjoinrequestCreateManyUserInputEnvelope
    set?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    disconnect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    delete?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    update?: ministryjoinrequestUpdateWithWhereUniqueWithoutUserInput | ministryjoinrequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ministryjoinrequestUpdateManyWithWhereWithoutUserInput | ministryjoinrequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ministryjoinrequestScalarWhereInput | ministryjoinrequestScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type prayerUpdateManyWithoutUserNestedInput = {
    create?: XOR<prayerCreateWithoutUserInput, prayerUncheckedCreateWithoutUserInput> | prayerCreateWithoutUserInput[] | prayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutUserInput | prayerCreateOrConnectWithoutUserInput[]
    upsert?: prayerUpsertWithWhereUniqueWithoutUserInput | prayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: prayerCreateManyUserInputEnvelope
    set?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    disconnect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    delete?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    update?: prayerUpdateWithWhereUniqueWithoutUserInput | prayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: prayerUpdateManyWithWhereWithoutUserInput | prayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: prayerScalarWhereInput | prayerScalarWhereInput[]
  }

  export type prayerrequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<prayerrequestCreateWithoutUserInput, prayerrequestUncheckedCreateWithoutUserInput> | prayerrequestCreateWithoutUserInput[] | prayerrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerrequestCreateOrConnectWithoutUserInput | prayerrequestCreateOrConnectWithoutUserInput[]
    upsert?: prayerrequestUpsertWithWhereUniqueWithoutUserInput | prayerrequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: prayerrequestCreateManyUserInputEnvelope
    set?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    disconnect?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    delete?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    connect?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    update?: prayerrequestUpdateWithWhereUniqueWithoutUserInput | prayerrequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: prayerrequestUpdateManyWithWhereWithoutUserInput | prayerrequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: prayerrequestScalarWhereInput | prayerrequestScalarWhereInput[]
  }

  export type testimonialUpdateManyWithoutUserNestedInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    upsert?: testimonialUpsertWithWhereUniqueWithoutUserInput | testimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    set?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    disconnect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    delete?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    update?: testimonialUpdateWithWhereUniqueWithoutUserInput | testimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: testimonialUpdateManyWithWhereWithoutUserInput | testimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
  }

  export type adminactionlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<adminactionlogCreateWithoutUserInput, adminactionlogUncheckedCreateWithoutUserInput> | adminactionlogCreateWithoutUserInput[] | adminactionlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: adminactionlogCreateOrConnectWithoutUserInput | adminactionlogCreateOrConnectWithoutUserInput[]
    upsert?: adminactionlogUpsertWithWhereUniqueWithoutUserInput | adminactionlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: adminactionlogCreateManyUserInputEnvelope
    set?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    disconnect?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    delete?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    connect?: adminactionlogWhereUniqueInput | adminactionlogWhereUniqueInput[]
    update?: adminactionlogUpdateWithWhereUniqueWithoutUserInput | adminactionlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: adminactionlogUpdateManyWithWhereWithoutUserInput | adminactionlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: adminactionlogScalarWhereInput | adminactionlogScalarWhereInput[]
  }

  export type churchmemberUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<churchmemberCreateWithoutUserInput, churchmemberUncheckedCreateWithoutUserInput>
    connectOrCreate?: churchmemberCreateOrConnectWithoutUserInput
    upsert?: churchmemberUpsertWithoutUserInput
    disconnect?: churchmemberWhereInput | boolean
    delete?: churchmemberWhereInput | boolean
    connect?: churchmemberWhereUniqueInput
    update?: XOR<XOR<churchmemberUpdateToOneWithWhereWithoutUserInput, churchmemberUpdateWithoutUserInput>, churchmemberUncheckedUpdateWithoutUserInput>
  }

  export type commentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutUserInput | commentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutUserInput | commentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: commentUpdateManyWithWhereWithoutUserInput | commentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput> | friendshipCreateWithoutUser_friendship_addresseeIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_addresseeIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_addresseeIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_addresseeIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput> | friendshipCreateWithoutUser_friendship_requesterIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_requesterIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_requesterIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_requesterIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<frontendactivitylogCreateWithoutUserInput, frontendactivitylogUncheckedCreateWithoutUserInput> | frontendactivitylogCreateWithoutUserInput[] | frontendactivitylogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: frontendactivitylogCreateOrConnectWithoutUserInput | frontendactivitylogCreateOrConnectWithoutUserInput[]
    upsert?: frontendactivitylogUpsertWithWhereUniqueWithoutUserInput | frontendactivitylogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: frontendactivitylogCreateManyUserInputEnvelope
    set?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    disconnect?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    delete?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    connect?: frontendactivitylogWhereUniqueInput | frontendactivitylogWhereUniqueInput[]
    update?: frontendactivitylogUpdateWithWhereUniqueWithoutUserInput | frontendactivitylogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: frontendactivitylogUpdateManyWithWhereWithoutUserInput | frontendactivitylogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: frontendactivitylogScalarWhereInput | frontendactivitylogScalarWhereInput[]
  }

  export type groupmemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<groupmemberCreateWithoutUserInput, groupmemberUncheckedCreateWithoutUserInput> | groupmemberCreateWithoutUserInput[] | groupmemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmemberCreateOrConnectWithoutUserInput | groupmemberCreateOrConnectWithoutUserInput[]
    upsert?: groupmemberUpsertWithWhereUniqueWithoutUserInput | groupmemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: groupmemberCreateManyUserInputEnvelope
    set?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    disconnect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    delete?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    connect?: groupmemberWhereUniqueInput | groupmemberWhereUniqueInput[]
    update?: groupmemberUpdateWithWhereUniqueWithoutUserInput | groupmemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: groupmemberUpdateManyWithWhereWithoutUserInput | groupmemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: groupmemberScalarWhereInput | groupmemberScalarWhereInput[]
  }

  export type groupmessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<groupmessageCreateWithoutUserInput, groupmessageUncheckedCreateWithoutUserInput> | groupmessageCreateWithoutUserInput[] | groupmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: groupmessageCreateOrConnectWithoutUserInput | groupmessageCreateOrConnectWithoutUserInput[]
    upsert?: groupmessageUpsertWithWhereUniqueWithoutUserInput | groupmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: groupmessageCreateManyUserInputEnvelope
    set?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    disconnect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    delete?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    connect?: groupmessageWhereUniqueInput | groupmessageWhereUniqueInput[]
    update?: groupmessageUpdateWithWhereUniqueWithoutUserInput | groupmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: groupmessageUpdateManyWithWhereWithoutUserInput | groupmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: groupmessageScalarWhereInput | groupmessageScalarWhereInput[]
  }

  export type ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ministryjoinrequestCreateWithoutUserInput, ministryjoinrequestUncheckedCreateWithoutUserInput> | ministryjoinrequestCreateWithoutUserInput[] | ministryjoinrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ministryjoinrequestCreateOrConnectWithoutUserInput | ministryjoinrequestCreateOrConnectWithoutUserInput[]
    upsert?: ministryjoinrequestUpsertWithWhereUniqueWithoutUserInput | ministryjoinrequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ministryjoinrequestCreateManyUserInputEnvelope
    set?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    disconnect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    delete?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    connect?: ministryjoinrequestWhereUniqueInput | ministryjoinrequestWhereUniqueInput[]
    update?: ministryjoinrequestUpdateWithWhereUniqueWithoutUserInput | ministryjoinrequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ministryjoinrequestUpdateManyWithWhereWithoutUserInput | ministryjoinrequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ministryjoinrequestScalarWhereInput | ministryjoinrequestScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type prayerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<prayerCreateWithoutUserInput, prayerUncheckedCreateWithoutUserInput> | prayerCreateWithoutUserInput[] | prayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerCreateOrConnectWithoutUserInput | prayerCreateOrConnectWithoutUserInput[]
    upsert?: prayerUpsertWithWhereUniqueWithoutUserInput | prayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: prayerCreateManyUserInputEnvelope
    set?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    disconnect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    delete?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    connect?: prayerWhereUniqueInput | prayerWhereUniqueInput[]
    update?: prayerUpdateWithWhereUniqueWithoutUserInput | prayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: prayerUpdateManyWithWhereWithoutUserInput | prayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: prayerScalarWhereInput | prayerScalarWhereInput[]
  }

  export type prayerrequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<prayerrequestCreateWithoutUserInput, prayerrequestUncheckedCreateWithoutUserInput> | prayerrequestCreateWithoutUserInput[] | prayerrequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: prayerrequestCreateOrConnectWithoutUserInput | prayerrequestCreateOrConnectWithoutUserInput[]
    upsert?: prayerrequestUpsertWithWhereUniqueWithoutUserInput | prayerrequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: prayerrequestCreateManyUserInputEnvelope
    set?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    disconnect?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    delete?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    connect?: prayerrequestWhereUniqueInput | prayerrequestWhereUniqueInput[]
    update?: prayerrequestUpdateWithWhereUniqueWithoutUserInput | prayerrequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: prayerrequestUpdateManyWithWhereWithoutUserInput | prayerrequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: prayerrequestScalarWhereInput | prayerrequestScalarWhereInput[]
  }

  export type testimonialUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput> | testimonialCreateWithoutUserInput[] | testimonialUncheckedCreateWithoutUserInput[]
    connectOrCreate?: testimonialCreateOrConnectWithoutUserInput | testimonialCreateOrConnectWithoutUserInput[]
    upsert?: testimonialUpsertWithWhereUniqueWithoutUserInput | testimonialUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: testimonialCreateManyUserInputEnvelope
    set?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    disconnect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    delete?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    connect?: testimonialWhereUniqueInput | testimonialWhereUniqueInput[]
    update?: testimonialUpdateWithWhereUniqueWithoutUserInput | testimonialUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: testimonialUpdateManyWithWhereWithoutUserInput | testimonialUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumadvertisement_adTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.advertisement_adType | Enumadvertisement_adTypeFieldRefInput<$PrismaModel>
    in?: $Enums.advertisement_adType[]
    notIn?: $Enums.advertisement_adType[]
    not?: NestedEnumadvertisement_adTypeFilter<$PrismaModel> | $Enums.advertisement_adType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumadvertisement_adTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.advertisement_adType | Enumadvertisement_adTypeFieldRefInput<$PrismaModel>
    in?: $Enums.advertisement_adType[]
    notIn?: $Enums.advertisement_adType[]
    not?: NestedEnumadvertisement_adTypeWithAggregatesFilter<$PrismaModel> | $Enums.advertisement_adType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumadvertisement_adTypeFilter<$PrismaModel>
    _max?: NestedEnumadvertisement_adTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumblogpost_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.blogpost_category | Enumblogpost_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.blogpost_category[] | null
    notIn?: $Enums.blogpost_category[] | null
    not?: NestedEnumblogpost_categoryNullableFilter<$PrismaModel> | $Enums.blogpost_category | null
  }

  export type NestedEnumblogpost_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.blogpost_category | Enumblogpost_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.blogpost_category[] | null
    notIn?: $Enums.blogpost_category[] | null
    not?: NestedEnumblogpost_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.blogpost_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumblogpost_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumblogpost_categoryNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumcollectionrecord_purposeFilter<$PrismaModel = never> = {
    equals?: $Enums.collectionrecord_purpose | Enumcollectionrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.collectionrecord_purpose[]
    notIn?: $Enums.collectionrecord_purpose[]
    not?: NestedEnumcollectionrecord_purposeFilter<$PrismaModel> | $Enums.collectionrecord_purpose
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumcollectionrecord_purposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.collectionrecord_purpose | Enumcollectionrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.collectionrecord_purpose[]
    notIn?: $Enums.collectionrecord_purpose[]
    not?: NestedEnumcollectionrecord_purposeWithAggregatesFilter<$PrismaModel> | $Enums.collectionrecord_purpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcollectionrecord_purposeFilter<$PrismaModel>
    _max?: NestedEnumcollectionrecord_purposeFilter<$PrismaModel>
  }

  export type NestedEnumcontactmessage_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.contactmessage_status | Enumcontactmessage_statusFieldRefInput<$PrismaModel>
    in?: $Enums.contactmessage_status[]
    notIn?: $Enums.contactmessage_status[]
    not?: NestedEnumcontactmessage_statusFilter<$PrismaModel> | $Enums.contactmessage_status
  }

  export type NestedEnumcontactmessage_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.contactmessage_status | Enumcontactmessage_statusFieldRefInput<$PrismaModel>
    in?: $Enums.contactmessage_status[]
    notIn?: $Enums.contactmessage_status[]
    not?: NestedEnumcontactmessage_statusWithAggregatesFilter<$PrismaModel> | $Enums.contactmessage_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcontactmessage_statusFilter<$PrismaModel>
    _max?: NestedEnumcontactmessage_statusFilter<$PrismaModel>
  }

  export type NestedEnumdecisionlog_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.decisionlog_status | Enumdecisionlog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.decisionlog_status[] | null
    notIn?: $Enums.decisionlog_status[] | null
    not?: NestedEnumdecisionlog_statusNullableFilter<$PrismaModel> | $Enums.decisionlog_status | null
  }

  export type NestedEnumdecisionlog_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.decisionlog_status | Enumdecisionlog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.decisionlog_status[] | null
    notIn?: $Enums.decisionlog_status[] | null
    not?: NestedEnumdecisionlog_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.decisionlog_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumdecisionlog_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumdecisionlog_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumdirectmediaitem_mediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.directmediaitem_mediaType | Enumdirectmediaitem_mediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.directmediaitem_mediaType[]
    notIn?: $Enums.directmediaitem_mediaType[]
    not?: NestedEnumdirectmediaitem_mediaTypeFilter<$PrismaModel> | $Enums.directmediaitem_mediaType
  }

  export type NestedEnumdirectmediaitem_mediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.directmediaitem_mediaType | Enumdirectmediaitem_mediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.directmediaitem_mediaType[]
    notIn?: $Enums.directmediaitem_mediaType[]
    not?: NestedEnumdirectmediaitem_mediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.directmediaitem_mediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdirectmediaitem_mediaTypeFilter<$PrismaModel>
    _max?: NestedEnumdirectmediaitem_mediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumdonationrecord_purposeFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_purpose | Enumdonationrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.donationrecord_purpose[]
    notIn?: $Enums.donationrecord_purpose[]
    not?: NestedEnumdonationrecord_purposeFilter<$PrismaModel> | $Enums.donationrecord_purpose
  }

  export type NestedEnumdonationrecord_paymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_paymentMethod | Enumdonationrecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.donationrecord_paymentMethod[] | null
    notIn?: $Enums.donationrecord_paymentMethod[] | null
    not?: NestedEnumdonationrecord_paymentMethodNullableFilter<$PrismaModel> | $Enums.donationrecord_paymentMethod | null
  }

  export type NestedEnumdonationrecord_purposeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_purpose | Enumdonationrecord_purposeFieldRefInput<$PrismaModel>
    in?: $Enums.donationrecord_purpose[]
    notIn?: $Enums.donationrecord_purpose[]
    not?: NestedEnumdonationrecord_purposeWithAggregatesFilter<$PrismaModel> | $Enums.donationrecord_purpose
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumdonationrecord_purposeFilter<$PrismaModel>
    _max?: NestedEnumdonationrecord_purposeFilter<$PrismaModel>
  }

  export type NestedEnumdonationrecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.donationrecord_paymentMethod | Enumdonationrecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.donationrecord_paymentMethod[] | null
    notIn?: $Enums.donationrecord_paymentMethod[] | null
    not?: NestedEnumdonationrecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.donationrecord_paymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumdonationrecord_paymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumdonationrecord_paymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumeventitem_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.eventitem_category | Enumeventitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.eventitem_category[] | null
    notIn?: $Enums.eventitem_category[] | null
    not?: NestedEnumeventitem_categoryNullableFilter<$PrismaModel> | $Enums.eventitem_category | null
  }

  export type NestedEnumeventitem_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.eventitem_category | Enumeventitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.eventitem_category[] | null
    notIn?: $Enums.eventitem_category[] | null
    not?: NestedEnumeventitem_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.eventitem_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumeventitem_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumeventitem_categoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumexpenserecord_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_category | Enumexpenserecord_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.expenserecord_category[]
    notIn?: $Enums.expenserecord_category[]
    not?: NestedEnumexpenserecord_categoryFilter<$PrismaModel> | $Enums.expenserecord_category
  }

  export type NestedEnumexpenserecord_paymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_paymentMethod | Enumexpenserecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_paymentMethod[] | null
    notIn?: $Enums.expenserecord_paymentMethod[] | null
    not?: NestedEnumexpenserecord_paymentMethodNullableFilter<$PrismaModel> | $Enums.expenserecord_paymentMethod | null
  }

  export type NestedEnumexpenserecord_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_status | Enumexpenserecord_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_status[] | null
    notIn?: $Enums.expenserecord_status[] | null
    not?: NestedEnumexpenserecord_statusNullableFilter<$PrismaModel> | $Enums.expenserecord_status | null
  }

  export type NestedEnumexpenserecord_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_category | Enumexpenserecord_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.expenserecord_category[]
    notIn?: $Enums.expenserecord_category[]
    not?: NestedEnumexpenserecord_categoryWithAggregatesFilter<$PrismaModel> | $Enums.expenserecord_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumexpenserecord_categoryFilter<$PrismaModel>
    _max?: NestedEnumexpenserecord_categoryFilter<$PrismaModel>
  }

  export type NestedEnumexpenserecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_paymentMethod | Enumexpenserecord_paymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_paymentMethod[] | null
    notIn?: $Enums.expenserecord_paymentMethod[] | null
    not?: NestedEnumexpenserecord_paymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.expenserecord_paymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumexpenserecord_paymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumexpenserecord_paymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumexpenserecord_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.expenserecord_status | Enumexpenserecord_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.expenserecord_status[] | null
    notIn?: $Enums.expenserecord_status[] | null
    not?: NestedEnumexpenserecord_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.expenserecord_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumexpenserecord_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumexpenserecord_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumfellowshiprosteritem_rosterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.fellowshiprosteritem_rosterType | Enumfellowshiprosteritem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.fellowshiprosteritem_rosterType[]
    notIn?: $Enums.fellowshiprosteritem_rosterType[]
    not?: NestedEnumfellowshiprosteritem_rosterTypeFilter<$PrismaModel> | $Enums.fellowshiprosteritem_rosterType
  }

  export type NestedEnumfellowshiprosteritem_rosterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.fellowshiprosteritem_rosterType | Enumfellowshiprosteritem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.fellowshiprosteritem_rosterType[]
    notIn?: $Enums.fellowshiprosteritem_rosterType[]
    not?: NestedEnumfellowshiprosteritem_rosterTypeWithAggregatesFilter<$PrismaModel> | $Enums.fellowshiprosteritem_rosterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfellowshiprosteritem_rosterTypeFilter<$PrismaModel>
    _max?: NestedEnumfellowshiprosteritem_rosterTypeFilter<$PrismaModel>
  }

  export type NestedEnumfriendship_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.friendship_status | Enumfriendship_statusFieldRefInput<$PrismaModel>
    in?: $Enums.friendship_status[]
    notIn?: $Enums.friendship_status[]
    not?: NestedEnumfriendship_statusFilter<$PrismaModel> | $Enums.friendship_status
  }

  export type NestedEnumfriendship_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.friendship_status | Enumfriendship_statusFieldRefInput<$PrismaModel>
    in?: $Enums.friendship_status[]
    notIn?: $Enums.friendship_status[]
    not?: NestedEnumfriendship_statusWithAggregatesFilter<$PrismaModel> | $Enums.friendship_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumfriendship_statusFilter<$PrismaModel>
    _max?: NestedEnumfriendship_statusFilter<$PrismaModel>
  }

  export type NestedEnumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedscheduleitem_rosterType | Enumgeneratedscheduleitem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedscheduleitem_rosterType[]
    notIn?: $Enums.generatedscheduleitem_rosterType[]
    not?: NestedEnumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel> | $Enums.generatedscheduleitem_rosterType
  }

  export type NestedEnumgeneratedscheduleitem_rosterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.generatedscheduleitem_rosterType | Enumgeneratedscheduleitem_rosterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.generatedscheduleitem_rosterType[]
    notIn?: $Enums.generatedscheduleitem_rosterType[]
    not?: NestedEnumgeneratedscheduleitem_rosterTypeWithAggregatesFilter<$PrismaModel> | $Enums.generatedscheduleitem_rosterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel>
    _max?: NestedEnumgeneratedscheduleitem_rosterTypeFilter<$PrismaModel>
  }

  export type NestedEnumgroup_editSettingsFilter<$PrismaModel = never> = {
    equals?: $Enums.group_editSettings | Enumgroup_editSettingsFieldRefInput<$PrismaModel>
    in?: $Enums.group_editSettings[]
    notIn?: $Enums.group_editSettings[]
    not?: NestedEnumgroup_editSettingsFilter<$PrismaModel> | $Enums.group_editSettings
  }

  export type NestedEnumgroup_sendMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.group_sendMessage | Enumgroup_sendMessageFieldRefInput<$PrismaModel>
    in?: $Enums.group_sendMessage[]
    notIn?: $Enums.group_sendMessage[]
    not?: NestedEnumgroup_sendMessageFilter<$PrismaModel> | $Enums.group_sendMessage
  }

  export type NestedEnumgroup_addMembersFilter<$PrismaModel = never> = {
    equals?: $Enums.group_addMembers | Enumgroup_addMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_addMembers[]
    notIn?: $Enums.group_addMembers[]
    not?: NestedEnumgroup_addMembersFilter<$PrismaModel> | $Enums.group_addMembers
  }

  export type NestedEnumgroup_approveMembersFilter<$PrismaModel = never> = {
    equals?: $Enums.group_approveMembers | Enumgroup_approveMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_approveMembers[]
    notIn?: $Enums.group_approveMembers[]
    not?: NestedEnumgroup_approveMembersFilter<$PrismaModel> | $Enums.group_approveMembers
  }

  export type NestedEnumgroup_editSettingsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_editSettings | Enumgroup_editSettingsFieldRefInput<$PrismaModel>
    in?: $Enums.group_editSettings[]
    notIn?: $Enums.group_editSettings[]
    not?: NestedEnumgroup_editSettingsWithAggregatesFilter<$PrismaModel> | $Enums.group_editSettings
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_editSettingsFilter<$PrismaModel>
    _max?: NestedEnumgroup_editSettingsFilter<$PrismaModel>
  }

  export type NestedEnumgroup_sendMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_sendMessage | Enumgroup_sendMessageFieldRefInput<$PrismaModel>
    in?: $Enums.group_sendMessage[]
    notIn?: $Enums.group_sendMessage[]
    not?: NestedEnumgroup_sendMessageWithAggregatesFilter<$PrismaModel> | $Enums.group_sendMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_sendMessageFilter<$PrismaModel>
    _max?: NestedEnumgroup_sendMessageFilter<$PrismaModel>
  }

  export type NestedEnumgroup_addMembersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_addMembers | Enumgroup_addMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_addMembers[]
    notIn?: $Enums.group_addMembers[]
    not?: NestedEnumgroup_addMembersWithAggregatesFilter<$PrismaModel> | $Enums.group_addMembers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_addMembersFilter<$PrismaModel>
    _max?: NestedEnumgroup_addMembersFilter<$PrismaModel>
  }

  export type NestedEnumgroup_approveMembersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.group_approveMembers | Enumgroup_approveMembersFieldRefInput<$PrismaModel>
    in?: $Enums.group_approveMembers[]
    notIn?: $Enums.group_approveMembers[]
    not?: NestedEnumgroup_approveMembersWithAggregatesFilter<$PrismaModel> | $Enums.group_approveMembers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroup_approveMembersFilter<$PrismaModel>
    _max?: NestedEnumgroup_approveMembersFilter<$PrismaModel>
  }

  export type NestedEnumgroupmember_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmember_role | Enumgroupmember_roleFieldRefInput<$PrismaModel>
    in?: $Enums.groupmember_role[]
    notIn?: $Enums.groupmember_role[]
    not?: NestedEnumgroupmember_roleFilter<$PrismaModel> | $Enums.groupmember_role
  }

  export type NestedEnumgroupmember_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmember_role | Enumgroupmember_roleFieldRefInput<$PrismaModel>
    in?: $Enums.groupmember_role[]
    notIn?: $Enums.groupmember_role[]
    not?: NestedEnumgroupmember_roleWithAggregatesFilter<$PrismaModel> | $Enums.groupmember_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgroupmember_roleFilter<$PrismaModel>
    _max?: NestedEnumgroupmember_roleFilter<$PrismaModel>
  }

  export type NestedEnumgroupmessage_mediaTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmessage_mediaType | Enumgroupmessage_mediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.groupmessage_mediaType[] | null
    notIn?: $Enums.groupmessage_mediaType[] | null
    not?: NestedEnumgroupmessage_mediaTypeNullableFilter<$PrismaModel> | $Enums.groupmessage_mediaType | null
  }

  export type NestedEnumgroupmessage_mediaTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.groupmessage_mediaType | Enumgroupmessage_mediaTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.groupmessage_mediaType[] | null
    notIn?: $Enums.groupmessage_mediaType[] | null
    not?: NestedEnumgroupmessage_mediaTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.groupmessage_mediaType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumgroupmessage_mediaTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumgroupmessage_mediaTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumhistorychapter_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.historychapter_status | Enumhistorychapter_statusFieldRefInput<$PrismaModel>
    in?: $Enums.historychapter_status[]
    notIn?: $Enums.historychapter_status[]
    not?: NestedEnumhistorychapter_statusFilter<$PrismaModel> | $Enums.historychapter_status
  }

  export type NestedEnumhistorychapter_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.historychapter_status | Enumhistorychapter_statusFieldRefInput<$PrismaModel>
    in?: $Enums.historychapter_status[]
    notIn?: $Enums.historychapter_status[]
    not?: NestedEnumhistorychapter_statusWithAggregatesFilter<$PrismaModel> | $Enums.historychapter_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumhistorychapter_statusFilter<$PrismaModel>
    _max?: NestedEnumhistorychapter_statusFilter<$PrismaModel>
  }

  export type NestedEnummeetingdecisionpoint_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.meetingdecisionpoint_status | Enummeetingdecisionpoint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.meetingdecisionpoint_status[]
    notIn?: $Enums.meetingdecisionpoint_status[]
    not?: NestedEnummeetingdecisionpoint_statusFilter<$PrismaModel> | $Enums.meetingdecisionpoint_status
  }

  export type NestedEnummeetingdecisionpoint_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meetingdecisionpoint_status | Enummeetingdecisionpoint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.meetingdecisionpoint_status[]
    notIn?: $Enums.meetingdecisionpoint_status[]
    not?: NestedEnummeetingdecisionpoint_statusWithAggregatesFilter<$PrismaModel> | $Enums.meetingdecisionpoint_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummeetingdecisionpoint_statusFilter<$PrismaModel>
    _max?: NestedEnummeetingdecisionpoint_statusFilter<$PrismaModel>
  }

  export type NestedEnummeetinglog_meetingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_meetingType | Enummeetinglog_meetingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_meetingType[] | null
    notIn?: $Enums.meetinglog_meetingType[] | null
    not?: NestedEnummeetinglog_meetingTypeNullableFilter<$PrismaModel> | $Enums.meetinglog_meetingType | null
  }

  export type NestedEnummeetinglog_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_status | Enummeetinglog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_status[] | null
    notIn?: $Enums.meetinglog_status[] | null
    not?: NestedEnummeetinglog_statusNullableFilter<$PrismaModel> | $Enums.meetinglog_status | null
  }

  export type NestedEnummeetinglog_meetingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_meetingType | Enummeetinglog_meetingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_meetingType[] | null
    notIn?: $Enums.meetinglog_meetingType[] | null
    not?: NestedEnummeetinglog_meetingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.meetinglog_meetingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummeetinglog_meetingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnummeetinglog_meetingTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnummeetinglog_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.meetinglog_status | Enummeetinglog_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.meetinglog_status[] | null
    notIn?: $Enums.meetinglog_status[] | null
    not?: NestedEnummeetinglog_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.meetinglog_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummeetinglog_statusNullableFilter<$PrismaModel>
    _max?: NestedEnummeetinglog_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumministry_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ministry_category | Enumministry_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ministry_category[] | null
    notIn?: $Enums.ministry_category[] | null
    not?: NestedEnumministry_categoryNullableFilter<$PrismaModel> | $Enums.ministry_category | null
  }

  export type NestedEnumministry_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ministry_category | Enumministry_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ministry_category[] | null
    notIn?: $Enums.ministry_category[] | null
    not?: NestedEnumministry_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ministry_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumministry_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumministry_categoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumministryjoinrequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.ministryjoinrequest_status | Enumministryjoinrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ministryjoinrequest_status[]
    notIn?: $Enums.ministryjoinrequest_status[]
    not?: NestedEnumministryjoinrequest_statusFilter<$PrismaModel> | $Enums.ministryjoinrequest_status
  }

  export type NestedEnumministryjoinrequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ministryjoinrequest_status | Enumministryjoinrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.ministryjoinrequest_status[]
    notIn?: $Enums.ministryjoinrequest_status[]
    not?: NestedEnumministryjoinrequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.ministryjoinrequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumministryjoinrequest_statusFilter<$PrismaModel>
    _max?: NestedEnumministryjoinrequest_statusFilter<$PrismaModel>
  }

  export type NestedEnumnewsitem_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.newsitem_category | Enumnewsitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.newsitem_category[] | null
    notIn?: $Enums.newsitem_category[] | null
    not?: NestedEnumnewsitem_categoryNullableFilter<$PrismaModel> | $Enums.newsitem_category | null
  }

  export type NestedEnumnewsitem_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.newsitem_category | Enumnewsitem_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.newsitem_category[] | null
    notIn?: $Enums.newsitem_category[] | null
    not?: NestedEnumnewsitem_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.newsitem_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumnewsitem_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumnewsitem_categoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumnotification_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[]
    notIn?: $Enums.notification_type[]
    not?: NestedEnumnotification_typeFilter<$PrismaModel> | $Enums.notification_type
  }

  export type NestedEnumnotification_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[]
    notIn?: $Enums.notification_type[]
    not?: NestedEnumnotification_typeWithAggregatesFilter<$PrismaModel> | $Enums.notification_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotification_typeFilter<$PrismaModel>
    _max?: NestedEnumnotification_typeFilter<$PrismaModel>
  }

  export type NestedEnumprayerrequest_visibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_visibility | Enumprayerrequest_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_visibility[]
    notIn?: $Enums.prayerrequest_visibility[]
    not?: NestedEnumprayerrequest_visibilityFilter<$PrismaModel> | $Enums.prayerrequest_visibility
  }

  export type NestedEnumprayerrequest_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_category | Enumprayerrequest_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.prayerrequest_category[] | null
    notIn?: $Enums.prayerrequest_category[] | null
    not?: NestedEnumprayerrequest_categoryNullableFilter<$PrismaModel> | $Enums.prayerrequest_category | null
  }

  export type NestedEnumprayerrequest_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_status | Enumprayerrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_status[]
    notIn?: $Enums.prayerrequest_status[]
    not?: NestedEnumprayerrequest_statusFilter<$PrismaModel> | $Enums.prayerrequest_status
  }

  export type NestedEnumprayerrequest_visibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_visibility | Enumprayerrequest_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_visibility[]
    notIn?: $Enums.prayerrequest_visibility[]
    not?: NestedEnumprayerrequest_visibilityWithAggregatesFilter<$PrismaModel> | $Enums.prayerrequest_visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprayerrequest_visibilityFilter<$PrismaModel>
    _max?: NestedEnumprayerrequest_visibilityFilter<$PrismaModel>
  }

  export type NestedEnumprayerrequest_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_category | Enumprayerrequest_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.prayerrequest_category[] | null
    notIn?: $Enums.prayerrequest_category[] | null
    not?: NestedEnumprayerrequest_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.prayerrequest_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumprayerrequest_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumprayerrequest_categoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumprayerrequest_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.prayerrequest_status | Enumprayerrequest_statusFieldRefInput<$PrismaModel>
    in?: $Enums.prayerrequest_status[]
    notIn?: $Enums.prayerrequest_status[]
    not?: NestedEnumprayerrequest_statusWithAggregatesFilter<$PrismaModel> | $Enums.prayerrequest_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumprayerrequest_statusFilter<$PrismaModel>
    _max?: NestedEnumprayerrequest_statusFilter<$PrismaModel>
  }

  export type NestedEnumsermon_categoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.sermon_category | Enumsermon_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.sermon_category[] | null
    notIn?: $Enums.sermon_category[] | null
    not?: NestedEnumsermon_categoryNullableFilter<$PrismaModel> | $Enums.sermon_category | null
  }

  export type NestedEnumsermon_categoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sermon_category | Enumsermon_categoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.sermon_category[] | null
    notIn?: $Enums.sermon_category[] | null
    not?: NestedEnumsermon_categoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.sermon_category | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumsermon_categoryNullableFilter<$PrismaModel>
    _max?: NestedEnumsermon_categoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumtestimonial_visibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.testimonial_visibility | Enumtestimonial_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.testimonial_visibility[]
    notIn?: $Enums.testimonial_visibility[]
    not?: NestedEnumtestimonial_visibilityFilter<$PrismaModel> | $Enums.testimonial_visibility
  }

  export type NestedEnumtestimonial_visibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.testimonial_visibility | Enumtestimonial_visibilityFieldRefInput<$PrismaModel>
    in?: $Enums.testimonial_visibility[]
    notIn?: $Enums.testimonial_visibility[]
    not?: NestedEnumtestimonial_visibilityWithAggregatesFilter<$PrismaModel> | $Enums.testimonial_visibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtestimonial_visibilityFilter<$PrismaModel>
    _max?: NestedEnumtestimonial_visibilityFilter<$PrismaModel>
  }

  export type NestedEnumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type NestedEnumuser_relationshipStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_relationshipStatus | Enumuser_relationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_relationshipStatus[] | null
    notIn?: $Enums.user_relationshipStatus[] | null
    not?: NestedEnumuser_relationshipStatusNullableFilter<$PrismaModel> | $Enums.user_relationshipStatus | null
  }

  export type NestedEnumuser_friendsListPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendsListPrivacy | Enumuser_friendsListPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendsListPrivacy[]
    notIn?: $Enums.user_friendsListPrivacy[]
    not?: NestedEnumuser_friendsListPrivacyFilter<$PrismaModel> | $Enums.user_friendsListPrivacy
  }

  export type NestedEnumuser_friendRequestPrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendRequestPrivacy | Enumuser_friendRequestPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendRequestPrivacy[]
    notIn?: $Enums.user_friendRequestPrivacy[]
    not?: NestedEnumuser_friendRequestPrivacyFilter<$PrismaModel> | $Enums.user_friendRequestPrivacy
  }

  export type NestedEnumuser_groupInvitePrivacyFilter<$PrismaModel = never> = {
    equals?: $Enums.user_groupInvitePrivacy | Enumuser_groupInvitePrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_groupInvitePrivacy[]
    notIn?: $Enums.user_groupInvitePrivacy[]
    not?: NestedEnumuser_groupInvitePrivacyFilter<$PrismaModel> | $Enums.user_groupInvitePrivacy
  }

  export type NestedEnumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type NestedEnumuser_relationshipStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_relationshipStatus | Enumuser_relationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_relationshipStatus[] | null
    notIn?: $Enums.user_relationshipStatus[] | null
    not?: NestedEnumuser_relationshipStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_relationshipStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_relationshipStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_relationshipStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumuser_friendsListPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendsListPrivacy | Enumuser_friendsListPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendsListPrivacy[]
    notIn?: $Enums.user_friendsListPrivacy[]
    not?: NestedEnumuser_friendsListPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.user_friendsListPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_friendsListPrivacyFilter<$PrismaModel>
    _max?: NestedEnumuser_friendsListPrivacyFilter<$PrismaModel>
  }

  export type NestedEnumuser_friendRequestPrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_friendRequestPrivacy | Enumuser_friendRequestPrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_friendRequestPrivacy[]
    notIn?: $Enums.user_friendRequestPrivacy[]
    not?: NestedEnumuser_friendRequestPrivacyWithAggregatesFilter<$PrismaModel> | $Enums.user_friendRequestPrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_friendRequestPrivacyFilter<$PrismaModel>
    _max?: NestedEnumuser_friendRequestPrivacyFilter<$PrismaModel>
  }

  export type NestedEnumuser_groupInvitePrivacyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_groupInvitePrivacy | Enumuser_groupInvitePrivacyFieldRefInput<$PrismaModel>
    in?: $Enums.user_groupInvitePrivacy[]
    notIn?: $Enums.user_groupInvitePrivacy[]
    not?: NestedEnumuser_groupInvitePrivacyWithAggregatesFilter<$PrismaModel> | $Enums.user_groupInvitePrivacy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_groupInvitePrivacyFilter<$PrismaModel>
    _max?: NestedEnumuser_groupInvitePrivacyFilter<$PrismaModel>
  }

  export type userCreateWithoutAdminactionlogInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAdminactionlogInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAdminactionlogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAdminactionlogInput, userUncheckedCreateWithoutAdminactionlogInput>
  }

  export type userUpsertWithoutAdminactionlogInput = {
    update: XOR<userUpdateWithoutAdminactionlogInput, userUncheckedUpdateWithoutAdminactionlogInput>
    create: XOR<userCreateWithoutAdminactionlogInput, userUncheckedCreateWithoutAdminactionlogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAdminactionlogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAdminactionlogInput, userUncheckedUpdateWithoutAdminactionlogInput>
  }

  export type userUpdateWithoutAdminactionlogInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAdminactionlogInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type commentCreateWithoutBlogpostInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    eventitem?: eventitemCreateNestedOneWithoutCommentInput
    historychapter?: historychapterCreateNestedOneWithoutCommentInput
    newsitem?: newsitemCreateNestedOneWithoutCommentInput
    prayerrequest?: prayerrequestCreateNestedOneWithoutCommentInput
    sermon?: sermonCreateNestedOneWithoutCommentInput
    user: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutBlogpostInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentCreateOrConnectWithoutBlogpostInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutBlogpostInput, commentUncheckedCreateWithoutBlogpostInput>
  }

  export type commentCreateManyBlogpostInputEnvelope = {
    data: commentCreateManyBlogpostInput | commentCreateManyBlogpostInput[]
    skipDuplicates?: boolean
  }

  export type commentUpsertWithWhereUniqueWithoutBlogpostInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutBlogpostInput, commentUncheckedUpdateWithoutBlogpostInput>
    create: XOR<commentCreateWithoutBlogpostInput, commentUncheckedCreateWithoutBlogpostInput>
  }

  export type commentUpdateWithWhereUniqueWithoutBlogpostInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutBlogpostInput, commentUncheckedUpdateWithoutBlogpostInput>
  }

  export type commentUpdateManyWithWhereWithoutBlogpostInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutBlogpostInput>
  }

  export type commentScalarWhereInput = {
    AND?: commentScalarWhereInput | commentScalarWhereInput[]
    OR?: commentScalarWhereInput[]
    NOT?: commentScalarWhereInput | commentScalarWhereInput[]
    id?: StringFilter<"comment"> | string
    userId?: StringFilter<"comment"> | string
    userName?: StringFilter<"comment"> | string
    userProfileImageUrl?: StringNullableFilter<"comment"> | string | null
    text?: StringFilter<"comment"> | string
    timestamp?: DateTimeFilter<"comment"> | Date | string
    editedAt?: DateTimeNullableFilter<"comment"> | Date | string | null
    sermonId?: StringNullableFilter<"comment"> | string | null
    eventId?: StringNullableFilter<"comment"> | string | null
    blogPostId?: StringNullableFilter<"comment"> | string | null
    newsItemId?: StringNullableFilter<"comment"> | string | null
    historyChapterId?: StringNullableFilter<"comment"> | string | null
    prayerRequestId?: StringNullableFilter<"comment"> | string | null
  }

  export type userCreateWithoutChurchmemberInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutChurchmemberInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutChurchmemberInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutChurchmemberInput, userUncheckedCreateWithoutChurchmemberInput>
  }

  export type userUpsertWithoutChurchmemberInput = {
    update: XOR<userUpdateWithoutChurchmemberInput, userUncheckedUpdateWithoutChurchmemberInput>
    create: XOR<userCreateWithoutChurchmemberInput, userUncheckedCreateWithoutChurchmemberInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutChurchmemberInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutChurchmemberInput, userUncheckedUpdateWithoutChurchmemberInput>
  }

  export type userUpdateWithoutChurchmemberInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutChurchmemberInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type donordetailCreateWithoutCollectionrecordInput = {
    id: string
    donorName: string
    amount: Decimal | DecimalJsLike | number | string
    address?: string | null
    contact?: string | null
  }

  export type donordetailUncheckedCreateWithoutCollectionrecordInput = {
    id: string
    donorName: string
    amount: Decimal | DecimalJsLike | number | string
    address?: string | null
    contact?: string | null
  }

  export type donordetailCreateOrConnectWithoutCollectionrecordInput = {
    where: donordetailWhereUniqueInput
    create: XOR<donordetailCreateWithoutCollectionrecordInput, donordetailUncheckedCreateWithoutCollectionrecordInput>
  }

  export type donordetailCreateManyCollectionrecordInputEnvelope = {
    data: donordetailCreateManyCollectionrecordInput | donordetailCreateManyCollectionrecordInput[]
    skipDuplicates?: boolean
  }

  export type donordetailUpsertWithWhereUniqueWithoutCollectionrecordInput = {
    where: donordetailWhereUniqueInput
    update: XOR<donordetailUpdateWithoutCollectionrecordInput, donordetailUncheckedUpdateWithoutCollectionrecordInput>
    create: XOR<donordetailCreateWithoutCollectionrecordInput, donordetailUncheckedCreateWithoutCollectionrecordInput>
  }

  export type donordetailUpdateWithWhereUniqueWithoutCollectionrecordInput = {
    where: donordetailWhereUniqueInput
    data: XOR<donordetailUpdateWithoutCollectionrecordInput, donordetailUncheckedUpdateWithoutCollectionrecordInput>
  }

  export type donordetailUpdateManyWithWhereWithoutCollectionrecordInput = {
    where: donordetailScalarWhereInput
    data: XOR<donordetailUpdateManyMutationInput, donordetailUncheckedUpdateManyWithoutCollectionrecordInput>
  }

  export type donordetailScalarWhereInput = {
    AND?: donordetailScalarWhereInput | donordetailScalarWhereInput[]
    OR?: donordetailScalarWhereInput[]
    NOT?: donordetailScalarWhereInput | donordetailScalarWhereInput[]
    id?: StringFilter<"donordetail"> | string
    donorName?: StringFilter<"donordetail"> | string
    amount?: DecimalFilter<"donordetail"> | Decimal | DecimalJsLike | number | string
    address?: StringNullableFilter<"donordetail"> | string | null
    contact?: StringNullableFilter<"donordetail"> | string | null
    collectionRecordId?: StringFilter<"donordetail"> | string
  }

  export type blogpostCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.blogpost_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    likes?: number
    audioUrl?: string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    videoUrl?: string | null
  }

  export type blogpostUncheckedCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.blogpost_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    likes?: number
    audioUrl?: string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    videoUrl?: string | null
  }

  export type blogpostCreateOrConnectWithoutCommentInput = {
    where: blogpostWhereUniqueInput
    create: XOR<blogpostCreateWithoutCommentInput, blogpostUncheckedCreateWithoutCommentInput>
  }

  export type eventitemCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.eventitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    location?: string | null
    time?: string | null
    expectations?: string | null
    guests?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    registrationLink?: string | null
    capacity?: number | null
    isFeeRequired?: boolean
    feeAmount?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
  }

  export type eventitemUncheckedCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.eventitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    location?: string | null
    time?: string | null
    expectations?: string | null
    guests?: string | null
    contactPerson?: string | null
    contactEmail?: string | null
    contactPhone?: string | null
    registrationLink?: string | null
    capacity?: number | null
    isFeeRequired?: boolean
    feeAmount?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
  }

  export type eventitemCreateOrConnectWithoutCommentInput = {
    where: eventitemWhereUniqueInput
    create: XOR<eventitemCreateWithoutCommentInput, eventitemUncheckedCreateWithoutCommentInput>
  }

  export type historychapterCreateWithoutCommentInput = {
    id: string
    chapterNumber: number
    title: string
    content: string
    status: $Enums.historychapter_status
    imageUrl?: string | null
    summary?: string | null
    authorId?: string | null
    authorName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    lastPublishedAt?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    likes?: number
  }

  export type historychapterUncheckedCreateWithoutCommentInput = {
    id: string
    chapterNumber: number
    title: string
    content: string
    status: $Enums.historychapter_status
    imageUrl?: string | null
    summary?: string | null
    authorId?: string | null
    authorName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    lastPublishedAt?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    likes?: number
  }

  export type historychapterCreateOrConnectWithoutCommentInput = {
    where: historychapterWhereUniqueInput
    create: XOR<historychapterCreateWithoutCommentInput, historychapterUncheckedCreateWithoutCommentInput>
  }

  export type newsitemCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.newsitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
  }

  export type newsitemUncheckedCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.newsitem_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    videoUrl?: string | null
    audioUrl?: string | null
    likes?: number
  }

  export type newsitemCreateOrConnectWithoutCommentInput = {
    where: newsitemWhereUniqueInput
    create: XOR<newsitemCreateWithoutCommentInput, newsitemUncheckedCreateWithoutCommentInput>
  }

  export type prayerrequestCreateWithoutCommentInput = {
    id: string
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    prayer?: prayerCreateNestedManyWithoutPrayerrequestInput
    user?: userCreateNestedOneWithoutPrayerrequestInput
  }

  export type prayerrequestUncheckedCreateWithoutCommentInput = {
    id: string
    userId?: string | null
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    prayer?: prayerUncheckedCreateNestedManyWithoutPrayerrequestInput
  }

  export type prayerrequestCreateOrConnectWithoutCommentInput = {
    where: prayerrequestWhereUniqueInput
    create: XOR<prayerrequestCreateWithoutCommentInput, prayerrequestUncheckedCreateWithoutCommentInput>
  }

  export type sermonCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.sermon_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    speaker?: string | null
    scripture?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fullContent?: string | null
    likes?: number
  }

  export type sermonUncheckedCreateWithoutCommentInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.sermon_category | null
    date?: Date | string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    speaker?: string | null
    scripture?: string | null
    videoUrl?: string | null
    audioUrl?: string | null
    fullContent?: string | null
    likes?: number
  }

  export type sermonCreateOrConnectWithoutCommentInput = {
    where: sermonWhereUniqueInput
    create: XOR<sermonCreateWithoutCommentInput, sermonUncheckedCreateWithoutCommentInput>
  }

  export type userCreateWithoutCommentInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCommentInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCommentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
  }

  export type blogpostUpsertWithoutCommentInput = {
    update: XOR<blogpostUpdateWithoutCommentInput, blogpostUncheckedUpdateWithoutCommentInput>
    create: XOR<blogpostCreateWithoutCommentInput, blogpostUncheckedCreateWithoutCommentInput>
    where?: blogpostWhereInput
  }

  export type blogpostUpdateToOneWithWhereWithoutCommentInput = {
    where?: blogpostWhereInput
    data: XOR<blogpostUpdateWithoutCommentInput, blogpostUncheckedUpdateWithoutCommentInput>
  }

  export type blogpostUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumblogpost_categoryFieldUpdateOperationsInput | $Enums.blogpost_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blogpostUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumblogpost_categoryFieldUpdateOperationsInput | $Enums.blogpost_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type eventitemUpsertWithoutCommentInput = {
    update: XOR<eventitemUpdateWithoutCommentInput, eventitemUncheckedUpdateWithoutCommentInput>
    create: XOR<eventitemCreateWithoutCommentInput, eventitemUncheckedCreateWithoutCommentInput>
    where?: eventitemWhereInput
  }

  export type eventitemUpdateToOneWithWhereWithoutCommentInput = {
    where?: eventitemWhereInput
    data: XOR<eventitemUpdateWithoutCommentInput, eventitemUncheckedUpdateWithoutCommentInput>
  }

  export type eventitemUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumeventitem_categoryFieldUpdateOperationsInput | $Enums.eventitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    guests?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isFeeRequired?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type eventitemUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumeventitem_categoryFieldUpdateOperationsInput | $Enums.eventitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    time?: NullableStringFieldUpdateOperationsInput | string | null
    expectations?: NullableStringFieldUpdateOperationsInput | string | null
    guests?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    isFeeRequired?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type historychapterUpsertWithoutCommentInput = {
    update: XOR<historychapterUpdateWithoutCommentInput, historychapterUncheckedUpdateWithoutCommentInput>
    create: XOR<historychapterCreateWithoutCommentInput, historychapterUncheckedCreateWithoutCommentInput>
    where?: historychapterWhereInput
  }

  export type historychapterUpdateToOneWithWhereWithoutCommentInput = {
    where?: historychapterWhereInput
    data: XOR<historychapterUpdateWithoutCommentInput, historychapterUncheckedUpdateWithoutCommentInput>
  }

  export type historychapterUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: Enumhistorychapter_statusFieldUpdateOperationsInput | $Enums.historychapter_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type historychapterUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: Enumhistorychapter_statusFieldUpdateOperationsInput | $Enums.historychapter_status
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type newsitemUpsertWithoutCommentInput = {
    update: XOR<newsitemUpdateWithoutCommentInput, newsitemUncheckedUpdateWithoutCommentInput>
    create: XOR<newsitemCreateWithoutCommentInput, newsitemUncheckedCreateWithoutCommentInput>
    where?: newsitemWhereInput
  }

  export type newsitemUpdateToOneWithWhereWithoutCommentInput = {
    where?: newsitemWhereInput
    data: XOR<newsitemUpdateWithoutCommentInput, newsitemUncheckedUpdateWithoutCommentInput>
  }

  export type newsitemUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumnewsitem_categoryFieldUpdateOperationsInput | $Enums.newsitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type newsitemUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumnewsitem_categoryFieldUpdateOperationsInput | $Enums.newsitem_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type prayerrequestUpsertWithoutCommentInput = {
    update: XOR<prayerrequestUpdateWithoutCommentInput, prayerrequestUncheckedUpdateWithoutCommentInput>
    create: XOR<prayerrequestCreateWithoutCommentInput, prayerrequestUncheckedCreateWithoutCommentInput>
    where?: prayerrequestWhereInput
  }

  export type prayerrequestUpdateToOneWithWhereWithoutCommentInput = {
    where?: prayerrequestWhereInput
    data: XOR<prayerrequestUpdateWithoutCommentInput, prayerrequestUncheckedUpdateWithoutCommentInput>
  }

  export type prayerrequestUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    prayer?: prayerUpdateManyWithoutPrayerrequestNestedInput
    user?: userUpdateOneWithoutPrayerrequestNestedInput
  }

  export type prayerrequestUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    prayer?: prayerUncheckedUpdateManyWithoutPrayerrequestNestedInput
  }

  export type sermonUpsertWithoutCommentInput = {
    update: XOR<sermonUpdateWithoutCommentInput, sermonUncheckedUpdateWithoutCommentInput>
    create: XOR<sermonCreateWithoutCommentInput, sermonUncheckedCreateWithoutCommentInput>
    where?: sermonWhereInput
  }

  export type sermonUpdateToOneWithWhereWithoutCommentInput = {
    where?: sermonWhereInput
    data: XOR<sermonUpdateWithoutCommentInput, sermonUncheckedUpdateWithoutCommentInput>
  }

  export type sermonUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumsermon_categoryFieldUpdateOperationsInput | $Enums.sermon_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    scripture?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullContent?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type sermonUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumsermon_categoryFieldUpdateOperationsInput | $Enums.sermon_category | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speaker?: NullableStringFieldUpdateOperationsInput | string | null
    scripture?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fullContent?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
  }

  export type userUpsertWithoutCommentInput = {
    update: XOR<userUpdateWithoutCommentInput, userUncheckedUpdateWithoutCommentInput>
    create: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCommentInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCommentInput, userUncheckedUpdateWithoutCommentInput>
  }

  export type userUpdateWithoutCommentInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCommentInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type collectionrecordCreateWithoutDonordetailInput = {
    id: string
    collectorName: string
    collectionDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.collectionrecord_purpose
    source?: string | null
    notes?: string | null
    recordedAt?: Date | string
    recordedByOwnerId?: string | null
    recordedByOwnerName?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    countedBy?: string | null
    isDeposited?: boolean
    depositDate?: Date | string | null
    bankDepositReference?: string | null
  }

  export type collectionrecordUncheckedCreateWithoutDonordetailInput = {
    id: string
    collectorName: string
    collectionDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    purpose: $Enums.collectionrecord_purpose
    source?: string | null
    notes?: string | null
    recordedAt?: Date | string
    recordedByOwnerId?: string | null
    recordedByOwnerName?: string | null
    updatedAt: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    countedBy?: string | null
    isDeposited?: boolean
    depositDate?: Date | string | null
    bankDepositReference?: string | null
  }

  export type collectionrecordCreateOrConnectWithoutDonordetailInput = {
    where: collectionrecordWhereUniqueInput
    create: XOR<collectionrecordCreateWithoutDonordetailInput, collectionrecordUncheckedCreateWithoutDonordetailInput>
  }

  export type collectionrecordUpsertWithoutDonordetailInput = {
    update: XOR<collectionrecordUpdateWithoutDonordetailInput, collectionrecordUncheckedUpdateWithoutDonordetailInput>
    create: XOR<collectionrecordCreateWithoutDonordetailInput, collectionrecordUncheckedCreateWithoutDonordetailInput>
    where?: collectionrecordWhereInput
  }

  export type collectionrecordUpdateToOneWithWhereWithoutDonordetailInput = {
    where?: collectionrecordWhereInput
    data: XOR<collectionrecordUpdateWithoutDonordetailInput, collectionrecordUncheckedUpdateWithoutDonordetailInput>
  }

  export type collectionrecordUpdateWithoutDonordetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectorName?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFieldUpdateOperationsInput | $Enums.collectionrecord_purpose
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeposited?: BoolFieldUpdateOperationsInput | boolean
    depositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankDepositReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectionrecordUncheckedUpdateWithoutDonordetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectorName?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purpose?: Enumcollectionrecord_purposeFieldUpdateOperationsInput | $Enums.collectionrecord_purpose
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    recordedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    countedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isDeposited?: BoolFieldUpdateOperationsInput | boolean
    depositDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bankDepositReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentCreateWithoutEventitemInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    blogpost?: blogpostCreateNestedOneWithoutCommentInput
    historychapter?: historychapterCreateNestedOneWithoutCommentInput
    newsitem?: newsitemCreateNestedOneWithoutCommentInput
    prayerrequest?: prayerrequestCreateNestedOneWithoutCommentInput
    sermon?: sermonCreateNestedOneWithoutCommentInput
    user: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutEventitemInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentCreateOrConnectWithoutEventitemInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutEventitemInput, commentUncheckedCreateWithoutEventitemInput>
  }

  export type commentCreateManyEventitemInputEnvelope = {
    data: commentCreateManyEventitemInput | commentCreateManyEventitemInput[]
    skipDuplicates?: boolean
  }

  export type commentUpsertWithWhereUniqueWithoutEventitemInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutEventitemInput, commentUncheckedUpdateWithoutEventitemInput>
    create: XOR<commentCreateWithoutEventitemInput, commentUncheckedCreateWithoutEventitemInput>
  }

  export type commentUpdateWithWhereUniqueWithoutEventitemInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutEventitemInput, commentUncheckedUpdateWithoutEventitemInput>
  }

  export type commentUpdateManyWithWhereWithoutEventitemInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutEventitemInput>
  }

  export type generatedscheduleitemCreateWithoutFellowshiprosteritemInput = {
    id: string
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    responsibility?: responsibilityCreateNestedManyWithoutGeneratedscheduleitemInput
  }

  export type generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput = {
    id: string
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    responsibility?: responsibilityUncheckedCreateNestedManyWithoutGeneratedscheduleitemInput
  }

  export type generatedscheduleitemCreateOrConnectWithoutFellowshiprosteritemInput = {
    where: generatedscheduleitemWhereUniqueInput
    create: XOR<generatedscheduleitemCreateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput>
  }

  export type generatedscheduleitemCreateManyFellowshiprosteritemInputEnvelope = {
    data: generatedscheduleitemCreateManyFellowshiprosteritemInput | generatedscheduleitemCreateManyFellowshiprosteritemInput[]
    skipDuplicates?: boolean
  }

  export type responsibilityCreateWithoutFellowshiprosteritemInput = {
    id: string
    role: string
    assignedTo: string
    generatedscheduleitem?: generatedscheduleitemCreateNestedOneWithoutResponsibilityInput
  }

  export type responsibilityUncheckedCreateWithoutFellowshiprosteritemInput = {
    id: string
    role: string
    assignedTo: string
    generatedScheduleId?: string | null
  }

  export type responsibilityCreateOrConnectWithoutFellowshiprosteritemInput = {
    where: responsibilityWhereUniqueInput
    create: XOR<responsibilityCreateWithoutFellowshiprosteritemInput, responsibilityUncheckedCreateWithoutFellowshiprosteritemInput>
  }

  export type responsibilityCreateManyFellowshiprosteritemInputEnvelope = {
    data: responsibilityCreateManyFellowshiprosteritemInput | responsibilityCreateManyFellowshiprosteritemInput[]
    skipDuplicates?: boolean
  }

  export type generatedscheduleitemUpsertWithWhereUniqueWithoutFellowshiprosteritemInput = {
    where: generatedscheduleitemWhereUniqueInput
    update: XOR<generatedscheduleitemUpdateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedUpdateWithoutFellowshiprosteritemInput>
    create: XOR<generatedscheduleitemCreateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedCreateWithoutFellowshiprosteritemInput>
  }

  export type generatedscheduleitemUpdateWithWhereUniqueWithoutFellowshiprosteritemInput = {
    where: generatedscheduleitemWhereUniqueInput
    data: XOR<generatedscheduleitemUpdateWithoutFellowshiprosteritemInput, generatedscheduleitemUncheckedUpdateWithoutFellowshiprosteritemInput>
  }

  export type generatedscheduleitemUpdateManyWithWhereWithoutFellowshiprosteritemInput = {
    where: generatedscheduleitemScalarWhereInput
    data: XOR<generatedscheduleitemUpdateManyMutationInput, generatedscheduleitemUncheckedUpdateManyWithoutFellowshiprosteritemInput>
  }

  export type generatedscheduleitemScalarWhereInput = {
    AND?: generatedscheduleitemScalarWhereInput | generatedscheduleitemScalarWhereInput[]
    OR?: generatedscheduleitemScalarWhereInput[]
    NOT?: generatedscheduleitemScalarWhereInput | generatedscheduleitemScalarWhereInput[]
    id?: StringFilter<"generatedscheduleitem"> | string
    basedOnRosterItemId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFilter<"generatedscheduleitem"> | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFilter<"generatedscheduleitem"> | string
    scheduledDate?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    timeSlot?: StringFilter<"generatedscheduleitem"> | string
    location?: StringNullableFilter<"generatedscheduleitem"> | string | null
    contactNumber?: StringNullableFilter<"generatedscheduleitem"> | string | null
    additionalNotesOrProgramDetails?: StringNullableFilter<"generatedscheduleitem"> | string | null
    generatedAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    isPublishedAsEvent?: BoolFilter<"generatedscheduleitem"> | boolean
    publishedEventId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    adminNotes?: StringNullableFilter<"generatedscheduleitem"> | string | null
    postedByOwnerId?: StringNullableFilter<"generatedscheduleitem"> | string | null
    postedByOwnerName?: StringNullableFilter<"generatedscheduleitem"> | string | null
    createdAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
    updatedAt?: DateTimeFilter<"generatedscheduleitem"> | Date | string
  }

  export type responsibilityUpsertWithWhereUniqueWithoutFellowshiprosteritemInput = {
    where: responsibilityWhereUniqueInput
    update: XOR<responsibilityUpdateWithoutFellowshiprosteritemInput, responsibilityUncheckedUpdateWithoutFellowshiprosteritemInput>
    create: XOR<responsibilityCreateWithoutFellowshiprosteritemInput, responsibilityUncheckedCreateWithoutFellowshiprosteritemInput>
  }

  export type responsibilityUpdateWithWhereUniqueWithoutFellowshiprosteritemInput = {
    where: responsibilityWhereUniqueInput
    data: XOR<responsibilityUpdateWithoutFellowshiprosteritemInput, responsibilityUncheckedUpdateWithoutFellowshiprosteritemInput>
  }

  export type responsibilityUpdateManyWithWhereWithoutFellowshiprosteritemInput = {
    where: responsibilityScalarWhereInput
    data: XOR<responsibilityUpdateManyMutationInput, responsibilityUncheckedUpdateManyWithoutFellowshiprosteritemInput>
  }

  export type responsibilityScalarWhereInput = {
    AND?: responsibilityScalarWhereInput | responsibilityScalarWhereInput[]
    OR?: responsibilityScalarWhereInput[]
    NOT?: responsibilityScalarWhereInput | responsibilityScalarWhereInput[]
    id?: StringFilter<"responsibility"> | string
    role?: StringFilter<"responsibility"> | string
    assignedTo?: StringFilter<"responsibility"> | string
    rosterItemId?: StringNullableFilter<"responsibility"> | string | null
    generatedScheduleId?: StringNullableFilter<"responsibility"> | string | null
  }

  export type userCreateWithoutFriendship_friendship_addresseeIdTouserInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFriendship_friendship_addresseeIdTouserInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFriendship_friendship_addresseeIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFriendship_friendship_addresseeIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_addresseeIdTouserInput>
  }

  export type userCreateWithoutFriendship_friendship_requesterIdTouserInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFriendship_friendship_requesterIdTouserInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFriendship_friendship_requesterIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFriendship_friendship_requesterIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_requesterIdTouserInput>
  }

  export type userUpsertWithoutFriendship_friendship_addresseeIdTouserInput = {
    update: XOR<userUpdateWithoutFriendship_friendship_addresseeIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_addresseeIdTouserInput>
    create: XOR<userCreateWithoutFriendship_friendship_addresseeIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_addresseeIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFriendship_friendship_addresseeIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFriendship_friendship_addresseeIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_addresseeIdTouserInput>
  }

  export type userUpdateWithoutFriendship_friendship_addresseeIdTouserInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFriendship_friendship_addresseeIdTouserInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutFriendship_friendship_requesterIdTouserInput = {
    update: XOR<userUpdateWithoutFriendship_friendship_requesterIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_requesterIdTouserInput>
    create: XOR<userCreateWithoutFriendship_friendship_requesterIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_requesterIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFriendship_friendship_requesterIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFriendship_friendship_requesterIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_requesterIdTouserInput>
  }

  export type userUpdateWithoutFriendship_friendship_requesterIdTouserInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFriendship_friendship_requesterIdTouserInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutFrontendactivitylogInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFrontendactivitylogInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFrontendactivitylogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFrontendactivitylogInput, userUncheckedCreateWithoutFrontendactivitylogInput>
  }

  export type userUpsertWithoutFrontendactivitylogInput = {
    update: XOR<userUpdateWithoutFrontendactivitylogInput, userUncheckedUpdateWithoutFrontendactivitylogInput>
    create: XOR<userCreateWithoutFrontendactivitylogInput, userUncheckedCreateWithoutFrontendactivitylogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFrontendactivitylogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFrontendactivitylogInput, userUncheckedUpdateWithoutFrontendactivitylogInput>
  }

  export type userUpdateWithoutFrontendactivitylogInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFrontendactivitylogInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type fellowshiprosteritemCreateWithoutGeneratedscheduleitemInput = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    isTemplate?: boolean
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    responsibility?: responsibilityCreateNestedManyWithoutFellowshiprosteritemInput
  }

  export type fellowshiprosteritemUncheckedCreateWithoutGeneratedscheduleitemInput = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    isTemplate?: boolean
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    responsibility?: responsibilityUncheckedCreateNestedManyWithoutFellowshiprosteritemInput
  }

  export type fellowshiprosteritemCreateOrConnectWithoutGeneratedscheduleitemInput = {
    where: fellowshiprosteritemWhereUniqueInput
    create: XOR<fellowshiprosteritemCreateWithoutGeneratedscheduleitemInput, fellowshiprosteritemUncheckedCreateWithoutGeneratedscheduleitemInput>
  }

  export type responsibilityCreateWithoutGeneratedscheduleitemInput = {
    id: string
    role: string
    assignedTo: string
    fellowshiprosteritem?: fellowshiprosteritemCreateNestedOneWithoutResponsibilityInput
  }

  export type responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput = {
    id: string
    role: string
    assignedTo: string
    rosterItemId?: string | null
  }

  export type responsibilityCreateOrConnectWithoutGeneratedscheduleitemInput = {
    where: responsibilityWhereUniqueInput
    create: XOR<responsibilityCreateWithoutGeneratedscheduleitemInput, responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput>
  }

  export type responsibilityCreateManyGeneratedscheduleitemInputEnvelope = {
    data: responsibilityCreateManyGeneratedscheduleitemInput | responsibilityCreateManyGeneratedscheduleitemInput[]
    skipDuplicates?: boolean
  }

  export type fellowshiprosteritemUpsertWithoutGeneratedscheduleitemInput = {
    update: XOR<fellowshiprosteritemUpdateWithoutGeneratedscheduleitemInput, fellowshiprosteritemUncheckedUpdateWithoutGeneratedscheduleitemInput>
    create: XOR<fellowshiprosteritemCreateWithoutGeneratedscheduleitemInput, fellowshiprosteritemUncheckedCreateWithoutGeneratedscheduleitemInput>
    where?: fellowshiprosteritemWhereInput
  }

  export type fellowshiprosteritemUpdateToOneWithWhereWithoutGeneratedscheduleitemInput = {
    where?: fellowshiprosteritemWhereInput
    data: XOR<fellowshiprosteritemUpdateWithoutGeneratedscheduleitemInput, fellowshiprosteritemUncheckedUpdateWithoutGeneratedscheduleitemInput>
  }

  export type fellowshiprosteritemUpdateWithoutGeneratedscheduleitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibility?: responsibilityUpdateManyWithoutFellowshiprosteritemNestedInput
  }

  export type fellowshiprosteritemUncheckedUpdateWithoutGeneratedscheduleitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibility?: responsibilityUncheckedUpdateManyWithoutFellowshiprosteritemNestedInput
  }

  export type responsibilityUpsertWithWhereUniqueWithoutGeneratedscheduleitemInput = {
    where: responsibilityWhereUniqueInput
    update: XOR<responsibilityUpdateWithoutGeneratedscheduleitemInput, responsibilityUncheckedUpdateWithoutGeneratedscheduleitemInput>
    create: XOR<responsibilityCreateWithoutGeneratedscheduleitemInput, responsibilityUncheckedCreateWithoutGeneratedscheduleitemInput>
  }

  export type responsibilityUpdateWithWhereUniqueWithoutGeneratedscheduleitemInput = {
    where: responsibilityWhereUniqueInput
    data: XOR<responsibilityUpdateWithoutGeneratedscheduleitemInput, responsibilityUncheckedUpdateWithoutGeneratedscheduleitemInput>
  }

  export type responsibilityUpdateManyWithWhereWithoutGeneratedscheduleitemInput = {
    where: responsibilityScalarWhereInput
    data: XOR<responsibilityUpdateManyMutationInput, responsibilityUncheckedUpdateManyWithoutGeneratedscheduleitemInput>
  }

  export type groupmemberCreateWithoutGroupInput = {
    id: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
    user: userCreateNestedOneWithoutGroupmemberInput
  }

  export type groupmemberUncheckedCreateWithoutGroupInput = {
    id: string
    userId: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
  }

  export type groupmemberCreateOrConnectWithoutGroupInput = {
    where: groupmemberWhereUniqueInput
    create: XOR<groupmemberCreateWithoutGroupInput, groupmemberUncheckedCreateWithoutGroupInput>
  }

  export type groupmemberCreateManyGroupInputEnvelope = {
    data: groupmemberCreateManyGroupInput | groupmemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type groupmessageCreateWithoutGroupInput = {
    id: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
    user: userCreateNestedOneWithoutGroupmessageInput
  }

  export type groupmessageUncheckedCreateWithoutGroupInput = {
    id: string
    senderId: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
  }

  export type groupmessageCreateOrConnectWithoutGroupInput = {
    where: groupmessageWhereUniqueInput
    create: XOR<groupmessageCreateWithoutGroupInput, groupmessageUncheckedCreateWithoutGroupInput>
  }

  export type groupmessageCreateManyGroupInputEnvelope = {
    data: groupmessageCreateManyGroupInput | groupmessageCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type groupmemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: groupmemberWhereUniqueInput
    update: XOR<groupmemberUpdateWithoutGroupInput, groupmemberUncheckedUpdateWithoutGroupInput>
    create: XOR<groupmemberCreateWithoutGroupInput, groupmemberUncheckedCreateWithoutGroupInput>
  }

  export type groupmemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: groupmemberWhereUniqueInput
    data: XOR<groupmemberUpdateWithoutGroupInput, groupmemberUncheckedUpdateWithoutGroupInput>
  }

  export type groupmemberUpdateManyWithWhereWithoutGroupInput = {
    where: groupmemberScalarWhereInput
    data: XOR<groupmemberUpdateManyMutationInput, groupmemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type groupmemberScalarWhereInput = {
    AND?: groupmemberScalarWhereInput | groupmemberScalarWhereInput[]
    OR?: groupmemberScalarWhereInput[]
    NOT?: groupmemberScalarWhereInput | groupmemberScalarWhereInput[]
    id?: StringFilter<"groupmember"> | string
    groupId?: StringFilter<"groupmember"> | string
    userId?: StringFilter<"groupmember"> | string
    role?: Enumgroupmember_roleFilter<"groupmember"> | $Enums.groupmember_role
    addedAt?: DateTimeFilter<"groupmember"> | Date | string
  }

  export type groupmessageUpsertWithWhereUniqueWithoutGroupInput = {
    where: groupmessageWhereUniqueInput
    update: XOR<groupmessageUpdateWithoutGroupInput, groupmessageUncheckedUpdateWithoutGroupInput>
    create: XOR<groupmessageCreateWithoutGroupInput, groupmessageUncheckedCreateWithoutGroupInput>
  }

  export type groupmessageUpdateWithWhereUniqueWithoutGroupInput = {
    where: groupmessageWhereUniqueInput
    data: XOR<groupmessageUpdateWithoutGroupInput, groupmessageUncheckedUpdateWithoutGroupInput>
  }

  export type groupmessageUpdateManyWithWhereWithoutGroupInput = {
    where: groupmessageScalarWhereInput
    data: XOR<groupmessageUpdateManyMutationInput, groupmessageUncheckedUpdateManyWithoutGroupInput>
  }

  export type groupmessageScalarWhereInput = {
    AND?: groupmessageScalarWhereInput | groupmessageScalarWhereInput[]
    OR?: groupmessageScalarWhereInput[]
    NOT?: groupmessageScalarWhereInput | groupmessageScalarWhereInput[]
    id?: StringFilter<"groupmessage"> | string
    groupId?: StringFilter<"groupmessage"> | string
    senderId?: StringFilter<"groupmessage"> | string
    senderName?: StringFilter<"groupmessage"> | string
    senderProfileImageUrl?: StringNullableFilter<"groupmessage"> | string | null
    text?: StringNullableFilter<"groupmessage"> | string | null
    mediaUrl?: StringNullableFilter<"groupmessage"> | string | null
    mediaType?: Enumgroupmessage_mediaTypeNullableFilter<"groupmessage"> | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFilter<"groupmessage"> | Date | string
  }

  export type groupCreateWithoutGroupmemberInput = {
    id: string
    name: string
    creatorId: string
    groupImageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    editSettings?: $Enums.group_editSettings
    sendMessage?: $Enums.group_sendMessage
    addMembers?: $Enums.group_addMembers
    approveMembers?: $Enums.group_approveMembers
    groupmessage?: groupmessageCreateNestedManyWithoutGroupInput
  }

  export type groupUncheckedCreateWithoutGroupmemberInput = {
    id: string
    name: string
    creatorId: string
    groupImageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    editSettings?: $Enums.group_editSettings
    sendMessage?: $Enums.group_sendMessage
    addMembers?: $Enums.group_addMembers
    approveMembers?: $Enums.group_approveMembers
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutGroupInput
  }

  export type groupCreateOrConnectWithoutGroupmemberInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutGroupmemberInput, groupUncheckedCreateWithoutGroupmemberInput>
  }

  export type userCreateWithoutGroupmemberInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutGroupmemberInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutGroupmemberInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGroupmemberInput, userUncheckedCreateWithoutGroupmemberInput>
  }

  export type groupUpsertWithoutGroupmemberInput = {
    update: XOR<groupUpdateWithoutGroupmemberInput, groupUncheckedUpdateWithoutGroupmemberInput>
    create: XOR<groupCreateWithoutGroupmemberInput, groupUncheckedCreateWithoutGroupmemberInput>
    where?: groupWhereInput
  }

  export type groupUpdateToOneWithWhereWithoutGroupmemberInput = {
    where?: groupWhereInput
    data: XOR<groupUpdateWithoutGroupmemberInput, groupUncheckedUpdateWithoutGroupmemberInput>
  }

  export type groupUpdateWithoutGroupmemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
    groupmessage?: groupmessageUpdateManyWithoutGroupNestedInput
  }

  export type groupUncheckedUpdateWithoutGroupmemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
    groupmessage?: groupmessageUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type userUpsertWithoutGroupmemberInput = {
    update: XOR<userUpdateWithoutGroupmemberInput, userUncheckedUpdateWithoutGroupmemberInput>
    create: XOR<userCreateWithoutGroupmemberInput, userUncheckedCreateWithoutGroupmemberInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGroupmemberInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGroupmemberInput, userUncheckedUpdateWithoutGroupmemberInput>
  }

  export type userUpdateWithoutGroupmemberInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutGroupmemberInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type groupCreateWithoutGroupmessageInput = {
    id: string
    name: string
    creatorId: string
    groupImageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    editSettings?: $Enums.group_editSettings
    sendMessage?: $Enums.group_sendMessage
    addMembers?: $Enums.group_addMembers
    approveMembers?: $Enums.group_approveMembers
    groupmember?: groupmemberCreateNestedManyWithoutGroupInput
  }

  export type groupUncheckedCreateWithoutGroupmessageInput = {
    id: string
    name: string
    creatorId: string
    groupImageUrl?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    editSettings?: $Enums.group_editSettings
    sendMessage?: $Enums.group_sendMessage
    addMembers?: $Enums.group_addMembers
    approveMembers?: $Enums.group_approveMembers
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type groupCreateOrConnectWithoutGroupmessageInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutGroupmessageInput, groupUncheckedCreateWithoutGroupmessageInput>
  }

  export type userCreateWithoutGroupmessageInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutGroupmessageInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutGroupmessageInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGroupmessageInput, userUncheckedCreateWithoutGroupmessageInput>
  }

  export type groupUpsertWithoutGroupmessageInput = {
    update: XOR<groupUpdateWithoutGroupmessageInput, groupUncheckedUpdateWithoutGroupmessageInput>
    create: XOR<groupCreateWithoutGroupmessageInput, groupUncheckedCreateWithoutGroupmessageInput>
    where?: groupWhereInput
  }

  export type groupUpdateToOneWithWhereWithoutGroupmessageInput = {
    where?: groupWhereInput
    data: XOR<groupUpdateWithoutGroupmessageInput, groupUncheckedUpdateWithoutGroupmessageInput>
  }

  export type groupUpdateWithoutGroupmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
    groupmember?: groupmemberUpdateManyWithoutGroupNestedInput
  }

  export type groupUncheckedUpdateWithoutGroupmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    groupImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editSettings?: Enumgroup_editSettingsFieldUpdateOperationsInput | $Enums.group_editSettings
    sendMessage?: Enumgroup_sendMessageFieldUpdateOperationsInput | $Enums.group_sendMessage
    addMembers?: Enumgroup_addMembersFieldUpdateOperationsInput | $Enums.group_addMembers
    approveMembers?: Enumgroup_approveMembersFieldUpdateOperationsInput | $Enums.group_approveMembers
    groupmember?: groupmemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type userUpsertWithoutGroupmessageInput = {
    update: XOR<userUpdateWithoutGroupmessageInput, userUncheckedUpdateWithoutGroupmessageInput>
    create: XOR<userCreateWithoutGroupmessageInput, userUncheckedCreateWithoutGroupmessageInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGroupmessageInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGroupmessageInput, userUncheckedUpdateWithoutGroupmessageInput>
  }

  export type userUpdateWithoutGroupmessageInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutGroupmessageInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type commentCreateWithoutHistorychapterInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    blogpost?: blogpostCreateNestedOneWithoutCommentInput
    eventitem?: eventitemCreateNestedOneWithoutCommentInput
    newsitem?: newsitemCreateNestedOneWithoutCommentInput
    prayerrequest?: prayerrequestCreateNestedOneWithoutCommentInput
    sermon?: sermonCreateNestedOneWithoutCommentInput
    user: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutHistorychapterInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    prayerRequestId?: string | null
  }

  export type commentCreateOrConnectWithoutHistorychapterInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutHistorychapterInput, commentUncheckedCreateWithoutHistorychapterInput>
  }

  export type commentCreateManyHistorychapterInputEnvelope = {
    data: commentCreateManyHistorychapterInput | commentCreateManyHistorychapterInput[]
    skipDuplicates?: boolean
  }

  export type commentUpsertWithWhereUniqueWithoutHistorychapterInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutHistorychapterInput, commentUncheckedUpdateWithoutHistorychapterInput>
    create: XOR<commentCreateWithoutHistorychapterInput, commentUncheckedCreateWithoutHistorychapterInput>
  }

  export type commentUpdateWithWhereUniqueWithoutHistorychapterInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutHistorychapterInput, commentUncheckedUpdateWithoutHistorychapterInput>
  }

  export type commentUpdateManyWithWhereWithoutHistorychapterInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutHistorychapterInput>
  }

  export type meetinglogCreateWithoutMeetingdecisionpointInput = {
    id: string
    meetingDate: Date | string
    title: string
    meetingType?: $Enums.meetinglog_meetingType | null
    attendees: string
    agenda: string
    minutes: string
    actionItems?: string | null
    status?: $Enums.meetinglog_status | null
    imageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meetinglogUncheckedCreateWithoutMeetingdecisionpointInput = {
    id: string
    meetingDate: Date | string
    title: string
    meetingType?: $Enums.meetinglog_meetingType | null
    attendees: string
    agenda: string
    minutes: string
    actionItems?: string | null
    status?: $Enums.meetinglog_status | null
    imageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type meetinglogCreateOrConnectWithoutMeetingdecisionpointInput = {
    where: meetinglogWhereUniqueInput
    create: XOR<meetinglogCreateWithoutMeetingdecisionpointInput, meetinglogUncheckedCreateWithoutMeetingdecisionpointInput>
  }

  export type meetinglogUpsertWithoutMeetingdecisionpointInput = {
    update: XOR<meetinglogUpdateWithoutMeetingdecisionpointInput, meetinglogUncheckedUpdateWithoutMeetingdecisionpointInput>
    create: XOR<meetinglogCreateWithoutMeetingdecisionpointInput, meetinglogUncheckedCreateWithoutMeetingdecisionpointInput>
    where?: meetinglogWhereInput
  }

  export type meetinglogUpdateToOneWithWhereWithoutMeetingdecisionpointInput = {
    where?: meetinglogWhereInput
    data: XOR<meetinglogUpdateWithoutMeetingdecisionpointInput, meetinglogUncheckedUpdateWithoutMeetingdecisionpointInput>
  }

  export type meetinglogUpdateWithoutMeetingdecisionpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    meetingType?: NullableEnummeetinglog_meetingTypeFieldUpdateOperationsInput | $Enums.meetinglog_meetingType | null
    attendees?: StringFieldUpdateOperationsInput | string
    agenda?: StringFieldUpdateOperationsInput | string
    minutes?: StringFieldUpdateOperationsInput | string
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnummeetinglog_statusFieldUpdateOperationsInput | $Enums.meetinglog_status | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetinglogUncheckedUpdateWithoutMeetingdecisionpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    meetingType?: NullableEnummeetinglog_meetingTypeFieldUpdateOperationsInput | $Enums.meetinglog_meetingType | null
    attendees?: StringFieldUpdateOperationsInput | string
    agenda?: StringFieldUpdateOperationsInput | string
    minutes?: StringFieldUpdateOperationsInput | string
    actionItems?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnummeetinglog_statusFieldUpdateOperationsInput | $Enums.meetinglog_status | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetingdecisionpointCreateWithoutMeetinglogInput = {
    id: string
    description: string
    proposedBy?: string | null
    status: $Enums.meetingdecisionpoint_status
    followUpNotes?: string | null
    resolutionDate?: Date | string | null
  }

  export type meetingdecisionpointUncheckedCreateWithoutMeetinglogInput = {
    id: string
    description: string
    proposedBy?: string | null
    status: $Enums.meetingdecisionpoint_status
    followUpNotes?: string | null
    resolutionDate?: Date | string | null
  }

  export type meetingdecisionpointCreateOrConnectWithoutMeetinglogInput = {
    where: meetingdecisionpointWhereUniqueInput
    create: XOR<meetingdecisionpointCreateWithoutMeetinglogInput, meetingdecisionpointUncheckedCreateWithoutMeetinglogInput>
  }

  export type meetingdecisionpointCreateManyMeetinglogInputEnvelope = {
    data: meetingdecisionpointCreateManyMeetinglogInput | meetingdecisionpointCreateManyMeetinglogInput[]
    skipDuplicates?: boolean
  }

  export type meetingdecisionpointUpsertWithWhereUniqueWithoutMeetinglogInput = {
    where: meetingdecisionpointWhereUniqueInput
    update: XOR<meetingdecisionpointUpdateWithoutMeetinglogInput, meetingdecisionpointUncheckedUpdateWithoutMeetinglogInput>
    create: XOR<meetingdecisionpointCreateWithoutMeetinglogInput, meetingdecisionpointUncheckedCreateWithoutMeetinglogInput>
  }

  export type meetingdecisionpointUpdateWithWhereUniqueWithoutMeetinglogInput = {
    where: meetingdecisionpointWhereUniqueInput
    data: XOR<meetingdecisionpointUpdateWithoutMeetinglogInput, meetingdecisionpointUncheckedUpdateWithoutMeetinglogInput>
  }

  export type meetingdecisionpointUpdateManyWithWhereWithoutMeetinglogInput = {
    where: meetingdecisionpointScalarWhereInput
    data: XOR<meetingdecisionpointUpdateManyMutationInput, meetingdecisionpointUncheckedUpdateManyWithoutMeetinglogInput>
  }

  export type meetingdecisionpointScalarWhereInput = {
    AND?: meetingdecisionpointScalarWhereInput | meetingdecisionpointScalarWhereInput[]
    OR?: meetingdecisionpointScalarWhereInput[]
    NOT?: meetingdecisionpointScalarWhereInput | meetingdecisionpointScalarWhereInput[]
    id?: StringFilter<"meetingdecisionpoint"> | string
    description?: StringFilter<"meetingdecisionpoint"> | string
    proposedBy?: StringNullableFilter<"meetingdecisionpoint"> | string | null
    status?: Enummeetingdecisionpoint_statusFilter<"meetingdecisionpoint"> | $Enums.meetingdecisionpoint_status
    followUpNotes?: StringNullableFilter<"meetingdecisionpoint"> | string | null
    resolutionDate?: DateTimeNullableFilter<"meetingdecisionpoint"> | Date | string | null
    meetingLogId?: StringFilter<"meetingdecisionpoint"> | string
  }

  export type ministryjoinrequestCreateWithoutMinistryInput = {
    id: string
    userName: string
    userEmail: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
    user: userCreateNestedOneWithoutMinistryjoinrequestInput
  }

  export type ministryjoinrequestUncheckedCreateWithoutMinistryInput = {
    id: string
    userId: string
    userName: string
    userEmail: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
  }

  export type ministryjoinrequestCreateOrConnectWithoutMinistryInput = {
    where: ministryjoinrequestWhereUniqueInput
    create: XOR<ministryjoinrequestCreateWithoutMinistryInput, ministryjoinrequestUncheckedCreateWithoutMinistryInput>
  }

  export type ministryjoinrequestCreateManyMinistryInputEnvelope = {
    data: ministryjoinrequestCreateManyMinistryInput | ministryjoinrequestCreateManyMinistryInput[]
    skipDuplicates?: boolean
  }

  export type ministryjoinrequestUpsertWithWhereUniqueWithoutMinistryInput = {
    where: ministryjoinrequestWhereUniqueInput
    update: XOR<ministryjoinrequestUpdateWithoutMinistryInput, ministryjoinrequestUncheckedUpdateWithoutMinistryInput>
    create: XOR<ministryjoinrequestCreateWithoutMinistryInput, ministryjoinrequestUncheckedCreateWithoutMinistryInput>
  }

  export type ministryjoinrequestUpdateWithWhereUniqueWithoutMinistryInput = {
    where: ministryjoinrequestWhereUniqueInput
    data: XOR<ministryjoinrequestUpdateWithoutMinistryInput, ministryjoinrequestUncheckedUpdateWithoutMinistryInput>
  }

  export type ministryjoinrequestUpdateManyWithWhereWithoutMinistryInput = {
    where: ministryjoinrequestScalarWhereInput
    data: XOR<ministryjoinrequestUpdateManyMutationInput, ministryjoinrequestUncheckedUpdateManyWithoutMinistryInput>
  }

  export type ministryjoinrequestScalarWhereInput = {
    AND?: ministryjoinrequestScalarWhereInput | ministryjoinrequestScalarWhereInput[]
    OR?: ministryjoinrequestScalarWhereInput[]
    NOT?: ministryjoinrequestScalarWhereInput | ministryjoinrequestScalarWhereInput[]
    id?: StringFilter<"ministryjoinrequest"> | string
    userId?: StringFilter<"ministryjoinrequest"> | string
    userName?: StringFilter<"ministryjoinrequest"> | string
    userEmail?: StringFilter<"ministryjoinrequest"> | string
    ministryId?: StringFilter<"ministryjoinrequest"> | string
    ministryName?: StringFilter<"ministryjoinrequest"> | string
    ministryGuidelines?: StringFilter<"ministryjoinrequest"> | string
    requestDate?: DateTimeFilter<"ministryjoinrequest"> | Date | string
    message?: StringFilter<"ministryjoinrequest"> | string
    status?: Enumministryjoinrequest_statusFilter<"ministryjoinrequest"> | $Enums.ministryjoinrequest_status
    processedDate?: DateTimeNullableFilter<"ministryjoinrequest"> | Date | string | null
    adminNotes?: StringNullableFilter<"ministryjoinrequest"> | string | null
  }

  export type ministryCreateWithoutMinistryjoinrequestInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.ministry_category | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    leader?: string | null
    meetingTime?: string | null
  }

  export type ministryUncheckedCreateWithoutMinistryjoinrequestInput = {
    id: string
    title: string
    description: string
    imageUrl?: string | null
    linkPath: string
    category?: $Enums.ministry_category | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    leader?: string | null
    meetingTime?: string | null
  }

  export type ministryCreateOrConnectWithoutMinistryjoinrequestInput = {
    where: ministryWhereUniqueInput
    create: XOR<ministryCreateWithoutMinistryjoinrequestInput, ministryUncheckedCreateWithoutMinistryjoinrequestInput>
  }

  export type userCreateWithoutMinistryjoinrequestInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMinistryjoinrequestInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMinistryjoinrequestInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMinistryjoinrequestInput, userUncheckedCreateWithoutMinistryjoinrequestInput>
  }

  export type ministryUpsertWithoutMinistryjoinrequestInput = {
    update: XOR<ministryUpdateWithoutMinistryjoinrequestInput, ministryUncheckedUpdateWithoutMinistryjoinrequestInput>
    create: XOR<ministryCreateWithoutMinistryjoinrequestInput, ministryUncheckedCreateWithoutMinistryjoinrequestInput>
    where?: ministryWhereInput
  }

  export type ministryUpdateToOneWithWhereWithoutMinistryjoinrequestInput = {
    where?: ministryWhereInput
    data: XOR<ministryUpdateWithoutMinistryjoinrequestInput, ministryUncheckedUpdateWithoutMinistryjoinrequestInput>
  }

  export type ministryUpdateWithoutMinistryjoinrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumministry_categoryFieldUpdateOperationsInput | $Enums.ministry_category | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: NullableStringFieldUpdateOperationsInput | string | null
    meetingTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ministryUncheckedUpdateWithoutMinistryjoinrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    linkPath?: StringFieldUpdateOperationsInput | string
    category?: NullableEnumministry_categoryFieldUpdateOperationsInput | $Enums.ministry_category | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: NullableStringFieldUpdateOperationsInput | string | null
    meetingTime?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUpsertWithoutMinistryjoinrequestInput = {
    update: XOR<userUpdateWithoutMinistryjoinrequestInput, userUncheckedUpdateWithoutMinistryjoinrequestInput>
    create: XOR<userCreateWithoutMinistryjoinrequestInput, userUncheckedCreateWithoutMinistryjoinrequestInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMinistryjoinrequestInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMinistryjoinrequestInput, userUncheckedUpdateWithoutMinistryjoinrequestInput>
  }

  export type userUpdateWithoutMinistryjoinrequestInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMinistryjoinrequestInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type commentCreateWithoutNewsitemInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    blogpost?: blogpostCreateNestedOneWithoutCommentInput
    eventitem?: eventitemCreateNestedOneWithoutCommentInput
    historychapter?: historychapterCreateNestedOneWithoutCommentInput
    prayerrequest?: prayerrequestCreateNestedOneWithoutCommentInput
    sermon?: sermonCreateNestedOneWithoutCommentInput
    user: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutNewsitemInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentCreateOrConnectWithoutNewsitemInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutNewsitemInput, commentUncheckedCreateWithoutNewsitemInput>
  }

  export type commentCreateManyNewsitemInputEnvelope = {
    data: commentCreateManyNewsitemInput | commentCreateManyNewsitemInput[]
    skipDuplicates?: boolean
  }

  export type commentUpsertWithWhereUniqueWithoutNewsitemInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutNewsitemInput, commentUncheckedUpdateWithoutNewsitemInput>
    create: XOR<commentCreateWithoutNewsitemInput, commentUncheckedCreateWithoutNewsitemInput>
  }

  export type commentUpdateWithWhereUniqueWithoutNewsitemInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutNewsitemInput, commentUncheckedUpdateWithoutNewsitemInput>
  }

  export type commentUpdateManyWithWhereWithoutNewsitemInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutNewsitemInput>
  }

  export type userCreateWithoutNotificationInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotificationInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotificationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
  }

  export type userUpsertWithoutNotificationInput = {
    update: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotificationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
  }

  export type userUpdateWithoutNotificationInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotificationInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type prayerrequestCreateWithoutPrayerInput = {
    id: string
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    comment?: commentCreateNestedManyWithoutPrayerrequestInput
    user?: userCreateNestedOneWithoutPrayerrequestInput
  }

  export type prayerrequestUncheckedCreateWithoutPrayerInput = {
    id: string
    userId?: string | null
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    comment?: commentUncheckedCreateNestedManyWithoutPrayerrequestInput
  }

  export type prayerrequestCreateOrConnectWithoutPrayerInput = {
    where: prayerrequestWhereUniqueInput
    create: XOR<prayerrequestCreateWithoutPrayerInput, prayerrequestUncheckedCreateWithoutPrayerInput>
  }

  export type userCreateWithoutPrayerInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPrayerInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPrayerInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPrayerInput, userUncheckedCreateWithoutPrayerInput>
  }

  export type prayerrequestUpsertWithoutPrayerInput = {
    update: XOR<prayerrequestUpdateWithoutPrayerInput, prayerrequestUncheckedUpdateWithoutPrayerInput>
    create: XOR<prayerrequestCreateWithoutPrayerInput, prayerrequestUncheckedCreateWithoutPrayerInput>
    where?: prayerrequestWhereInput
  }

  export type prayerrequestUpdateToOneWithWhereWithoutPrayerInput = {
    where?: prayerrequestWhereInput
    data: XOR<prayerrequestUpdateWithoutPrayerInput, prayerrequestUncheckedUpdateWithoutPrayerInput>
  }

  export type prayerrequestUpdateWithoutPrayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUpdateManyWithoutPrayerrequestNestedInput
    user?: userUpdateOneWithoutPrayerrequestNestedInput
  }

  export type prayerrequestUncheckedUpdateWithoutPrayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUncheckedUpdateManyWithoutPrayerrequestNestedInput
  }

  export type userUpsertWithoutPrayerInput = {
    update: XOR<userUpdateWithoutPrayerInput, userUncheckedUpdateWithoutPrayerInput>
    create: XOR<userCreateWithoutPrayerInput, userUncheckedCreateWithoutPrayerInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPrayerInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPrayerInput, userUncheckedUpdateWithoutPrayerInput>
  }

  export type userUpdateWithoutPrayerInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPrayerInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type commentCreateWithoutPrayerrequestInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    blogpost?: blogpostCreateNestedOneWithoutCommentInput
    eventitem?: eventitemCreateNestedOneWithoutCommentInput
    historychapter?: historychapterCreateNestedOneWithoutCommentInput
    newsitem?: newsitemCreateNestedOneWithoutCommentInput
    sermon?: sermonCreateNestedOneWithoutCommentInput
    user: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutPrayerrequestInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
  }

  export type commentCreateOrConnectWithoutPrayerrequestInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutPrayerrequestInput, commentUncheckedCreateWithoutPrayerrequestInput>
  }

  export type commentCreateManyPrayerrequestInputEnvelope = {
    data: commentCreateManyPrayerrequestInput | commentCreateManyPrayerrequestInput[]
    skipDuplicates?: boolean
  }

  export type prayerCreateWithoutPrayerrequestInput = {
    id: string
    userName: string
    timestamp?: Date | string
    user: userCreateNestedOneWithoutPrayerInput
  }

  export type prayerUncheckedCreateWithoutPrayerrequestInput = {
    id: string
    userId: string
    userName: string
    timestamp?: Date | string
  }

  export type prayerCreateOrConnectWithoutPrayerrequestInput = {
    where: prayerWhereUniqueInput
    create: XOR<prayerCreateWithoutPrayerrequestInput, prayerUncheckedCreateWithoutPrayerrequestInput>
  }

  export type prayerCreateManyPrayerrequestInputEnvelope = {
    data: prayerCreateManyPrayerrequestInput | prayerCreateManyPrayerrequestInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutPrayerrequestInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    testimonial?: testimonialCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPrayerrequestInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    testimonial?: testimonialUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPrayerrequestInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPrayerrequestInput, userUncheckedCreateWithoutPrayerrequestInput>
  }

  export type commentUpsertWithWhereUniqueWithoutPrayerrequestInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutPrayerrequestInput, commentUncheckedUpdateWithoutPrayerrequestInput>
    create: XOR<commentCreateWithoutPrayerrequestInput, commentUncheckedCreateWithoutPrayerrequestInput>
  }

  export type commentUpdateWithWhereUniqueWithoutPrayerrequestInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutPrayerrequestInput, commentUncheckedUpdateWithoutPrayerrequestInput>
  }

  export type commentUpdateManyWithWhereWithoutPrayerrequestInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutPrayerrequestInput>
  }

  export type prayerUpsertWithWhereUniqueWithoutPrayerrequestInput = {
    where: prayerWhereUniqueInput
    update: XOR<prayerUpdateWithoutPrayerrequestInput, prayerUncheckedUpdateWithoutPrayerrequestInput>
    create: XOR<prayerCreateWithoutPrayerrequestInput, prayerUncheckedCreateWithoutPrayerrequestInput>
  }

  export type prayerUpdateWithWhereUniqueWithoutPrayerrequestInput = {
    where: prayerWhereUniqueInput
    data: XOR<prayerUpdateWithoutPrayerrequestInput, prayerUncheckedUpdateWithoutPrayerrequestInput>
  }

  export type prayerUpdateManyWithWhereWithoutPrayerrequestInput = {
    where: prayerScalarWhereInput
    data: XOR<prayerUpdateManyMutationInput, prayerUncheckedUpdateManyWithoutPrayerrequestInput>
  }

  export type prayerScalarWhereInput = {
    AND?: prayerScalarWhereInput | prayerScalarWhereInput[]
    OR?: prayerScalarWhereInput[]
    NOT?: prayerScalarWhereInput | prayerScalarWhereInput[]
    id?: StringFilter<"prayer"> | string
    userId?: StringFilter<"prayer"> | string
    userName?: StringFilter<"prayer"> | string
    timestamp?: DateTimeFilter<"prayer"> | Date | string
    prayerRequestId?: StringFilter<"prayer"> | string
  }

  export type userUpsertWithoutPrayerrequestInput = {
    update: XOR<userUpdateWithoutPrayerrequestInput, userUncheckedUpdateWithoutPrayerrequestInput>
    create: XOR<userCreateWithoutPrayerrequestInput, userUncheckedCreateWithoutPrayerrequestInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPrayerrequestInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPrayerrequestInput, userUncheckedUpdateWithoutPrayerrequestInput>
  }

  export type userUpdateWithoutPrayerrequestInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPrayerrequestInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    testimonial?: testimonialUncheckedUpdateManyWithoutUserNestedInput
  }

  export type generatedscheduleitemCreateWithoutResponsibilityInput = {
    id: string
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    fellowshiprosteritem?: fellowshiprosteritemCreateNestedOneWithoutGeneratedscheduleitemInput
  }

  export type generatedscheduleitemUncheckedCreateWithoutResponsibilityInput = {
    id: string
    basedOnRosterItemId?: string | null
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type generatedscheduleitemCreateOrConnectWithoutResponsibilityInput = {
    where: generatedscheduleitemWhereUniqueInput
    create: XOR<generatedscheduleitemCreateWithoutResponsibilityInput, generatedscheduleitemUncheckedCreateWithoutResponsibilityInput>
  }

  export type fellowshiprosteritemCreateWithoutResponsibilityInput = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    isTemplate?: boolean
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    generatedscheduleitem?: generatedscheduleitemCreateNestedManyWithoutFellowshiprosteritemInput
  }

  export type fellowshiprosteritemUncheckedCreateWithoutResponsibilityInput = {
    id: string
    rosterType: $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle: string
    assignedDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    isTemplate?: boolean
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    generatedscheduleitem?: generatedscheduleitemUncheckedCreateNestedManyWithoutFellowshiprosteritemInput
  }

  export type fellowshiprosteritemCreateOrConnectWithoutResponsibilityInput = {
    where: fellowshiprosteritemWhereUniqueInput
    create: XOR<fellowshiprosteritemCreateWithoutResponsibilityInput, fellowshiprosteritemUncheckedCreateWithoutResponsibilityInput>
  }

  export type generatedscheduleitemUpsertWithoutResponsibilityInput = {
    update: XOR<generatedscheduleitemUpdateWithoutResponsibilityInput, generatedscheduleitemUncheckedUpdateWithoutResponsibilityInput>
    create: XOR<generatedscheduleitemCreateWithoutResponsibilityInput, generatedscheduleitemUncheckedCreateWithoutResponsibilityInput>
    where?: generatedscheduleitemWhereInput
  }

  export type generatedscheduleitemUpdateToOneWithWhereWithoutResponsibilityInput = {
    where?: generatedscheduleitemWhereInput
    data: XOR<generatedscheduleitemUpdateWithoutResponsibilityInput, generatedscheduleitemUncheckedUpdateWithoutResponsibilityInput>
  }

  export type generatedscheduleitemUpdateWithoutResponsibilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fellowshiprosteritem?: fellowshiprosteritemUpdateOneWithoutGeneratedscheduleitemNestedInput
  }

  export type generatedscheduleitemUncheckedUpdateWithoutResponsibilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    basedOnRosterItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fellowshiprosteritemUpsertWithoutResponsibilityInput = {
    update: XOR<fellowshiprosteritemUpdateWithoutResponsibilityInput, fellowshiprosteritemUncheckedUpdateWithoutResponsibilityInput>
    create: XOR<fellowshiprosteritemCreateWithoutResponsibilityInput, fellowshiprosteritemUncheckedCreateWithoutResponsibilityInput>
    where?: fellowshiprosteritemWhereInput
  }

  export type fellowshiprosteritemUpdateToOneWithWhereWithoutResponsibilityInput = {
    where?: fellowshiprosteritemWhereInput
    data: XOR<fellowshiprosteritemUpdateWithoutResponsibilityInput, fellowshiprosteritemUncheckedUpdateWithoutResponsibilityInput>
  }

  export type fellowshiprosteritemUpdateWithoutResponsibilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedscheduleitem?: generatedscheduleitemUpdateManyWithoutFellowshiprosteritemNestedInput
  }

  export type fellowshiprosteritemUncheckedUpdateWithoutResponsibilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumfellowshiprosteritem_rosterTypeFieldUpdateOperationsInput | $Enums.fellowshiprosteritem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedscheduleitem?: generatedscheduleitemUncheckedUpdateManyWithoutFellowshiprosteritemNestedInput
  }

  export type commentCreateWithoutSermonInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    blogpost?: blogpostCreateNestedOneWithoutCommentInput
    eventitem?: eventitemCreateNestedOneWithoutCommentInput
    historychapter?: historychapterCreateNestedOneWithoutCommentInput
    newsitem?: newsitemCreateNestedOneWithoutCommentInput
    prayerrequest?: prayerrequestCreateNestedOneWithoutCommentInput
    user: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutSermonInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentCreateOrConnectWithoutSermonInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutSermonInput, commentUncheckedCreateWithoutSermonInput>
  }

  export type commentCreateManySermonInputEnvelope = {
    data: commentCreateManySermonInput | commentCreateManySermonInput[]
    skipDuplicates?: boolean
  }

  export type commentUpsertWithWhereUniqueWithoutSermonInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutSermonInput, commentUncheckedUpdateWithoutSermonInput>
    create: XOR<commentCreateWithoutSermonInput, commentUncheckedCreateWithoutSermonInput>
  }

  export type commentUpdateWithWhereUniqueWithoutSermonInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutSermonInput, commentUncheckedUpdateWithoutSermonInput>
  }

  export type commentUpdateManyWithWhereWithoutSermonInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutSermonInput>
  }

  export type userCreateWithoutTestimonialInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogCreateNestedManyWithoutUserInput
    churchmember?: churchmemberCreateNestedOneWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogCreateNestedManyWithoutUserInput
    groupmember?: groupmemberCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestCreateNestedManyWithoutUserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    prayer?: prayerCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTestimonialInput = {
    password: string
    passwordHash?: string | null
    id: string
    username: string
    fullName: string
    email: string
    countryCode?: string | null
    phone?: string | null
    role?: $Enums.user_role
    profileImageUrl?: string | null
    coverPhotoUrl?: string | null
    bio?: string | null
    hometown?: string | null
    currentCity?: string | null
    work?: string | null
    education?: string | null
    relationshipStatus?: $Enums.user_relationshipStatus | null
    interests?: string | null
    favoriteScripture?: string | null
    receiveContentUpdateNotifications?: boolean
    receivePrayerRequestNotifications?: boolean
    receiveTestimonialNotifications?: boolean
    receiveFriendActivityNotifications?: boolean
    friendsListPrivacy?: $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: boolean
    friendRequestPrivacy?: $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: $Enums.user_groupInvitePrivacy
    createdAt?: Date | string
    updatedAt?: Date | string
    adminactionlog?: adminactionlogUncheckedCreateNestedManyWithoutUserInput
    churchmember?: churchmemberUncheckedCreateNestedOneWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_addresseeIdTouserInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_requesterIdTouserInput
    frontendactivitylog?: frontendactivitylogUncheckedCreateNestedManyWithoutUserInput
    groupmember?: groupmemberUncheckedCreateNestedManyWithoutUserInput
    groupmessage?: groupmessageUncheckedCreateNestedManyWithoutUserInput
    ministryjoinrequest?: ministryjoinrequestUncheckedCreateNestedManyWithoutUserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    prayer?: prayerUncheckedCreateNestedManyWithoutUserInput
    prayerrequest?: prayerrequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTestimonialInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
  }

  export type userUpsertWithoutTestimonialInput = {
    update: XOR<userUpdateWithoutTestimonialInput, userUncheckedUpdateWithoutTestimonialInput>
    create: XOR<userCreateWithoutTestimonialInput, userUncheckedCreateWithoutTestimonialInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTestimonialInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTestimonialInput, userUncheckedUpdateWithoutTestimonialInput>
  }

  export type userUpdateWithoutTestimonialInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUpdateOneWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUpdateManyWithoutUserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    prayer?: prayerUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTestimonialInput = {
    password?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    hometown?: NullableStringFieldUpdateOperationsInput | string | null
    currentCity?: NullableStringFieldUpdateOperationsInput | string | null
    work?: NullableStringFieldUpdateOperationsInput | string | null
    education?: NullableStringFieldUpdateOperationsInput | string | null
    relationshipStatus?: NullableEnumuser_relationshipStatusFieldUpdateOperationsInput | $Enums.user_relationshipStatus | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    favoriteScripture?: NullableStringFieldUpdateOperationsInput | string | null
    receiveContentUpdateNotifications?: BoolFieldUpdateOperationsInput | boolean
    receivePrayerRequestNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveTestimonialNotifications?: BoolFieldUpdateOperationsInput | boolean
    receiveFriendActivityNotifications?: BoolFieldUpdateOperationsInput | boolean
    friendsListPrivacy?: Enumuser_friendsListPrivacyFieldUpdateOperationsInput | $Enums.user_friendsListPrivacy
    profileInSearchPrivacy?: BoolFieldUpdateOperationsInput | boolean
    friendRequestPrivacy?: Enumuser_friendRequestPrivacyFieldUpdateOperationsInput | $Enums.user_friendRequestPrivacy
    groupInvitePrivacy?: Enumuser_groupInvitePrivacyFieldUpdateOperationsInput | $Enums.user_groupInvitePrivacy
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminactionlog?: adminactionlogUncheckedUpdateManyWithoutUserNestedInput
    churchmember?: churchmemberUncheckedUpdateOneWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_addresseeIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserNestedInput
    friendship_friendship_requesterIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserNestedInput
    frontendactivitylog?: frontendactivitylogUncheckedUpdateManyWithoutUserNestedInput
    groupmember?: groupmemberUncheckedUpdateManyWithoutUserNestedInput
    groupmessage?: groupmessageUncheckedUpdateManyWithoutUserNestedInput
    ministryjoinrequest?: ministryjoinrequestUncheckedUpdateManyWithoutUserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutUserNestedInput
    prayerrequest?: prayerrequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type adminactionlogCreateWithoutUserInput = {
    id: string
    timestamp?: Date | string
    adminName: string
    action: string
    targetId?: string | null
    details?: string | null
  }

  export type adminactionlogUncheckedCreateWithoutUserInput = {
    id: string
    timestamp?: Date | string
    adminName: string
    action: string
    targetId?: string | null
    details?: string | null
  }

  export type adminactionlogCreateOrConnectWithoutUserInput = {
    where: adminactionlogWhereUniqueInput
    create: XOR<adminactionlogCreateWithoutUserInput, adminactionlogUncheckedCreateWithoutUserInput>
  }

  export type adminactionlogCreateManyUserInputEnvelope = {
    data: adminactionlogCreateManyUserInput | adminactionlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type churchmemberCreateWithoutUserInput = {
    id: string
    fullName: string
    username?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    address?: string | null
    memberSince: Date | string
    dateOfBirth?: Date | string | null
    baptismDate?: Date | string | null
    familyMembers?: string | null
    notes?: string | null
    isActiveMember: boolean
    profileImageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type churchmemberUncheckedCreateWithoutUserInput = {
    id: string
    fullName: string
    username?: string | null
    contactPhone?: string | null
    contactEmail?: string | null
    address?: string | null
    memberSince: Date | string
    dateOfBirth?: Date | string | null
    baptismDate?: Date | string | null
    familyMembers?: string | null
    notes?: string | null
    isActiveMember: boolean
    profileImageUrl?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type churchmemberCreateOrConnectWithoutUserInput = {
    where: churchmemberWhereUniqueInput
    create: XOR<churchmemberCreateWithoutUserInput, churchmemberUncheckedCreateWithoutUserInput>
  }

  export type commentCreateWithoutUserInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    blogpost?: blogpostCreateNestedOneWithoutCommentInput
    eventitem?: eventitemCreateNestedOneWithoutCommentInput
    historychapter?: historychapterCreateNestedOneWithoutCommentInput
    newsitem?: newsitemCreateNestedOneWithoutCommentInput
    prayerrequest?: prayerrequestCreateNestedOneWithoutCommentInput
    sermon?: sermonCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutUserInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentCreateOrConnectWithoutUserInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput>
  }

  export type commentCreateManyUserInputEnvelope = {
    data: commentCreateManyUserInput | commentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type friendshipCreateWithoutUser_friendship_addresseeIdTouserInput = {
    id: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
    user_friendship_requesterIdTouser: userCreateNestedOneWithoutFriendship_friendship_requesterIdTouserInput
  }

  export type friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput = {
    id: string
    requesterId: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type friendshipCreateOrConnectWithoutUser_friendship_addresseeIdTouserInput = {
    where: friendshipWhereUniqueInput
    create: XOR<friendshipCreateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput>
  }

  export type friendshipCreateManyUser_friendship_addresseeIdTouserInputEnvelope = {
    data: friendshipCreateManyUser_friendship_addresseeIdTouserInput | friendshipCreateManyUser_friendship_addresseeIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type friendshipCreateWithoutUser_friendship_requesterIdTouserInput = {
    id: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
    user_friendship_addresseeIdTouser: userCreateNestedOneWithoutFriendship_friendship_addresseeIdTouserInput
  }

  export type friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput = {
    id: string
    addresseeId: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type friendshipCreateOrConnectWithoutUser_friendship_requesterIdTouserInput = {
    where: friendshipWhereUniqueInput
    create: XOR<friendshipCreateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput>
  }

  export type friendshipCreateManyUser_friendship_requesterIdTouserInputEnvelope = {
    data: friendshipCreateManyUser_friendship_requesterIdTouserInput | friendshipCreateManyUser_friendship_requesterIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type frontendactivitylogCreateWithoutUserInput = {
    id: string
    timestamp?: Date | string
    description: string
    type: string
    itemId?: string | null
    itemType?: string | null
  }

  export type frontendactivitylogUncheckedCreateWithoutUserInput = {
    id: string
    timestamp?: Date | string
    description: string
    type: string
    itemId?: string | null
    itemType?: string | null
  }

  export type frontendactivitylogCreateOrConnectWithoutUserInput = {
    where: frontendactivitylogWhereUniqueInput
    create: XOR<frontendactivitylogCreateWithoutUserInput, frontendactivitylogUncheckedCreateWithoutUserInput>
  }

  export type frontendactivitylogCreateManyUserInputEnvelope = {
    data: frontendactivitylogCreateManyUserInput | frontendactivitylogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type groupmemberCreateWithoutUserInput = {
    id: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
    group: groupCreateNestedOneWithoutGroupmemberInput
  }

  export type groupmemberUncheckedCreateWithoutUserInput = {
    id: string
    groupId: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
  }

  export type groupmemberCreateOrConnectWithoutUserInput = {
    where: groupmemberWhereUniqueInput
    create: XOR<groupmemberCreateWithoutUserInput, groupmemberUncheckedCreateWithoutUserInput>
  }

  export type groupmemberCreateManyUserInputEnvelope = {
    data: groupmemberCreateManyUserInput | groupmemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type groupmessageCreateWithoutUserInput = {
    id: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
    group: groupCreateNestedOneWithoutGroupmessageInput
  }

  export type groupmessageUncheckedCreateWithoutUserInput = {
    id: string
    groupId: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
  }

  export type groupmessageCreateOrConnectWithoutUserInput = {
    where: groupmessageWhereUniqueInput
    create: XOR<groupmessageCreateWithoutUserInput, groupmessageUncheckedCreateWithoutUserInput>
  }

  export type groupmessageCreateManyUserInputEnvelope = {
    data: groupmessageCreateManyUserInput | groupmessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ministryjoinrequestCreateWithoutUserInput = {
    id: string
    userName: string
    userEmail: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
    ministry: ministryCreateNestedOneWithoutMinistryjoinrequestInput
  }

  export type ministryjoinrequestUncheckedCreateWithoutUserInput = {
    id: string
    userName: string
    userEmail: string
    ministryId: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
  }

  export type ministryjoinrequestCreateOrConnectWithoutUserInput = {
    where: ministryjoinrequestWhereUniqueInput
    create: XOR<ministryjoinrequestCreateWithoutUserInput, ministryjoinrequestUncheckedCreateWithoutUserInput>
  }

  export type ministryjoinrequestCreateManyUserInputEnvelope = {
    data: ministryjoinrequestCreateManyUserInput | ministryjoinrequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutUserInput = {
    id: string
    message: string
    link?: string | null
    timestamp?: Date | string
    read?: boolean
    type: $Enums.notification_type
  }

  export type notificationUncheckedCreateWithoutUserInput = {
    id: string
    message: string
    link?: string | null
    timestamp?: Date | string
    read?: boolean
    type: $Enums.notification_type
  }

  export type notificationCreateOrConnectWithoutUserInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationCreateManyUserInputEnvelope = {
    data: notificationCreateManyUserInput | notificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type prayerCreateWithoutUserInput = {
    id: string
    userName: string
    timestamp?: Date | string
    prayerrequest: prayerrequestCreateNestedOneWithoutPrayerInput
  }

  export type prayerUncheckedCreateWithoutUserInput = {
    id: string
    userName: string
    timestamp?: Date | string
    prayerRequestId: string
  }

  export type prayerCreateOrConnectWithoutUserInput = {
    where: prayerWhereUniqueInput
    create: XOR<prayerCreateWithoutUserInput, prayerUncheckedCreateWithoutUserInput>
  }

  export type prayerCreateManyUserInputEnvelope = {
    data: prayerCreateManyUserInput | prayerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type prayerrequestCreateWithoutUserInput = {
    id: string
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    comment?: commentCreateNestedManyWithoutPrayerrequestInput
    prayer?: prayerCreateNestedManyWithoutPrayerrequestInput
  }

  export type prayerrequestUncheckedCreateWithoutUserInput = {
    id: string
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
    comment?: commentUncheckedCreateNestedManyWithoutPrayerrequestInput
    prayer?: prayerUncheckedCreateNestedManyWithoutPrayerrequestInput
  }

  export type prayerrequestCreateOrConnectWithoutUserInput = {
    where: prayerrequestWhereUniqueInput
    create: XOR<prayerrequestCreateWithoutUserInput, prayerrequestUncheckedCreateWithoutUserInput>
  }

  export type prayerrequestCreateManyUserInputEnvelope = {
    data: prayerrequestCreateManyUserInput | prayerrequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type testimonialCreateWithoutUserInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    title: string
    contentText: string
    visibility: $Enums.testimonial_visibility
    submittedAt?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
  }

  export type testimonialUncheckedCreateWithoutUserInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    title: string
    contentText: string
    visibility: $Enums.testimonial_visibility
    submittedAt?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
  }

  export type testimonialCreateOrConnectWithoutUserInput = {
    where: testimonialWhereUniqueInput
    create: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput>
  }

  export type testimonialCreateManyUserInputEnvelope = {
    data: testimonialCreateManyUserInput | testimonialCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type adminactionlogUpsertWithWhereUniqueWithoutUserInput = {
    where: adminactionlogWhereUniqueInput
    update: XOR<adminactionlogUpdateWithoutUserInput, adminactionlogUncheckedUpdateWithoutUserInput>
    create: XOR<adminactionlogCreateWithoutUserInput, adminactionlogUncheckedCreateWithoutUserInput>
  }

  export type adminactionlogUpdateWithWhereUniqueWithoutUserInput = {
    where: adminactionlogWhereUniqueInput
    data: XOR<adminactionlogUpdateWithoutUserInput, adminactionlogUncheckedUpdateWithoutUserInput>
  }

  export type adminactionlogUpdateManyWithWhereWithoutUserInput = {
    where: adminactionlogScalarWhereInput
    data: XOR<adminactionlogUpdateManyMutationInput, adminactionlogUncheckedUpdateManyWithoutUserInput>
  }

  export type adminactionlogScalarWhereInput = {
    AND?: adminactionlogScalarWhereInput | adminactionlogScalarWhereInput[]
    OR?: adminactionlogScalarWhereInput[]
    NOT?: adminactionlogScalarWhereInput | adminactionlogScalarWhereInput[]
    id?: StringFilter<"adminactionlog"> | string
    timestamp?: DateTimeFilter<"adminactionlog"> | Date | string
    adminId?: StringFilter<"adminactionlog"> | string
    adminName?: StringFilter<"adminactionlog"> | string
    action?: StringFilter<"adminactionlog"> | string
    targetId?: StringNullableFilter<"adminactionlog"> | string | null
    details?: StringNullableFilter<"adminactionlog"> | string | null
  }

  export type churchmemberUpsertWithoutUserInput = {
    update: XOR<churchmemberUpdateWithoutUserInput, churchmemberUncheckedUpdateWithoutUserInput>
    create: XOR<churchmemberCreateWithoutUserInput, churchmemberUncheckedCreateWithoutUserInput>
    where?: churchmemberWhereInput
  }

  export type churchmemberUpdateToOneWithWhereWithoutUserInput = {
    where?: churchmemberWhereInput
    data: XOR<churchmemberUpdateWithoutUserInput, churchmemberUncheckedUpdateWithoutUserInput>
  }

  export type churchmemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baptismDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMembers?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActiveMember?: BoolFieldUpdateOperationsInput | boolean
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type churchmemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    memberSince?: DateTimeFieldUpdateOperationsInput | Date | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    baptismDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMembers?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActiveMember?: BoolFieldUpdateOperationsInput | boolean
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentUpsertWithWhereUniqueWithoutUserInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutUserInput, commentUncheckedUpdateWithoutUserInput>
    create: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput>
  }

  export type commentUpdateWithWhereUniqueWithoutUserInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutUserInput, commentUncheckedUpdateWithoutUserInput>
  }

  export type commentUpdateManyWithWhereWithoutUserInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutUserInput>
  }

  export type friendshipUpsertWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput = {
    where: friendshipWhereUniqueInput
    update: XOR<friendshipUpdateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_addresseeIdTouserInput>
    create: XOR<friendshipCreateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_addresseeIdTouserInput>
  }

  export type friendshipUpdateWithWhereUniqueWithoutUser_friendship_addresseeIdTouserInput = {
    where: friendshipWhereUniqueInput
    data: XOR<friendshipUpdateWithoutUser_friendship_addresseeIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_addresseeIdTouserInput>
  }

  export type friendshipUpdateManyWithWhereWithoutUser_friendship_addresseeIdTouserInput = {
    where: friendshipScalarWhereInput
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserInput>
  }

  export type friendshipScalarWhereInput = {
    AND?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
    OR?: friendshipScalarWhereInput[]
    NOT?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
    id?: StringFilter<"friendship"> | string
    requesterId?: StringFilter<"friendship"> | string
    addresseeId?: StringFilter<"friendship"> | string
    status?: Enumfriendship_statusFilter<"friendship"> | $Enums.friendship_status
    requestedAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeFilter<"friendship"> | Date | string
  }

  export type friendshipUpsertWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput = {
    where: friendshipWhereUniqueInput
    update: XOR<friendshipUpdateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_requesterIdTouserInput>
    create: XOR<friendshipCreateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_requesterIdTouserInput>
  }

  export type friendshipUpdateWithWhereUniqueWithoutUser_friendship_requesterIdTouserInput = {
    where: friendshipWhereUniqueInput
    data: XOR<friendshipUpdateWithoutUser_friendship_requesterIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_requesterIdTouserInput>
  }

  export type friendshipUpdateManyWithWhereWithoutUser_friendship_requesterIdTouserInput = {
    where: friendshipScalarWhereInput
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserInput>
  }

  export type frontendactivitylogUpsertWithWhereUniqueWithoutUserInput = {
    where: frontendactivitylogWhereUniqueInput
    update: XOR<frontendactivitylogUpdateWithoutUserInput, frontendactivitylogUncheckedUpdateWithoutUserInput>
    create: XOR<frontendactivitylogCreateWithoutUserInput, frontendactivitylogUncheckedCreateWithoutUserInput>
  }

  export type frontendactivitylogUpdateWithWhereUniqueWithoutUserInput = {
    where: frontendactivitylogWhereUniqueInput
    data: XOR<frontendactivitylogUpdateWithoutUserInput, frontendactivitylogUncheckedUpdateWithoutUserInput>
  }

  export type frontendactivitylogUpdateManyWithWhereWithoutUserInput = {
    where: frontendactivitylogScalarWhereInput
    data: XOR<frontendactivitylogUpdateManyMutationInput, frontendactivitylogUncheckedUpdateManyWithoutUserInput>
  }

  export type frontendactivitylogScalarWhereInput = {
    AND?: frontendactivitylogScalarWhereInput | frontendactivitylogScalarWhereInput[]
    OR?: frontendactivitylogScalarWhereInput[]
    NOT?: frontendactivitylogScalarWhereInput | frontendactivitylogScalarWhereInput[]
    id?: StringFilter<"frontendactivitylog"> | string
    timestamp?: DateTimeFilter<"frontendactivitylog"> | Date | string
    userId?: StringNullableFilter<"frontendactivitylog"> | string | null
    description?: StringFilter<"frontendactivitylog"> | string
    type?: StringFilter<"frontendactivitylog"> | string
    itemId?: StringNullableFilter<"frontendactivitylog"> | string | null
    itemType?: StringNullableFilter<"frontendactivitylog"> | string | null
  }

  export type groupmemberUpsertWithWhereUniqueWithoutUserInput = {
    where: groupmemberWhereUniqueInput
    update: XOR<groupmemberUpdateWithoutUserInput, groupmemberUncheckedUpdateWithoutUserInput>
    create: XOR<groupmemberCreateWithoutUserInput, groupmemberUncheckedCreateWithoutUserInput>
  }

  export type groupmemberUpdateWithWhereUniqueWithoutUserInput = {
    where: groupmemberWhereUniqueInput
    data: XOR<groupmemberUpdateWithoutUserInput, groupmemberUncheckedUpdateWithoutUserInput>
  }

  export type groupmemberUpdateManyWithWhereWithoutUserInput = {
    where: groupmemberScalarWhereInput
    data: XOR<groupmemberUpdateManyMutationInput, groupmemberUncheckedUpdateManyWithoutUserInput>
  }

  export type groupmessageUpsertWithWhereUniqueWithoutUserInput = {
    where: groupmessageWhereUniqueInput
    update: XOR<groupmessageUpdateWithoutUserInput, groupmessageUncheckedUpdateWithoutUserInput>
    create: XOR<groupmessageCreateWithoutUserInput, groupmessageUncheckedCreateWithoutUserInput>
  }

  export type groupmessageUpdateWithWhereUniqueWithoutUserInput = {
    where: groupmessageWhereUniqueInput
    data: XOR<groupmessageUpdateWithoutUserInput, groupmessageUncheckedUpdateWithoutUserInput>
  }

  export type groupmessageUpdateManyWithWhereWithoutUserInput = {
    where: groupmessageScalarWhereInput
    data: XOR<groupmessageUpdateManyMutationInput, groupmessageUncheckedUpdateManyWithoutUserInput>
  }

  export type ministryjoinrequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ministryjoinrequestWhereUniqueInput
    update: XOR<ministryjoinrequestUpdateWithoutUserInput, ministryjoinrequestUncheckedUpdateWithoutUserInput>
    create: XOR<ministryjoinrequestCreateWithoutUserInput, ministryjoinrequestUncheckedCreateWithoutUserInput>
  }

  export type ministryjoinrequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ministryjoinrequestWhereUniqueInput
    data: XOR<ministryjoinrequestUpdateWithoutUserInput, ministryjoinrequestUncheckedUpdateWithoutUserInput>
  }

  export type ministryjoinrequestUpdateManyWithWhereWithoutUserInput = {
    where: ministryjoinrequestScalarWhereInput
    data: XOR<ministryjoinrequestUpdateManyMutationInput, ministryjoinrequestUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
  }

  export type notificationUpdateManyWithWhereWithoutUserInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: StringFilter<"notification"> | string
    targetUserId?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    link?: StringNullableFilter<"notification"> | string | null
    timestamp?: DateTimeFilter<"notification"> | Date | string
    read?: BoolFilter<"notification"> | boolean
    type?: Enumnotification_typeFilter<"notification"> | $Enums.notification_type
  }

  export type prayerUpsertWithWhereUniqueWithoutUserInput = {
    where: prayerWhereUniqueInput
    update: XOR<prayerUpdateWithoutUserInput, prayerUncheckedUpdateWithoutUserInput>
    create: XOR<prayerCreateWithoutUserInput, prayerUncheckedCreateWithoutUserInput>
  }

  export type prayerUpdateWithWhereUniqueWithoutUserInput = {
    where: prayerWhereUniqueInput
    data: XOR<prayerUpdateWithoutUserInput, prayerUncheckedUpdateWithoutUserInput>
  }

  export type prayerUpdateManyWithWhereWithoutUserInput = {
    where: prayerScalarWhereInput
    data: XOR<prayerUpdateManyMutationInput, prayerUncheckedUpdateManyWithoutUserInput>
  }

  export type prayerrequestUpsertWithWhereUniqueWithoutUserInput = {
    where: prayerrequestWhereUniqueInput
    update: XOR<prayerrequestUpdateWithoutUserInput, prayerrequestUncheckedUpdateWithoutUserInput>
    create: XOR<prayerrequestCreateWithoutUserInput, prayerrequestUncheckedCreateWithoutUserInput>
  }

  export type prayerrequestUpdateWithWhereUniqueWithoutUserInput = {
    where: prayerrequestWhereUniqueInput
    data: XOR<prayerrequestUpdateWithoutUserInput, prayerrequestUncheckedUpdateWithoutUserInput>
  }

  export type prayerrequestUpdateManyWithWhereWithoutUserInput = {
    where: prayerrequestScalarWhereInput
    data: XOR<prayerrequestUpdateManyMutationInput, prayerrequestUncheckedUpdateManyWithoutUserInput>
  }

  export type prayerrequestScalarWhereInput = {
    AND?: prayerrequestScalarWhereInput | prayerrequestScalarWhereInput[]
    OR?: prayerrequestScalarWhereInput[]
    NOT?: prayerrequestScalarWhereInput | prayerrequestScalarWhereInput[]
    id?: StringFilter<"prayerrequest"> | string
    userId?: StringNullableFilter<"prayerrequest"> | string | null
    userName?: StringNullableFilter<"prayerrequest"> | string | null
    userProfileImageUrl?: StringNullableFilter<"prayerrequest"> | string | null
    title?: StringFilter<"prayerrequest"> | string
    requestText?: StringFilter<"prayerrequest"> | string
    visibility?: Enumprayerrequest_visibilityFilter<"prayerrequest"> | $Enums.prayerrequest_visibility
    category?: Enumprayerrequest_categoryNullableFilter<"prayerrequest"> | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFilter<"prayerrequest"> | $Enums.prayerrequest_status
    submittedAt?: DateTimeFilter<"prayerrequest"> | Date | string
    lastPrayedAt?: DateTimeNullableFilter<"prayerrequest"> | Date | string | null
    adminNotes?: StringNullableFilter<"prayerrequest"> | string | null
    postedByOwnerId?: StringNullableFilter<"prayerrequest"> | string | null
    postedByOwnerName?: StringNullableFilter<"prayerrequest"> | string | null
    createdAt?: DateTimeFilter<"prayerrequest"> | Date | string
    updatedAt?: DateTimeFilter<"prayerrequest"> | Date | string
    mediaUrls?: JsonNullableFilter<"prayerrequest">
    location?: StringNullableFilter<"prayerrequest"> | string | null
    taggedFriends?: StringNullableFilter<"prayerrequest"> | string | null
    feelingActivity?: StringNullableFilter<"prayerrequest"> | string | null
    backgroundTheme?: StringNullableFilter<"prayerrequest"> | string | null
  }

  export type testimonialUpsertWithWhereUniqueWithoutUserInput = {
    where: testimonialWhereUniqueInput
    update: XOR<testimonialUpdateWithoutUserInput, testimonialUncheckedUpdateWithoutUserInput>
    create: XOR<testimonialCreateWithoutUserInput, testimonialUncheckedCreateWithoutUserInput>
  }

  export type testimonialUpdateWithWhereUniqueWithoutUserInput = {
    where: testimonialWhereUniqueInput
    data: XOR<testimonialUpdateWithoutUserInput, testimonialUncheckedUpdateWithoutUserInput>
  }

  export type testimonialUpdateManyWithWhereWithoutUserInput = {
    where: testimonialScalarWhereInput
    data: XOR<testimonialUpdateManyMutationInput, testimonialUncheckedUpdateManyWithoutUserInput>
  }

  export type testimonialScalarWhereInput = {
    AND?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
    OR?: testimonialScalarWhereInput[]
    NOT?: testimonialScalarWhereInput | testimonialScalarWhereInput[]
    id?: StringFilter<"testimonial"> | string
    userId?: StringFilter<"testimonial"> | string
    userName?: StringFilter<"testimonial"> | string
    userProfileImageUrl?: StringNullableFilter<"testimonial"> | string | null
    title?: StringFilter<"testimonial"> | string
    contentText?: StringFilter<"testimonial"> | string
    visibility?: Enumtestimonial_visibilityFilter<"testimonial"> | $Enums.testimonial_visibility
    submittedAt?: DateTimeFilter<"testimonial"> | Date | string
    postedByOwnerId?: StringNullableFilter<"testimonial"> | string | null
    postedByOwnerName?: StringNullableFilter<"testimonial"> | string | null
    createdAt?: DateTimeFilter<"testimonial"> | Date | string
    updatedAt?: DateTimeFilter<"testimonial"> | Date | string
    mediaUrls?: JsonNullableFilter<"testimonial">
    location?: StringNullableFilter<"testimonial"> | string | null
    taggedFriends?: StringNullableFilter<"testimonial"> | string | null
    feelingActivity?: StringNullableFilter<"testimonial"> | string | null
    backgroundTheme?: StringNullableFilter<"testimonial"> | string | null
  }

  export type commentCreateManyBlogpostInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentUpdateWithoutBlogpostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventitem?: eventitemUpdateOneWithoutCommentNestedInput
    historychapter?: historychapterUpdateOneWithoutCommentNestedInput
    newsitem?: newsitemUpdateOneWithoutCommentNestedInput
    prayerrequest?: prayerrequestUpdateOneWithoutCommentNestedInput
    sermon?: sermonUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneRequiredWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutBlogpostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutBlogpostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donordetailCreateManyCollectionrecordInput = {
    id: string
    donorName: string
    amount: Decimal | DecimalJsLike | number | string
    address?: string | null
    contact?: string | null
  }

  export type donordetailUpdateWithoutCollectionrecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donordetailUncheckedUpdateWithoutCollectionrecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type donordetailUncheckedUpdateManyWithoutCollectionrecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    donorName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentCreateManyEventitemInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentUpdateWithoutEventitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogpost?: blogpostUpdateOneWithoutCommentNestedInput
    historychapter?: historychapterUpdateOneWithoutCommentNestedInput
    newsitem?: newsitemUpdateOneWithoutCommentNestedInput
    prayerrequest?: prayerrequestUpdateOneWithoutCommentNestedInput
    sermon?: sermonUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneRequiredWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutEventitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutEventitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type generatedscheduleitemCreateManyFellowshiprosteritemInput = {
    id: string
    rosterType: $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle: string
    scheduledDate: Date | string
    timeSlot: string
    location?: string | null
    contactNumber?: string | null
    additionalNotesOrProgramDetails?: string | null
    generatedAt?: Date | string
    isPublishedAsEvent?: boolean
    publishedEventId?: string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type responsibilityCreateManyFellowshiprosteritemInput = {
    id: string
    role: string
    assignedTo: string
    generatedScheduleId?: string | null
  }

  export type generatedscheduleitemUpdateWithoutFellowshiprosteritemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibility?: responsibilityUpdateManyWithoutGeneratedscheduleitemNestedInput
  }

  export type generatedscheduleitemUncheckedUpdateWithoutFellowshiprosteritemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsibility?: responsibilityUncheckedUpdateManyWithoutGeneratedscheduleitemNestedInput
  }

  export type generatedscheduleitemUncheckedUpdateManyWithoutFellowshiprosteritemInput = {
    id?: StringFieldUpdateOperationsInput | string
    rosterType?: Enumgeneratedscheduleitem_rosterTypeFieldUpdateOperationsInput | $Enums.generatedscheduleitem_rosterType
    groupNameOrEventTitle?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSlot?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    additionalNotesOrProgramDetails?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublishedAsEvent?: BoolFieldUpdateOperationsInput | boolean
    publishedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type responsibilityUpdateWithoutFellowshiprosteritemInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    generatedscheduleitem?: generatedscheduleitemUpdateOneWithoutResponsibilityNestedInput
  }

  export type responsibilityUncheckedUpdateWithoutFellowshiprosteritemInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    generatedScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilityUncheckedUpdateManyWithoutFellowshiprosteritemInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    generatedScheduleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilityCreateManyGeneratedscheduleitemInput = {
    id: string
    role: string
    assignedTo: string
    rosterItemId?: string | null
  }

  export type responsibilityUpdateWithoutGeneratedscheduleitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    fellowshiprosteritem?: fellowshiprosteritemUpdateOneWithoutResponsibilityNestedInput
  }

  export type responsibilityUncheckedUpdateWithoutGeneratedscheduleitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    rosterItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type responsibilityUncheckedUpdateManyWithoutGeneratedscheduleitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    rosterItemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupmemberCreateManyGroupInput = {
    id: string
    userId: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
  }

  export type groupmessageCreateManyGroupInput = {
    id: string
    senderId: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
  }

  export type groupmemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutGroupmemberNestedInput
  }

  export type groupmemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmessageUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutGroupmessageNestedInput
  }

  export type groupmessageUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmessageUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentCreateManyHistorychapterInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    prayerRequestId?: string | null
  }

  export type commentUpdateWithoutHistorychapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogpost?: blogpostUpdateOneWithoutCommentNestedInput
    eventitem?: eventitemUpdateOneWithoutCommentNestedInput
    newsitem?: newsitemUpdateOneWithoutCommentNestedInput
    prayerrequest?: prayerrequestUpdateOneWithoutCommentNestedInput
    sermon?: sermonUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneRequiredWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutHistorychapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutHistorychapterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type meetingdecisionpointCreateManyMeetinglogInput = {
    id: string
    description: string
    proposedBy?: string | null
    status: $Enums.meetingdecisionpoint_status
    followUpNotes?: string | null
    resolutionDate?: Date | string | null
  }

  export type meetingdecisionpointUpdateWithoutMeetinglogInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummeetingdecisionpoint_statusFieldUpdateOperationsInput | $Enums.meetingdecisionpoint_status
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type meetingdecisionpointUncheckedUpdateWithoutMeetinglogInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummeetingdecisionpoint_statusFieldUpdateOperationsInput | $Enums.meetingdecisionpoint_status
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type meetingdecisionpointUncheckedUpdateManyWithoutMeetinglogInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    proposedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummeetingdecisionpoint_statusFieldUpdateOperationsInput | $Enums.meetingdecisionpoint_status
    followUpNotes?: NullableStringFieldUpdateOperationsInput | string | null
    resolutionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ministryjoinrequestCreateManyMinistryInput = {
    id: string
    userId: string
    userName: string
    userEmail: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
  }

  export type ministryjoinrequestUpdateWithoutMinistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutMinistryjoinrequestNestedInput
  }

  export type ministryjoinrequestUncheckedUpdateWithoutMinistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ministryjoinrequestUncheckedUpdateManyWithoutMinistryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentCreateManyNewsitemInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentUpdateWithoutNewsitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogpost?: blogpostUpdateOneWithoutCommentNestedInput
    eventitem?: eventitemUpdateOneWithoutCommentNestedInput
    historychapter?: historychapterUpdateOneWithoutCommentNestedInput
    prayerrequest?: prayerrequestUpdateOneWithoutCommentNestedInput
    sermon?: sermonUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneRequiredWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutNewsitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutNewsitemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentCreateManyPrayerrequestInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
  }

  export type prayerCreateManyPrayerrequestInput = {
    id: string
    userId: string
    userName: string
    timestamp?: Date | string
  }

  export type commentUpdateWithoutPrayerrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogpost?: blogpostUpdateOneWithoutCommentNestedInput
    eventitem?: eventitemUpdateOneWithoutCommentNestedInput
    historychapter?: historychapterUpdateOneWithoutCommentNestedInput
    newsitem?: newsitemUpdateOneWithoutCommentNestedInput
    sermon?: sermonUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneRequiredWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutPrayerrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutPrayerrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prayerUpdateWithoutPrayerrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutPrayerNestedInput
  }

  export type prayerUncheckedUpdateWithoutPrayerrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type prayerUncheckedUpdateManyWithoutPrayerrequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentCreateManySermonInput = {
    id: string
    userId: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type commentUpdateWithoutSermonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogpost?: blogpostUpdateOneWithoutCommentNestedInput
    eventitem?: eventitemUpdateOneWithoutCommentNestedInput
    historychapter?: historychapterUpdateOneWithoutCommentNestedInput
    newsitem?: newsitemUpdateOneWithoutCommentNestedInput
    prayerrequest?: prayerrequestUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneRequiredWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutSermonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutSermonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adminactionlogCreateManyUserInput = {
    id: string
    timestamp?: Date | string
    adminName: string
    action: string
    targetId?: string | null
    details?: string | null
  }

  export type commentCreateManyUserInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    text: string
    timestamp?: Date | string
    editedAt?: Date | string | null
    sermonId?: string | null
    eventId?: string | null
    blogPostId?: string | null
    newsItemId?: string | null
    historyChapterId?: string | null
    prayerRequestId?: string | null
  }

  export type friendshipCreateManyUser_friendship_addresseeIdTouserInput = {
    id: string
    requesterId: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type friendshipCreateManyUser_friendship_requesterIdTouserInput = {
    id: string
    addresseeId: string
    status: $Enums.friendship_status
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type frontendactivitylogCreateManyUserInput = {
    id: string
    timestamp?: Date | string
    description: string
    type: string
    itemId?: string | null
    itemType?: string | null
  }

  export type groupmemberCreateManyUserInput = {
    id: string
    groupId: string
    role: $Enums.groupmember_role
    addedAt?: Date | string
  }

  export type groupmessageCreateManyUserInput = {
    id: string
    groupId: string
    senderName: string
    senderProfileImageUrl?: string | null
    text?: string | null
    mediaUrl?: string | null
    mediaType?: $Enums.groupmessage_mediaType | null
    timestamp?: Date | string
  }

  export type ministryjoinrequestCreateManyUserInput = {
    id: string
    userName: string
    userEmail: string
    ministryId: string
    ministryName: string
    ministryGuidelines: string
    requestDate?: Date | string
    message: string
    status?: $Enums.ministryjoinrequest_status
    processedDate?: Date | string | null
    adminNotes?: string | null
  }

  export type notificationCreateManyUserInput = {
    id: string
    message: string
    link?: string | null
    timestamp?: Date | string
    read?: boolean
    type: $Enums.notification_type
  }

  export type prayerCreateManyUserInput = {
    id: string
    userName: string
    timestamp?: Date | string
    prayerRequestId: string
  }

  export type prayerrequestCreateManyUserInput = {
    id: string
    userName?: string | null
    userProfileImageUrl?: string | null
    title: string
    requestText: string
    visibility: $Enums.prayerrequest_visibility
    category?: $Enums.prayerrequest_category | null
    status?: $Enums.prayerrequest_status
    submittedAt?: Date | string
    lastPrayedAt?: Date | string | null
    adminNotes?: string | null
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
  }

  export type testimonialCreateManyUserInput = {
    id: string
    userName: string
    userProfileImageUrl?: string | null
    title: string
    contentText: string
    visibility: $Enums.testimonial_visibility
    submittedAt?: Date | string
    postedByOwnerId?: string | null
    postedByOwnerName?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: string | null
    taggedFriends?: string | null
    feelingActivity?: string | null
    backgroundTheme?: string | null
  }

  export type adminactionlogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adminactionlogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adminactionlogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    adminName?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blogpost?: blogpostUpdateOneWithoutCommentNestedInput
    eventitem?: eventitemUpdateOneWithoutCommentNestedInput
    historychapter?: historychapterUpdateOneWithoutCommentNestedInput
    newsitem?: newsitemUpdateOneWithoutCommentNestedInput
    prayerrequest?: prayerrequestUpdateOneWithoutCommentNestedInput
    sermon?: sermonUpdateOneWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sermonId?: NullableStringFieldUpdateOperationsInput | string | null
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: NullableStringFieldUpdateOperationsInput | string | null
    newsItemId?: NullableStringFieldUpdateOperationsInput | string | null
    historyChapterId?: NullableStringFieldUpdateOperationsInput | string | null
    prayerRequestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendshipUpdateWithoutUser_friendship_addresseeIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_friendship_requesterIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_requesterIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateWithoutUser_friendship_addresseeIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_addresseeIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type friendshipUpdateWithoutUser_friendship_requesterIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_friendship_addresseeIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_addresseeIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateWithoutUser_friendship_requesterIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_requesterIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: Enumfriendship_statusFieldUpdateOperationsInput | $Enums.friendship_status
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type frontendactivitylogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type frontendactivitylogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type frontendactivitylogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupmemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: groupUpdateOneRequiredWithoutGroupmemberNestedInput
  }

  export type groupmemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: Enumgroupmember_roleFieldUpdateOperationsInput | $Enums.groupmember_role
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: groupUpdateOneRequiredWithoutGroupmessageNestedInput
  }

  export type groupmessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type groupmessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mediaType?: NullableEnumgroupmessage_mediaTypeFieldUpdateOperationsInput | $Enums.groupmessage_mediaType | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ministryjoinrequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ministry?: ministryUpdateOneRequiredWithoutMinistryjoinrequestNestedInput
  }

  export type ministryjoinrequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryId?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ministryjoinrequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    ministryId?: StringFieldUpdateOperationsInput | string
    ministryName?: StringFieldUpdateOperationsInput | string
    ministryGuidelines?: StringFieldUpdateOperationsInput | string
    requestDate?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    status?: Enumministryjoinrequest_statusFieldUpdateOperationsInput | $Enums.ministryjoinrequest_status
    processedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
  }

  export type notificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
  }

  export type notificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
  }

  export type prayerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    prayerrequest?: prayerrequestUpdateOneRequiredWithoutPrayerNestedInput
  }

  export type prayerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    prayerRequestId?: StringFieldUpdateOperationsInput | string
  }

  export type prayerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    prayerRequestId?: StringFieldUpdateOperationsInput | string
  }

  export type prayerrequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUpdateManyWithoutPrayerrequestNestedInput
    prayer?: prayerUpdateManyWithoutPrayerrequestNestedInput
  }

  export type prayerrequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUncheckedUpdateManyWithoutPrayerrequestNestedInput
    prayer?: prayerUncheckedUpdateManyWithoutPrayerrequestNestedInput
  }

  export type prayerrequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    requestText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumprayerrequest_visibilityFieldUpdateOperationsInput | $Enums.prayerrequest_visibility
    category?: NullableEnumprayerrequest_categoryFieldUpdateOperationsInput | $Enums.prayerrequest_category | null
    status?: Enumprayerrequest_statusFieldUpdateOperationsInput | $Enums.prayerrequest_status
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPrayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testimonialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumtestimonial_visibilityFieldUpdateOperationsInput | $Enums.testimonial_visibility
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testimonialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumtestimonial_visibilityFieldUpdateOperationsInput | $Enums.testimonial_visibility
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testimonialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    userProfileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    contentText?: StringFieldUpdateOperationsInput | string
    visibility?: Enumtestimonial_visibilityFieldUpdateOperationsInput | $Enums.testimonial_visibility
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByOwnerId?: NullableStringFieldUpdateOperationsInput | string | null
    postedByOwnerName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrls?: NullableJsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    taggedFriends?: NullableStringFieldUpdateOperationsInput | string | null
    feelingActivity?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundTheme?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use BlogpostCountOutputTypeDefaultArgs instead
     */
    export type BlogpostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogpostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CollectionrecordCountOutputTypeDefaultArgs instead
     */
    export type CollectionrecordCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollectionrecordCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventitemCountOutputTypeDefaultArgs instead
     */
    export type EventitemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventitemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FellowshiprosteritemCountOutputTypeDefaultArgs instead
     */
    export type FellowshiprosteritemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FellowshiprosteritemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GeneratedscheduleitemCountOutputTypeDefaultArgs instead
     */
    export type GeneratedscheduleitemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GeneratedscheduleitemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistorychapterCountOutputTypeDefaultArgs instead
     */
    export type HistorychapterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistorychapterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetinglogCountOutputTypeDefaultArgs instead
     */
    export type MeetinglogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetinglogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinistryCountOutputTypeDefaultArgs instead
     */
    export type MinistryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinistryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NewsitemCountOutputTypeDefaultArgs instead
     */
    export type NewsitemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NewsitemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrayerrequestCountOutputTypeDefaultArgs instead
     */
    export type PrayerrequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrayerrequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SermonCountOutputTypeDefaultArgs instead
     */
    export type SermonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SermonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use aboutsectionDefaultArgs instead
     */
    export type aboutsectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = aboutsectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use adminactionlogDefaultArgs instead
     */
    export type adminactionlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = adminactionlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use advertisementDefaultArgs instead
     */
    export type advertisementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = advertisementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use blogpostDefaultArgs instead
     */
    export type blogpostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = blogpostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use branchchurchDefaultArgs instead
     */
    export type branchchurchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = branchchurchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use churchmemberDefaultArgs instead
     */
    export type churchmemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = churchmemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use collectionrecordDefaultArgs instead
     */
    export type collectionrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = collectionrecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use commentDefaultArgs instead
     */
    export type commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = commentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contactmessageDefaultArgs instead
     */
    export type contactmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contactmessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use decisionlogDefaultArgs instead
     */
    export type decisionlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = decisionlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use directmediaitemDefaultArgs instead
     */
    export type directmediaitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = directmediaitemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use donatepagecontentDefaultArgs instead
     */
    export type donatepagecontentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = donatepagecontentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use donationrecordDefaultArgs instead
     */
    export type donationrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = donationrecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use donordetailDefaultArgs instead
     */
    export type donordetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = donordetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use eventitemDefaultArgs instead
     */
    export type eventitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = eventitemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use expenserecordDefaultArgs instead
     */
    export type expenserecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = expenserecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use fellowshiprosteritemDefaultArgs instead
     */
    export type fellowshiprosteritemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = fellowshiprosteritemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use friendshipDefaultArgs instead
     */
    export type friendshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = friendshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use frontendactivitylogDefaultArgs instead
     */
    export type frontendactivitylogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = frontendactivitylogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use generatedscheduleitemDefaultArgs instead
     */
    export type generatedscheduleitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = generatedscheduleitemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groupDefaultArgs instead
     */
    export type groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groupmemberDefaultArgs instead
     */
    export type groupmemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groupmemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groupmessageDefaultArgs instead
     */
    export type groupmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groupmessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use historychapterDefaultArgs instead
     */
    export type historychapterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = historychapterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use historymilestoneDefaultArgs instead
     */
    export type historymilestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = historymilestoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use homeslideDefaultArgs instead
     */
    export type homeslideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = homeslideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use keypersonDefaultArgs instead
     */
    export type keypersonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = keypersonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use meetingdecisionpointDefaultArgs instead
     */
    export type meetingdecisionpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = meetingdecisionpointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use meetinglogDefaultArgs instead
     */
    export type meetinglogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = meetinglogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ministryDefaultArgs instead
     */
    export type ministryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ministryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ministryjoinrequestDefaultArgs instead
     */
    export type ministryjoinrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ministryjoinrequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use monthlythemeimageDefaultArgs instead
     */
    export type monthlythemeimageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = monthlythemeimageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use newsitemDefaultArgs instead
     */
    export type newsitemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = newsitemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationDefaultArgs instead
     */
    export type notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prayerDefaultArgs instead
     */
    export type prayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use prayerrequestDefaultArgs instead
     */
    export type prayerrequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = prayerrequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use responsibilityDefaultArgs instead
     */
    export type responsibilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = responsibilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sermonDefaultArgs instead
     */
    export type sermonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sermonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use testimonialDefaultArgs instead
     */
    export type testimonialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = testimonialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}